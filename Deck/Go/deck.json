{
    "__type__": "Deck",
    "children": [],
    "crowdanki_uuid": "2c88cdfa-4e0f-11ec-899d-d45d6450590b",
    "deck_config_uuid": "6b7a6e06-8f2e-11eb-9b16-d45d6450590b",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "autoAgain": 0,
            "autoAlert": 0,
            "autoAnswer": 0,
            "autoplay": true,
            "crowdanki_uuid": "6b7a6e06-8f2e-11eb-9b16-d45d6450590b",
            "dyn": false,
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.0
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": false,
                "delays": [
                    1.0,
                    10.0,
                    1440.0
                ],
                "initialFactor": 2500,
                "ints": [
                    3,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 9999,
                "retirementActions": {
                    "delete": false,
                    "move": false,
                    "suspend": true,
                    "tag": true
                },
                "retiringInterval": 0,
                "separate": true,
                "weeklySchedule": [
                    true,
                    true,
                    true,
                    true,
                    true,
                    true,
                    true
                ]
            },
            "newGatherPriority": 0,
            "newMix": 1,
            "newPerDayMinimum": 0,
            "newSortOrder": 3,
            "replayq": true,
            "rev": {
                "bury": true,
                "ease4": 1.3,
                "fuzz": 0.05,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "minSpace": 1,
                "perDay": 9999
            },
            "reviewOrder": 0,
            "timer": 0
        }
    ],
    "desc": "",
    "dyn": 0,
    "extendNew": 0,
    "extendRev": 0,
    "media_files": [
        "_shinkaya4.jpg"
    ],
    "name": "Go",
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "2c89bbe8-4e0f-11ec-899d-d45d6450590b",
            "css": "::-webkit-scrollbar {\n  display: none;\n}\n\n.night_mode {\n  background-color: black;\n}\n\n/*  a simple way to stop inverted colours on ankidroid*/\n.card {\n  color: black !important;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: -webkit-box;\n  -webkit-box-align: stretch;\n  -webkit-box-pack: center;\n  -webkit-box-orient: vertical;\n  font-size: 22px;\n  text-align: center;\n  /* ALIGN TEXT */\n}\n\n.mobile .card {\n  width: 97%\n}\n\nbody {\n  margin: 0\n}\n\n.besogo-comment>input {\n  display: none;\n}\n\n.besogo-container {\n  margin: auto;\n  outline: none;\n  display: flex;\n  background: #d0fefe;\n}\n\n.besogo-container * {\n  box-sizing: border-box;\n}\n\n.besogo-container button {\n  height: 30px;\n  width: 30px;\n  padding: 0px;\n  background: #d8dcd6;\n}\n\n.besogo-container input {\n  font-size: 12pt;\n}\n\n.besogo-container input[type='button'] {\n  background: #d8dcd6;\n}\n\n.besogo-container input[type='text'] {\n  width: 30px;\n}\n\n.besogo-container svg {\n  /* Prevent text selection within SVG */\n  -webkit-touch-callout: none;\n  /* iOS Safari */\n  -webkit-user-select: none;\n  /* Chrome/Safari/Opera */\n  -moz-user-select: none;\n  /* Firefox */\n  -ms-user-select: none;\n  /* Internet Explorer/Edge */\n  user-select: none;\n}\n\n.besogo-panels {\n  flex-direction: column;\n  align-items: center;\n  padding: 0px 5px;\n}\n\n.besogo-panels>* {\n  margin: 3px 0px;\n}\n\n.besogo-control {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  justify-content: space-around;\n  width: 100%;\n  flex: 0 0 auto;\n}\n\n.besogo-names {\n  flex: 0 0 auto;\n  width: 100%;\n}\n\n.besogo-playerInfo {\n  display: flex;\n  font-family: Tahoma, Geneva, sans-serif;\n  white-space: pre-wrap;\n}\n\n.besogo-blackInfo {\n  flex: 50%;\n  color: white;\n  background: black;\n  text-align: right;\n  padding: 5px;\n}\n\n.besogo-whiteInfo {\n  flex: 50%;\n  color: black;\n  background: white;\n  text-align: left;\n  padding: 5px;\n}\n\n.besogo-blackCaps {\n  float: left;\n}\n\n.besogo-whiteCaps {\n  float: right;\n}\n\n.besogo-comment {\n  font-family: Georgia, serif;\n  font-size: 12pt;\n  white-space: pre-wrap;\n  overflow: auto;\n  flex: 1 1 60%;\n  width: 100%;\n}\n\n.besogo-comment input[type='button'] {\n  float: right;\n}\n\n.besogo-comment textarea {\n  height: 100%;\n  width: 100%;\n}\n\n.besogo-gameInfo {\n  padding: 5px;\n  border-collapse: collapse;\n}\n\n.besogo-gameInfo td, tr {\n  border: 1px solid black;\n  padding: 3px;\n}\n\n.besogo-tool {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  justify-content: space-around;\n  width: 100%;\n  flex: 0 0 auto;\n}\n\n.besogo-tree {\n  overflow: auto;\n  flex: 1 1 40%;\n  width: 100%;\n}\n\n.besogo-file {\n  display: none;\n  flex: 0 0 auto;\n}\n\n/* Kaya board theme */\n.besogo-svg-board {\n  fill: none;\n}\n\n.besogo-svg-backer {\n  fill: #fcbc5b;\n}\n\n.besogo-board {\n  background: url(\"_shinkaya4.jpg\");\n  background-size: cover;\n}\n\n.besogo-svg-lines {\n  stroke: #151515;\n  stroke-width: 2.5;\n  fill: none;\n}\n\n.besogo-svg-hoshi {\n  stroke: #151515;\n  stroke-width: 12;\n}\n\n.besogo-svg-blackStone {\n  fill: #252525;\n  stroke: #252525;\n  stroke-width: 4;\n}\n\n.besogo-svg-whiteStone {\n  fill: #f5f5f5;\n  stroke: #f5f5f5;\n  stroke-width: 4;\n}\n\n.besogo-svg-greyStone {\n  fill: #929591;\n  stroke: #929591;\n  stroke-width: 4;\n}",
            "flds": [
                {
                    "font": "MS Shell Dlg 2",
                    "media": [],
                    "meta": null,
                    "name": "SGF",
                    "ord": 0,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Go opponents moves",
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [
                "Go::test"
            ],
            "tmpls": [
                {
                    "afmt": "<script>\n// v1.0.0 - https://github.com/SimonLammer/anki-persistence/blob/cd2ca88e019dc3b8f32dad623932c1eabdba7e21/script.js\nif(void 0===window.Persistence){var _persistenceKey=\"github.com/SimonLammer/anki-persistence/\",_defaultKey=\"_default\";if(window.Persistence_sessionStorage=function(){var e=!1;try{\"object\"==typeof window.sessionStorage&&(e=!0,this.clear=function(){for(var e=0;e<sessionStorage.length;e++){var t=sessionStorage.key(e);0==t.indexOf(_persistenceKey)&&(sessionStorage.removeItem(t),e--)}},this.setItem=function(e,t){null==t&&(t=e,e=_defaultKey),sessionStorage.setItem(_persistenceKey+e,JSON.stringify(t))},this.getItem=function(e){return null==e&&(e=_defaultKey),JSON.parse(sessionStorage.getItem(_persistenceKey+e))},this.removeItem=function(e){null==e&&(e=_defaultKey),sessionStorage.removeItem(_persistenceKey+e)})}catch(e){}this.isAvailable=function(){return e}},window.Persistence_windowKey=function(e){var t=window[e],n=!1;\"object\"==typeof t&&(n=!0,this.clear=function(){t[_persistenceKey]={}},this.setItem=function(e,n){null==n&&(n=e,e=_defaultKey),t[_persistenceKey][e]=n},this.getItem=function(e){return null==e&&(e=_defaultKey),null==t[_persistenceKey][e]?null:t[_persistenceKey][e]},this.removeItem=function(e){null==e&&(e=_defaultKey),delete t[_persistenceKey][e]},null==t[_persistenceKey]&&this.clear()),this.isAvailable=function(){return n}},window.Persistence=new Persistence_sessionStorage,Persistence.isAvailable()||(window.Persistence=new Persistence_windowKey(\"py\")),!Persistence.isAvailable()){var titleStartIndex=window.location.toString().indexOf(\"title\"),titleContentIndex=window.location.toString().indexOf(\"main\",titleStartIndex);titleStartIndex>0&&titleContentIndex>0&&titleContentIndex-titleStartIndex<10&&(window.Persistence=new Persistence_windowKey(\"qt\"))}}\n</script>\n<div class=\"besogo-editor\" maxwidth=1200 transwidth=700>{{SGF}}</div>\n\n<script>\n\t(function() {\n\t\t'use strict';\n\t\tvar besogo = window.besogo = window.besogo || {}; // Establish our namespace\n\t\tbesogo.VERSION = '0.0.2-alpha';\n\n\t\tbesogo.create = function(container, options) {\n\t\t\tvar editor, // Core editor object\n\t\t\t\tresizer, // Auto-resizing function\n\t\t\t\tboardDiv, // Board display container\n\t\t\t\tpanelsDiv, // Parent container of panel divs\n\t\t\t\tmakers = { // Map to panel creators\n\t\t\t\t\tcontrol: besogo.makeControlPanel,\n\t\t\t\t\tnames: besogo.makeNamesPanel,\n\t\t\t\t\tcomment: besogo.makeCommentPanel,\n\t\t\t\t\ttool: besogo.makeToolPanel,\n\t\t\t\t\ttree: besogo.makeTreePanel,\n\t\t\t\t\tfile: besogo.makeFilePanel\n\t\t\t\t},\n\t\t\t\tinsideText = container.textContent || container.innerText || '',\n\t\t\t\ti, panelName; // Scratch iteration variables\n\n\t\t\tcontainer.className += ' besogo-container'; // Marks this div as initialized\n\n\t\t\t// Process options and set defaults\n\t\t\toptions = options || {}; // Makes option checking simpler\n\t\t\toptions.size = besogo.parseSize(options.size || 19);\n\t\t\toptions.coord = options.coord || 'none';\n\t\t\toptions.tool = options.tool || 'auto';\n\t\t\tif (options.panels === '') {\n\t\t\t\toptions.panels = [];\n\t\t\t}\n\t\t\toptions.panels = options.panels || 'control+names+comment+tool+tree+file';\n\t\t\tif (typeof options.panels === 'string') {\n\t\t\t\toptions.panels = options.panels.split('+');\n\t\t\t}\n\t\t\toptions.path = options.path || '';\n\t\t\tif (options.shadows === undefined) {\n\t\t\t\toptions.shadows = 'auto';\n\t\t\t} else if (options.shadows === 'off') {\n\t\t\t\toptions.shadows = false;\n\t\t\t}\n\n\t\t\t// Make the core editor object\n\t\t\teditor = besogo.makeEditor(options.size.x, options.size.y);\n\t\t\teditor.setTool(options.tool);\n\t\t\teditor.setCoordStyle(options.coord);\n\t\t\tif (options.realstones) { // Using realistic stones\n\t\t\t\teditor.REAL_STONES = true;\n\t\t\t\teditor.SHADOWS = options.shadows;\n\t\t\t} else { // SVG stones\n\t\t\t\teditor.SHADOWS = (options.shadows && options.shadows !== 'auto');\n\t\t\t}\n\n\t\t\tif (!options.nokeys) { // Add keypress handler unless nokeys option is truthy\n\t\t\t\taddKeypressHandler(container, editor);\n\t\t\t}\n\n\t\t\tif (options.sgf) { // Load SGF file from URL\n\t\t\t\ttry {\n\t\t\t\t\tfetchParseLoad(options.sgf, editor, options.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Silently fail on network error\n\t\t\t\t}\n\t\t\t} else if (insideText.match(/\\s*\\(\\s*;/)) { // Text content looks like an SGF file\n\t\t\t\tparseAndLoad(insideText, editor);\n\t\t\t\tnavigatePath(editor, options.path); // Navigate editor along path\n\t\t\t}\n\n\t\t\tif (typeof options.variants === 'number' || typeof options.variants === 'string') {\n\t\t\t\teditor.setVariantStyle(+options.variants); // Converts to number\n\t\t\t}\n\n\t\t\twhile (container.firstChild) { // Remove all children of container\n\t\t\t\tcontainer.removeChild(container.firstChild);\n\t\t\t}\n\n\t\t\tboardDiv = makeDiv('besogo-board'); // Create div for board display\n\t\t\tbesogo.makeBoardDisplay(boardDiv, editor); // Create board display\n\n\t\t\tif (!options.nowheel) { // Add mousewheel handler unless nowheel option is truthy\n\t\t\t\taddWheelHandler(boardDiv, editor);\n\t\t\t}\n\n\t\t\tif (options.panels.length > 0) { // Only create if there are panels to add\n\t\t\t\tpanelsDiv = makeDiv('besogo-panels');\n\t\t\t\tfor (i = 0; i < options.panels.length; i++) {\n\t\t\t\t\tpanelName = options.panels[i];\n\t\t\t\t\tif (makers[panelName]) { // Only add if creator function exists\n\t\t\t\t\t\tmakers[panelName](makeDiv('besogo-' + panelName, panelsDiv), editor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!panelsDiv.firstChild) { // If no panels were added\n\t\t\t\t\tcontainer.removeChild(panelsDiv); // Remove the panels div\n\t\t\t\t\tpanelsDiv = false; // Flags panels div as removed\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.resize = options.resize || 'auto';\n\t\t\tif (options.resize === 'auto') { // Add auto-resizing unless resize option is truthy\n\t\t\t\tresizer = function() {\n\t\t\t\t\tvar windowHeight = window.innerHeight, // Viewport height\n\t\t\t\t\t\t// Calculated width of parent element\n\t\t\t\t\t\tparentWidth = parseFloat(getComputedStyle(container).width),\n\t\t\t\t\t\tmaxWidth = +(options.maxwidth || -1),\n\t\t\t\t\t\torientation = options.orient || 'auto',\n\n\t\t\t\t\t\tportraitRatio = +(options.portratio || 200) / 100,\n\t\t\t\t\t\tlandscapeRatio = +(options.landratio || 200) / 100,\n\t\t\t\t\t\tminPanelsWidth = +(options.minpanelswidth || 350),\n\t\t\t\t\t\tminPanelsHeight = +(options.minpanelsheight || 400),\n\t\t\t\t\t\tminLandscapeWidth = +(options.transwidth || 600),\n\n\t\t\t\t\t\t// Initial width parent\n\t\t\t\t\t\twidth = (maxWidth > 0 && maxWidth < parentWidth) ? maxWidth : parentWidth,\n\t\t\t\t\t\theight; // Initial height is undefined\n\n\t\t\t\t\t// Determine orientation if 'auto' or 'view'\n\t\t\t\t\tif (orientation !== 'portrait' && orientation !== 'landscape') {\n\t\t\t\t\t\tif (width < minLandscapeWidth || (orientation === 'view' && width < windowHeight)) {\n\t\t\t\t\t\t\torientation = 'portrait';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\torientation = 'landscape';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (orientation === 'portrait') { // Portrait mode\n\t\t\t\t\t\tif (!isNaN(portraitRatio)) {\n\t\t\t\t\t\t\theight = portraitRatio * width;\n\t\t\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\t\t\theight = (height - width < minPanelsHeight) ? width + minPanelsHeight : height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // Otherwise, leave height undefined\n\t\t\t\t\t} else if (orientation === 'landscape') { // Landscape mode\n\t\t\t\t\t\tif (!panelsDiv) { // No panels div\n\t\t\t\t\t\t\theight = width; // Square overall\n\t\t\t\t\t\t} else if (isNaN(landscapeRatio)) {\n\t\t\t\t\t\t\theight = windowHeight;\n\t\t\t\t\t\t} else { // Otherwise use ratio\n\t\t\t\t\t\t\theight = width / landscapeRatio;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\t\t// Reduce height to ensure minimum width of panels div\n\t\t\t\t\t\t\theight = (width < height + minPanelsWidth) ? (width - minPanelsWidth) : height;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsetDimensions(width, height);\n\t\t\t\t\tcontainer.style.width = width + 'px';\n\t\t\t\t};\n\t\t\t\twindow.addEventListener(\"resize\", resizer);\n\t\t\t\tresizer(); // Initial div sizing\n\t\t\t} else if (options.resize === 'fixed') {\n\t\t\t\tsetDimensions(container.clientWidth, container.clientHeight);\n\t\t\t}\n\n\t\t\t// Sets dimensions with optional height param\n\t\t\tfunction setDimensions(width, height) {\n\t\t\t\tif (height && width > height) { // Landscape mode\n\t\t\t\t\tcontainer.style['flex-direction'] = 'row';\n\t\t\t\t\tboardDiv.style.height = height + 'px';\n\t\t\t\t\tboardDiv.style.width = height + 'px';\n\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\tpanelsDiv.style.height = height + 'px';\n\t\t\t\t\t\tpanelsDiv.style.width = (width - height) + 'px';\n\t\t\t\t\t}\n\t\t\t\t} else { // Portrait mode (implied if height is missing)\n\t\t\t\t\tcontainer.style['flex-direction'] = 'column';\n\t\t\t\t\tboardDiv.style.height = width + 'px';\n\t\t\t\t\tboardDiv.style.width = width + 'px';\n\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\tif (height) { // Only set height if param present\n\t\t\t\t\t\t\tpanelsDiv.style.height = (height - width) + 'px';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpanelsDiv.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Creates and adds divs to specified parent or container\n\t\t\tfunction makeDiv(className, parent) {\n\t\t\t\tvar div = document.createElement(\"div\");\n\t\t\t\tif (className) {\n\t\t\t\t\tdiv.className = className;\n\t\t\t\t}\n\t\t\t\tparent = parent || container;\n\t\t\t\tparent.appendChild(div);\n\t\t\t\treturn div;\n\t\t\t}\n\t\t}; // END function besogo.create\n\n\t\t// Parses size parameter from SGF format\n\t\tbesogo.parseSize = function(input) {\n\t\t\tvar matches,\n\t\t\t\tsizeX,\n\t\t\t\tsizeY;\n\n\t\t\tinput = (input + '').replace(/\\s/g, ''); // Convert to string and remove whitespace\n\n\t\t\tmatches = input.match(/^(\\d+):(\\d+)$/); // Check for #:# pattern\n\t\t\tif (matches) { // Composed value pattern found\n\t\t\t\tsizeX = +matches[1]; // Convert to numbers\n\t\t\t\tsizeY = +matches[2];\n\t\t\t} else if (input.match(/^\\d+$/)) { // Check for # pattern\n\t\t\t\tsizeX = +input; // Convert to numbers\n\t\t\t\tsizeY = +input; // Implied square\n\t\t\t} else { // Invalid input format\n\t\t\t\tsizeX = sizeY = 19; // Default size value\n\t\t\t}\n\t\t\tif (sizeX > 52 || sizeX < 1 || sizeY > 52 || sizeY < 1) {\n\t\t\t\tsizeX = sizeY = 19; // Out of range, set to default\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: sizeX,\n\t\t\t\ty: sizeY\n\t\t\t};\n\t\t};\n\n\t\t// Automatically converts document elements into besogo instances\n\t\tbesogo.autoInit = function() {\n\t\t\tvar allDivs = document.getElementsByTagName('div'), // Live collection of divs\n\t\t\t\ttargetDivs = [], // List of divs to auto-initialize\n\t\t\t\toptions, // Structure to hold options\n\t\t\t\ti, j, attrs; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < allDivs.length; i++) { // Iterate over all divs\n\t\t\t\tif ((hasClass(allDivs[i], 'besogo-editor') || // Has an auto-init class\n\t\t\t\t\t\thasClass(allDivs[i], 'besogo-viewer') ||\n\t\t\t\t\t\thasClass(allDivs[i], 'besogo-diagram')) &&\n\t\t\t\t\t!hasClass(allDivs[i], 'besogo-container')) { // Not already initialized\n\t\t\t\t\ttargetDivs.push(allDivs[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targetDivs.length; i++) { // Iterate over target divs\n\t\t\t\toptions = {}; // Clear the options struct\n\t\t\t\tif (hasClass(targetDivs[i], 'besogo-editor')) {\n\t\t\t\t\toptions.panels = ['control', 'names', 'comment', 'tool', 'tree', 'file'];\n\t\t\t\t\toptions.tool = 'auto';\n\t\t\t\t} else if (hasClass(targetDivs[i], 'besogo-viewer')) {\n\t\t\t\t\toptions.panels = ['control', 'names', 'comment'];\n\t\t\t\t\toptions.tool = 'navOnly';\n\t\t\t\t} else if (hasClass(targetDivs[i], 'besogo-diagram')) {\n\t\t\t\t\toptions.panels = [];\n\t\t\t\t\toptions.tool = 'navOnly';\n\t\t\t\t}\n\n\t\t\t\tattrs = targetDivs[i].attributes;\n\t\t\t\tfor (j = 0; j < attrs.length; j++) { // Load attributes as options\n\t\t\t\t\toptions[attrs[j].name] = attrs[j].value;\n\t\t\t\t}\n\t\t\t\tbesogo.create(targetDivs[i], options);\n\t\t\t}\n\n\t\t\tfunction hasClass(element, str) {\n\t\t\t\treturn (element.className.split(' ').indexOf(str) !== -1);\n\t\t\t}\n\t\t};\n\n\t\t// Sets up keypress handling\n\t\tfunction addKeypressHandler(container, editor) {\n\t\t\tif (!container.getAttribute('tabindex')) {\n\t\t\t\tcontainer.setAttribute('tabindex', '0'); // Set tabindex to allow div focusing\n\t\t\t}\n\n\t\t\tcontainer.addEventListener('keydown', function(evt) {\n\t\t\t\tevt = evt || window.event;\n\t\t\t\tswitch (evt.keyCode) {\n\t\t\t\t\tcase 33: // page up\n\t\t\t\t\t\teditor.prevNode(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 34: // page down\n\t\t\t\t\t\teditor.nextNode(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 35: // end\n\t\t\t\t\t\teditor.nextNode(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 36: // home\n\t\t\t\t\t\teditor.prevNode(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 37: // left\n\t\t\t\t\t\teditor.prevNode(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 38: // up\n\t\t\t\t\t\teditor.nextSibling(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 39: // right\n\t\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 40: // down\n\t\t\t\t\t\teditor.nextSibling(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 46: // delete\n\t\t\t\t\t\teditor.cutCurrent();\n\t\t\t\t\t\tbreak;\n\t\t\t\t} // END switch (evt.keyCode)\n\t\t\t\tif (evt.keyCode >= 33 && evt.keyCode <= 40) {\n\t\t\t\t\tevt.preventDefault(); // Suppress page nav controls\n\t\t\t\t}\n\t\t\t}); // END func() and addEventListener\n\t\t} // END function addKeypressHandler\n\n\t\t// Sets up mousewheel handling\n\t\tfunction addWheelHandler(boardDiv, editor) {\n\t\t\tboardDiv.addEventListener('wheel', function(evt) {\n\t\t\t\tevt = evt || window.event;\n\t\t\t\tif (evt.deltaY > 0) {\n\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t} else if (evt.deltaY < 0) {\n\t\t\t\t\teditor.prevNode(1);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Parses SGF string and loads into editor\n\t\tfunction parseAndLoad(text, editor) {\n\t\t\tvar sgf;\n\t\t\ttry {\n\t\t\t\tsgf = besogo.parseSgf(text);\n\t\t\t} catch (error) {\n\t\t\t\treturn; // Silently fail on parse error\n\t\t\t}\n\t\t\tbesogo.loadSgf(sgf, editor);\n\t\t}\n\n\t\t// Fetches text file at url from same domain\n\t\tfunction fetchParseLoad(url, editor, path) {\n\t\t\tvar http = new XMLHttpRequest();\n\n\t\t\thttp.onreadystatechange = function() {\n\t\t\t\tif (http.readyState === 4 && http.status === 200) { // Successful fetch\n\t\t\t\t\tparseAndLoad(http.responseText, editor);\n\t\t\t\t\tnavigatePath(editor, path);\n\t\t\t\t}\n\t\t\t};\n\t\t\thttp.overrideMimeType('text/plain'); // Prevents XML parsing and warnings\n\t\t\thttp.open(\"GET\", url, true); // Asynchronous load\n\t\t\thttp.send();\n\t\t}\n\n\t\tfunction navigatePath(editor, path) {\n\t\t\tvar subPaths,\n\t\t\t\ti, j; // Scratch iteration variables\n\n\t\t\tpath = path.split(/[Nn]+/); // Split into parts that start in next mode\n\t\t\tfor (i = 0; i < path.length; i++) {\n\t\t\t\tsubPaths = path[i].split(/[Bb]+/); // Split on switches into branch mode\n\t\t\t\texecuteMoves(subPaths[0], false); // Next mode moves\n\t\t\t\tfor (j = 1; j < subPaths.length; j++) { // Intentionally starting at 1\n\t\t\t\t\texecuteMoves(subPaths[j], true); // Branch mode moves\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction executeMoves(part, branch) {\n\t\t\t\tvar i;\n\t\t\t\tpart = part.split(/\\D+/); // Split on non-digits\n\t\t\t\tfor (i = 0; i < part.length; i++) {\n\t\t\t\t\tif (part[i]) { // Skip empty strings\n\t\t\t\t\t\tif (branch) { // Branch mode\n\t\t\t\t\t\t\tif (editor.getCurrent().children.length) {\n\t\t\t\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\t\t\t\teditor.nextSibling(part[i] - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // Next mode\n\t\t\t\t\t\t\teditor.nextNode(+part[i]); // Converts to number\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t})(); // END closure\n\tbesogo.makeBoardDisplay = function(container, editor) {\n\t\t'use strict';\n\t\tvar CELL_SIZE = 88, // Including line width\n\t\t\tCOORD_MARGIN = 75, // Margin for coordinate labels\n\t\t\tEXTRA_MARGIN = 6, // Extra margin on the edge of board\n\t\t\tBOARD_MARGIN, // Total board margin\n\n\t\t\t// Board size parameters\n\t\t\tsizeX = editor.getCurrent().getSize().x,\n\t\t\tsizeY = editor.getCurrent().getSize().y,\n\n\t\t\tsvg, // Holds the overall board display SVG element\n\t\t\tstoneGroup, // Group for stones\n\t\t\tmarkupGroup, // Group for markup\n\t\t\thoverGroup, // Group for hover layer\n\t\t\tmarkupLayer, // Array of markup layer elements\n\t\t\thoverLayer, // Array of hover layer elements\n\n\t\t\trandIndex, // Random index for stone images\n\n\t\t\tTOUCH_FLAG = false; // Flag for touch interfaces\n\n\t\tinitializeBoard(editor.getCoordStyle()); // Initialize SVG element and draw the board\n\t\tcontainer.appendChild(svg); // Add the SVG element to the document\n\t\teditor.addListener(update); // Register listener to handle editor/game state updates\n\t\tredrawAll(editor.getCurrent()); // Draw stones, markup and hover layer\n\n\t\t// Set listener to detect touch interfaces\n\t\tcontainer.addEventListener('touchstart', setTouchFlag);\n\n\t\t// Function for setting the flag for touch interfaces\n\t\tfunction setTouchFlag() {\n\t\t\tTOUCH_FLAG = true; // Set flag to prevent needless function calls\n\t\t\thoverLayer = []; // Drop hover layer references, kills events\n\t\t\tsvg.removeChild(hoverGroup); // Remove hover group from SVG\n\t\t\t// Remove self when done\n\t\t\tcontainer.removeEventListener('touchstart', setTouchFlag);\n\t\t}\n\n\t\t// Initializes the SVG and draws the board\n\t\tfunction initializeBoard(coord) {\n\t\t\tdrawBoard(coord); // Initialize the SVG element and draw the board\n\n\t\t\tstoneGroup = besogo.svgEl(\"g\");\n\t\t\tmarkupGroup = besogo.svgEl(\"g\");\n\n\t\t\tsvg.appendChild(stoneGroup); // Add placeholder group for stone layer\n\t\t\tsvg.appendChild(markupGroup); // Add placeholder group for markup layer\n\n\t\t\tif (!TOUCH_FLAG) {\n\t\t\t\thoverGroup = besogo.svgEl(\"g\");\n\t\t\t\tsvg.appendChild(hoverGroup);\n\t\t\t}\n\n\t\t\taddEventTargets(); // Add mouse event listener layer\n\n\t\t\tif (editor.REAL_STONES) { // Generate index for realistic stone images\n\t\t\t\trandomizeIndex();\n\t\t\t}\n\t\t}\n\n\t\t// Callback for board display redraws\n\t\tfunction update(msg) {\n\t\t\tvar current = editor.getCurrent(),\n\t\t\t\tcurrentSize = current.getSize(),\n\t\t\t\treinit = false, // Board redraw flag\n\t\t\t\toldSvg = svg;\n\n\t\t\t// Check if board size has changed\n\t\t\tif (currentSize.x !== sizeX || currentSize.y !== sizeY || msg.coord) {\n\t\t\t\tsizeX = currentSize.x;\n\t\t\t\tsizeY = currentSize.y;\n\t\t\t\tinitializeBoard(msg.coord || editor.getCoordStyle()); // Reinitialize board\n\t\t\t\tcontainer.replaceChild(svg, oldSvg);\n\t\t\t\treinit = true; // Flag board redrawn\n\t\t\t}\n\n\t\t\t// Redraw stones only if needed\n\t\t\tif (reinit || msg.navChange || msg.stoneChange) {\n\t\t\t\tredrawStones(current);\n\t\t\t\tredrawMarkup(current);\n\t\t\t\tredrawHover(current);\n\t\t\t} else if (msg.markupChange) {\n\t\t\t\tredrawMarkup(current);\n\t\t\t\tredrawHover(current);\n\t\t\t} else if (msg.tool || msg.label) {\n\t\t\t\tredrawHover(current);\n\t\t\t}\n\t\t}\n\n\t\tfunction redrawAll(current) {\n\t\t\tredrawStones(current);\n\t\t\tredrawMarkup(current);\n\t\t\tredrawHover(current);\n\t\t}\n\n\t\t// Initializes the SVG element and draws the board\n\t\tfunction drawBoard(coord) {\n\t\t\tvar boardWidth,\n\t\t\t\tboardHeight,\n\t\t\t\tstring = \"\", // Path string for inner board lines\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tBOARD_MARGIN = (coord === 'none' ? 0 : COORD_MARGIN) + EXTRA_MARGIN;\n\t\t\tboardWidth = 2 * BOARD_MARGIN + sizeX * CELL_SIZE;\n\t\t\tboardHeight = 2 * BOARD_MARGIN + sizeY * CELL_SIZE;\n\n\t\t\tsvg = besogo.svgEl(\"svg\", { // Initialize the SVG element\n\t\t\t\twidth: \"100%\",\n\t\t\t\theight: \"100%\",\n\t\t\t\tviewBox: \"0 0 \" + boardWidth + \" \" + boardHeight\n\t\t\t});\n\n\t\t\tsvg.appendChild(besogo.svgEl(\"rect\", { // Fill background color\n\t\t\t\twidth: boardWidth,\n\t\t\t\theight: boardHeight,\n\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t}));\n\n\t\t\tsvg.appendChild(besogo.svgEl(\"rect\", { // Draw outer square of board\n\t\t\t\twidth: CELL_SIZE * (sizeX - 1),\n\t\t\t\theight: CELL_SIZE * (sizeY - 1),\n\t\t\t\tx: svgPos(1),\n\t\t\t\ty: svgPos(1),\n\t\t\t\t'class': 'besogo-svg-lines'\n\t\t\t}));\n\n\t\t\tfor (i = 2; i <= (sizeY - 1); i++) { // Horizontal inner lines\n\t\t\t\tstring += \"M\" + svgPos(1) + \",\" + svgPos(i) + \"h\" + CELL_SIZE * (sizeX - 1);\n\t\t\t}\n\t\t\tfor (i = 2; i <= (sizeX - 1); i++) { // Vertical inner lines\n\t\t\t\tstring += \"M\" + svgPos(i) + \",\" + svgPos(1) + \"v\" + CELL_SIZE * (sizeY - 1);\n\t\t\t}\n\t\t\tsvg.appendChild(besogo.svgEl(\"path\", { // Draw inner lines of board\n\t\t\t\td: string,\n\t\t\t\t'class': 'besogo-svg-lines'\n\t\t\t}));\n\n\t\t\tdrawHoshi(); // Draw the hoshi points\n\t\t\tif (coord !== 'none') {\n\t\t\t\tdrawCoords(coord); // Draw the coordinate labels\n\t\t\t}\n\t\t}\n\n\t\t// Draws coordinate labels on the board\n\t\tfunction drawCoords(coord) {\n\t\t\tvar labels = besogo.coord[coord](sizeX, sizeY),\n\t\t\t\tshift = COORD_MARGIN + 10,\n\t\t\t\ti, x, y; // Scratch iteration variable\n\n\t\t\tfor (i = 1; i <= sizeX; i++) { // Draw column coordinate labels\n\t\t\t\tx = svgPos(i);\n\t\t\t\tdrawCoordLabel(x, svgPos(1) - shift, labels.x[i]);\n\t\t\t\tdrawCoordLabel(x, svgPos(sizeY) + shift, labels.x[i]);\n\t\t\t}\n\n\t\t\tfor (i = 1; i <= sizeY; i++) { // Draw row coordinate labels\n\t\t\t\ty = svgPos(i);\n\t\t\t\tdrawCoordLabel(svgPos(1) - shift, y, labels.y[i]);\n\t\t\t\tdrawCoordLabel(svgPos(sizeX) + shift, y, labels.y[i]);\n\t\t\t}\n\n\t\t\tfunction drawCoordLabel(x, y, label) {\n\t\t\t\tvar element = besogo.svgEl(\"text\", {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\tdy: \".65ex\", // Seems to work for vertically centering these fonts\n\t\t\t\t\t\"font-size\": 32,\n\t\t\t\t\t\"text-anchor\": \"middle\", // Horizontal centering\n\t\t\t\t\t\"font-family\": \"Helvetica, Arial, sans-serif\",\n\t\t\t\t\tfill: 'black'\n\t\t\t\t});\n\t\t\t\telement.appendChild(document.createTextNode(label));\n\t\t\t\tsvg.appendChild(element);\n\t\t\t}\n\t\t}\n\n\t\t// Draws hoshi onto the board at procedurally generated locations\n\t\tfunction drawHoshi() {\n\t\t\tvar cx, cy, // Center point calculation\n\t\t\t\tpathStr = \"\"; // Path string for drawing star points\n\n\t\t\tif (sizeX % 2 && sizeY % 2) { // Draw center hoshi if both dimensions are odd\n\t\t\t\tcx = (sizeX - 1) / 2 + 1; // Calculate the center of the board\n\t\t\t\tcy = (sizeY - 1) / 2 + 1;\n\t\t\t\tdrawStar(cx, cy);\n\n\t\t\t\tif (sizeX >= 17 && sizeY >= 17) { // Draw side hoshi if at least 17x17 and odd\n\t\t\t\t\tdrawStar(4, cy);\n\t\t\t\t\tdrawStar(sizeX - 3, cy);\n\t\t\t\t\tdrawStar(cx, 4);\n\t\t\t\t\tdrawStar(cx, sizeY - 3);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sizeX >= 11 && sizeY >= 11) { // Corner hoshi at (4, 4) for larger sizes\n\t\t\t\tdrawStar(4, 4);\n\t\t\t\tdrawStar(4, sizeY - 3);\n\t\t\t\tdrawStar(sizeX - 3, 4);\n\t\t\t\tdrawStar(sizeX - 3, sizeY - 3);\n\t\t\t} else if (sizeX >= 8 && sizeY >= 8) { // Corner hoshi at (3, 3) for medium sizes\n\t\t\t\tdrawStar(3, 3);\n\t\t\t\tdrawStar(3, sizeY - 2);\n\t\t\t\tdrawStar(sizeX - 2, 3);\n\t\t\t\tdrawStar(sizeX - 2, sizeY - 2);\n\t\t\t} // No corner hoshi for smaller sizes\n\n\t\t\tif (pathStr) { // Only need to add if hoshi drawn\n\t\t\t\tsvg.appendChild(besogo.svgEl('path', { // Drawing circles via path points\n\t\t\t\t\td: pathStr, // Hack to allow radius adjustment via stroke-width\n\t\t\t\t\t'stroke-linecap': 'round', // Makes the points round\n\t\t\t\t\t'class': 'besogo-svg-hoshi'\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tfunction drawStar(i, j) { // Extend path string to draw star point\n\t\t\t\tpathStr += \"M\" + svgPos(i) + ',' + svgPos(j) + 'l0,0'; // Draws a point\n\t\t\t}\n\t\t}\n\n\t\t// Remakes the randomized index for stone images\n\t\tfunction randomizeIndex() {\n\t\t\tvar maxIndex = besogo.BLACK_STONES * besogo.WHITE_STONES,\n\t\t\t\ti, j;\n\n\t\t\trandIndex = [];\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\trandIndex[fromXY(i, j)] = Math.floor(Math.random() * maxIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adds a grid of squares to register mouse events\n\t\tfunction addEventTargets() {\n\t\t\tvar element,\n\t\t\t\ti, j;\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\telement = besogo.svgEl(\"rect\", { // Make a transparent event target\n\t\t\t\t\t\tx: svgPos(i) - CELL_SIZE / 2,\n\t\t\t\t\t\ty: svgPos(j) - CELL_SIZE / 2,\n\t\t\t\t\t\twidth: CELL_SIZE,\n\t\t\t\t\t\theight: CELL_SIZE,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t});\n\n\t\t\t\t\t// Add event listeners, using closures to decouple (i, j)\n\t\t\t\t\telement.addEventListener(\"click\", handleClick(i, j));\n\n\t\t\t\t\tif (!TOUCH_FLAG) { // Skip hover listeners for touch interfaces\n\t\t\t\t\t\telement.addEventListener(\"mouseover\", handleOver(i, j));\n\t\t\t\t\t\telement.addEventListener(\"mouseout\", handleOut(i, j));\n\t\t\t\t\t}\n\n\t\t\t\t\tsvg.appendChild(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction handleClick(i, j) { // Returns function for click handling\n\t\t\treturn function(event) {\n\t\t\t\t// Call click handler in editor\n\t\t\t\teditor.click(i, j, event.ctrlKey, event.shiftKey);\n\t\t\t\tif (!TOUCH_FLAG) {\n\t\t\t\t\t(handleOver(i, j))(); // Ensures that any updated tool is visible\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction handleOver(i, j) { // Returns function for mouse over\n\t\t\treturn function() {\n\t\t\t\tvar element = hoverLayer[fromXY(i, j)];\n\t\t\t\tif (element) { // Make tool action visible on hover over\n\t\t\t\t\telement.setAttribute('visibility', 'visible');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction handleOut(i, j) { // Returns function for mouse off\n\t\t\treturn function() {\n\t\t\t\tvar element = hoverLayer[fromXY(i, j)];\n\t\t\t\tif (element) { // Make tool action invisible on hover off\n\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Redraws the stones\n\t\tfunction redrawStones(current) {\n\t\t\tvar group = besogo.svgEl(\"g\"), // New stone layer group\n\t\t\t\tshadowGroup, // Group for shadow layer\n\t\t\t\ti, j, x, y, color; // Scratch iteration variables\n\n\t\t\tif (editor.SHADOWS) { // Add group for shawdows\n\t\t\t\tshadowGroup = besogo.svgShadowGroup();\n\t\t\t\tgroup.appendChild(shadowGroup);\n\t\t\t}\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\tcolor = current.getStone(i, j);\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\n\t\t\t\t\t\tif (editor.REAL_STONES) { // Realistic stone\n\t\t\t\t\t\t\tgroup.appendChild(besogo.realStone(x, y, color, randIndex[fromXY(i, j)]));\n\t\t\t\t\t\t} else { // SVG stone\n\t\t\t\t\t\t\tgroup.appendChild(besogo.svgStone(x, y, color));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (editor.SHADOWS) { // Draw shadows\n\t\t\t\t\t\t\tshadowGroup.appendChild(besogo.svgShadow(x - 2, y - 4));\n\t\t\t\t\t\t\tshadowGroup.appendChild(besogo.svgShadow(x + 2, y + 4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsvg.replaceChild(group, stoneGroup); // Replace the stone group\n\t\t\tstoneGroup = group;\n\t\t}\n\n\t\t// Redraws the markup\n\t\tfunction redrawMarkup(current) {\n\t\t\tvar element, i, j, x, y, // Scratch iteration variables\n\t\t\t\tgroup = besogo.svgEl(\"g\"), // Group holding markup layer elements\n\t\t\t\tlastMove = current.move,\n\t\t\t\tvariants = editor.getVariants(),\n\t\t\t\tmark, // Scratch mark state {0, 1, 2, 3, 4, 5}\n\t\t\t\tstone, // Scratch stone state {0, -1, 1}\n\t\t\t\tcolor; // Scratch color string\n\n\t\t\tmarkupLayer = []; // Clear the references to the old layer\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\tmark = current.getMarkup(i, j);\n\t\t\t\t\tif (mark) {\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\t\t\t\t\t\tstone = current.getStone(i, j);\n\t\t\t\t\t\tcolor = (stone === -1) ? \"white\" : \"black\"; // White on black\n\t\t\t\t\t\tif (lastMove && lastMove.x === i && lastMove.y === j) {\n\t\t\t\t\t\t\t// Mark last move blue or violet if also a variant\n\t\t\t\t\t\t\tcolor = checkVariants(variants, current, i, j) ?\n\t\t\t\t\t\t\t\tbesogo.PURP : besogo.BLUE;\n\t\t\t\t\t\t} else if (checkVariants(variants, current, i, j)) {\n\t\t\t\t\t\t\tcolor = besogo.RED; // Natural variant marks are red\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof mark === 'number') { // Markup is a basic shape\n\t\t\t\t\t\t\tswitch (mark) {\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\telement = besogo.svgCircle(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\telement = besogo.svgSquare(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\telement = besogo.svgTriangle(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\telement = besogo.svgBlock(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // Markup is a label\n\t\t\t\t\t\t\tif (!stone) { // If placing label on empty spot\n\t\t\t\t\t\t\t\telement = makeBacker(x, y);\n\t\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telement = besogo.svgLabel(x, y, color, mark);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\tmarkupLayer[fromXY(i, j)] = element;\n\t\t\t\t\t} // END if (mark)\n\t\t\t\t} // END for j\n\t\t\t} // END for i\n\n\t\t\t// Mark last move with plus if not already marked\n\t\t\tif (lastMove && lastMove.x !== 0 && lastMove.y !== 0) {\n\t\t\t\ti = lastMove.x;\n\t\t\t\tj = lastMove.y;\n\t\t\t\tif (!markupLayer[fromXY(i, j)]) { // Last move not marked\n\t\t\t\t\tcolor = checkVariants(variants, current, i, j) ? besogo.PURP : besogo.BLUE;\n\t\t\t\t\telement = besogo.svgPlus(svgPos(i), svgPos(j), color);\n\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\tmarkupLayer[fromXY(i, j)] = element;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mark variants that have not already been marked above\n\t\t\tmarkRemainingVariants(variants, current, group);\n\n\t\t\tsvg.replaceChild(group, markupGroup); // Replace the markup group\n\t\t\tmarkupGroup = group;\n\t\t} // END function redrawMarkup\n\n\t\tfunction makeBacker(x, y) { // Makes a label markup backer at (x, y)\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: x - CELL_SIZE / 2,\n\t\t\t\ty: y - CELL_SIZE / 2,\n\t\t\t\theight: CELL_SIZE,\n\t\t\t\twidth: CELL_SIZE,\n\t\t\t\topacity: 0.85,\n\t\t\t\tstroke: \"none\",\n\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t});\n\t\t}\n\n\t\t// Checks if (x, y) is in variants\n\t\tfunction checkVariants(variants, current, x, y) {\n\t\t\tvar i, move;\n\t\t\tfor (i = 0; i < variants.length; i++) {\n\t\t\t\tif (variants[i] !== current) { // Skip current (within siblings)\n\t\t\t\t\tmove = variants[i].move;\n\t\t\t\t\tif (move && move.x === x && move.y === y) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Marks variants that have not already been marked\n\t\tfunction markRemainingVariants(variants, current, group) {\n\t\t\tvar element,\n\t\t\t\tmove, // Variant move\n\t\t\t\tlabel, // Variant label\n\t\t\t\tstone, // Stone state\n\t\t\t\ti, x, y; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < variants.length; i++) {\n\t\t\t\tif (variants[i] !== current) { // Skip current (within siblings)\n\t\t\t\t\tmove = variants[i].move;\n\t\t\t\t\t// Check if move, not a pass, and no mark yet\n\t\t\t\t\tif (move && move.x !== 0 && !markupLayer[fromXY(move.x, move.y)]) {\n\t\t\t\t\t\tstone = current.getStone(move.x, move.y);\n\t\t\t\t\t\tx = svgPos(move.x); // Get SVG positions\n\t\t\t\t\t\ty = svgPos(move.y);\n\t\t\t\t\t\tif (!stone) { // If placing label on empty spot\n\t\t\t\t\t\t\telement = makeBacker(x, y);\n\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Label variants with letters A-Z cyclically\n\t\t\t\t\t\tlabel = String.fromCharCode('A'.charCodeAt(0) + (i % 26));\n\t\t\t\t\t\telement = besogo.svgLabel(x, y, besogo.LRED, label);\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\tmarkupLayer[fromXY(move.x, move.y)] = element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function markRemainingVariants\n\n\t\t// Redraws the hover layer\n\t\tfunction redrawHover(current) {\n\t\t\tif (TOUCH_FLAG) {\n\t\t\t\treturn; // Do nothing for touch interfaces\n\t\t\t}\n\n\t\t\tvar element, i, j, x, y, // Scratch iteration variables\n\t\t\t\tgroup = besogo.svgEl(\"g\"), // Group holding hover layer elements\n\t\t\t\ttool = editor.getTool(),\n\t\t\t\tchildren,\n\t\t\t\tstone, // Scratch stone state {0, -1, 1} or move\n\t\t\t\tcolor; // Scratch color string\n\n\t\t\thoverLayer = []; // Clear the references to the old layer\n\t\t\tgroup.setAttribute('opacity', '0.35');\n\n\t\t\tif (tool === 'navOnly') { // Render navOnly hover by iterating over children\n\t\t\t\tchildren = current.children;\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tstone = children[i].move;\n\t\t\t\t\tif (stone && stone.x !== 0) { // Child node is move and not a pass\n\t\t\t\t\t\tx = svgPos(stone.x);\n\t\t\t\t\t\ty = svgPos(stone.y);\n\t\t\t\t\t\telement = besogo.svgStone(x, y, stone.color);\n\t\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\thoverLayer[fromXY(stone.x, stone.y)] = element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { // Render hover for other tools by iterating over grid\n\t\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\t\telement = null;\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\t\t\t\t\t\tstone = current.getStone(i, j);\n\t\t\t\t\t\tcolor = (stone === -1) ? \"white\" : \"black\"; // White on black\n\t\t\t\t\t\tswitch (tool) {\n\t\t\t\t\t\t\tcase 'auto':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, current.nextToMove);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'playB':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, -1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'playW':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addB':\n\t\t\t\t\t\t\t\tif (stone === -1) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = besogo.svgEl('g');\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgStone(x, y, -1));\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgPlus(x, y, besogo.RED));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addW':\n\t\t\t\t\t\t\t\tif (stone === 1) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = besogo.svgEl('g');\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgStone(x, y, 1));\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgPlus(x, y, besogo.RED));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addE':\n\t\t\t\t\t\t\t\tif (stone) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'clrMark':\n\t\t\t\t\t\t\t\tbreak; // Nothing\n\t\t\t\t\t\t\tcase 'circle':\n\t\t\t\t\t\t\t\telement = besogo.svgCircle(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'square':\n\t\t\t\t\t\t\t\telement = besogo.svgSquare(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'triangle':\n\t\t\t\t\t\t\t\telement = besogo.svgTriangle(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'cross':\n\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'block':\n\t\t\t\t\t\t\t\telement = besogo.svgBlock(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'label':\n\t\t\t\t\t\t\t\telement = besogo.svgLabel(x, y, color, editor.getLabel());\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // END switch (tool)\n\t\t\t\t\t\tif (element) {\n\t\t\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t\thoverLayer[fromXY(i, j)] = element;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // END for j\n\t\t\t\t} // END for i\n\t\t\t} // END else\n\n\t\t\tsvg.replaceChild(group, hoverGroup); // Replace the hover layer group\n\t\t\thoverGroup = group;\n\t\t} // END function redrawHover\n\n\t\tfunction svgPos(x) { // Converts (x, y) coordinates to SVG position\n\t\t\treturn BOARD_MARGIN + CELL_SIZE / 2 + (x - 1) * CELL_SIZE;\n\t\t}\n\n\t\tfunction fromXY(x, y) { // Converts (x, y) coordinates to linear index\n\t\t\treturn (x - 1) * sizeY + (y - 1);\n\t\t}\n\t};\n\tbesogo.makeCommentPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar infoTexts = {}, // Holds text nodes for game info properties\n\t\t\tgameInfoTable = document.createElement('table'),\n\t\t\tgameInfoEdit = document.createElement('table'),\n\t\t\tcommentBox = document.createElement('div'),\n\t\t\tcommentEdit = document.createElement('textarea'),\n\t\t\tplayerInfoOrder = 'PW WR WT PB BR BT'.split(' '),\n\t\t\tinfoOrder = 'HA KM RU TM OT GN EV PC RO DT RE ON GC AN US SO CP'.split(' '),\n\t\t\tinfoIds = {\n\t\t\t\tPW: 'White Player',\n\t\t\t\tWR: 'White Rank',\n\t\t\t\tWT: 'White Team',\n\t\t\t\tPB: 'Black Player',\n\t\t\t\tBR: 'Black Rank',\n\t\t\t\tBT: 'Black Team',\n\n\t\t\t\tHA: 'Handicap',\n\t\t\t\tKM: 'Komi',\n\t\t\t\tRU: 'Rules',\n\t\t\t\tTM: 'Timing',\n\t\t\t\tOT: 'Overtime',\n\n\t\t\t\tGN: 'Game Name',\n\t\t\t\tEV: 'Event',\n\t\t\t\tPC: 'Place',\n\t\t\t\tRO: 'Round',\n\t\t\t\tDT: 'Date',\n\n\t\t\t\tRE: 'Result',\n\t\t\t\tON: 'Opening',\n\t\t\t\tGC: 'Comments',\n\n\t\t\t\tAN: 'Annotator',\n\t\t\t\tUS: 'Recorder',\n\t\t\t\tSO: 'Source',\n\t\t\t\tCP: 'Copyright'\n\t\t\t};\n\n\t\tcontainer.appendChild(makeInfoButton());\n\t\tcontainer.appendChild(makeInfoEditButton());\n\t\tcontainer.appendChild(makeCommentButton());\n\t\tcontainer.appendChild(gameInfoTable);\n\t\tcontainer.appendChild(gameInfoEdit);\n\t\tinfoTexts.C = document.createTextNode('');\n\t\tcontainer.appendChild(commentBox);\n\t\tcommentBox.appendChild(infoTexts.C);\n\t\tcontainer.appendChild(commentEdit);\n\n\t\tcommentEdit.onblur = function() {\n\t\t\teditor.setComment(commentEdit.value);\n\t\t};\n\t\tcommentEdit.addEventListener('keydown', function(evt) {\n\t\t\tevt = evt || window.event;\n\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t});\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tgameInfo: editor.getGameInfo()\n\t\t});\n\t\tgameInfoEdit.style.display = 'none'; // Hide game info editting table initially\n\n\t\tfunction update(msg) {\n\t\t\tvar temp; // Scratch for strings\n\n\t\t\tif (msg.navChange) {\n\t\t\t\ttemp = editor.getCurrent().comment || '';\n\t\t\t\tupdateText(commentBox, temp, 'C');\n\t\t\t\tif (editor.getCurrent() === editor.getRoot() &&\n\t\t\t\t\tgameInfoTable.firstChild &&\n\t\t\t\t\tgameInfoEdit.style.display === 'none') {\n\t\t\t\t\tgameInfoTable.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tcommentEdit.style.display = 'none';\n\t\t\t\tcommentBox.style.display = 'block';\n\t\t\t} else if (msg.comment !== undefined) {\n\t\t\t\tupdateText(commentBox, msg.comment, 'C');\n\t\t\t\tcommentEdit.value = msg.comment;\n\t\t\t}\n\n\t\t\tif (msg.gameInfo) { // Update game info\n\t\t\t\tupdateGameInfoTable(msg.gameInfo);\n\t\t\t\tupdateGameInfoEdit(msg.gameInfo);\n\t\t\t}\n\t\t} // END function update\n\n\t\tfunction updateGameInfoTable(gameInfo) {\n\t\t\tvar table = document.createElement('table'),\n\t\t\t\ti, id, row, cell, text; // Scratch iteration variable\n\n\t\t\ttable.className = 'besogo-gameInfo';\n\t\t\tfor (i = 0; i < infoOrder.length; i++) { // Iterate in specified order\n\t\t\t\tid = infoOrder[i];\n\n\t\t\t\tif (gameInfo[id]) { // Only add row if property exists\n\t\t\t\t\trow = document.createElement('tr');\n\t\t\t\t\ttable.appendChild(row);\n\n\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\tcell.appendChild(document.createTextNode(infoIds[id]));\n\t\t\t\t\trow.appendChild(cell);\n\n\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\ttext = document.createTextNode(gameInfo[id]);\n\t\t\t\t\tcell.appendChild(text);\n\t\t\t\t\trow.appendChild(cell);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!table.firstChild || gameInfoTable.style.display === 'none') {\n\t\t\t\ttable.style.display = 'none'; // Do not display empty table or if already hidden\n\t\t\t}\n\t\t\tcontainer.replaceChild(table, gameInfoTable);\n\t\t\tgameInfoTable = table;\n\t\t}\n\n\t\tfunction updateGameInfoEdit(gameInfo) {\n\t\t\tvar table = document.createElement('table'),\n\t\t\t\tinfoTableOrder = playerInfoOrder.concat(infoOrder),\n\t\t\t\ti, id, row, cell, text;\n\n\t\t\ttable.className = 'besogo-gameInfo';\n\t\t\tfor (i = 0; i < infoTableOrder.length; i++) { // Iterate in specified order\n\t\t\t\tid = infoTableOrder[i];\n\t\t\t\trow = document.createElement('tr');\n\t\t\t\ttable.appendChild(row);\n\n\t\t\t\tcell = document.createElement('td');\n\t\t\t\tcell.appendChild(document.createTextNode(infoIds[id]));\n\t\t\t\trow.appendChild(cell);\n\n\t\t\t\tcell = document.createElement('td');\n\t\t\t\ttext = document.createElement('input');\n\t\t\t\tif (gameInfo[id]) {\n\t\t\t\t\ttext.value = gameInfo[id];\n\t\t\t\t}\n\t\t\t\ttext.onblur = function(t, id) {\n\t\t\t\t\treturn function() { // Commit change on blur\n\t\t\t\t\t\teditor.setGameInfo(t.value, id);\n\t\t\t\t\t};\n\t\t\t\t}(text, id);\n\t\t\t\ttext.addEventListener('keydown', function(evt) {\n\t\t\t\t\tevt = evt || window.event;\n\t\t\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t\t\t});\n\t\t\t\tcell.appendChild(text);\n\t\t\t\trow.appendChild(cell);\n\t\t\t}\n\t\t\tif (gameInfoEdit.style.display === 'none') {\n\t\t\t\ttable.style.display = 'none'; // Hide if already hidden\n\t\t\t}\n\t\t\tcontainer.replaceChild(table, gameInfoEdit);\n\t\t\tgameInfoEdit = table;\n\t\t}\n\n\t\tfunction updateText(parent, text, id) {\n\t\t\tvar textNode = document.createTextNode(text);\n\t\t\tparent.replaceChild(textNode, infoTexts[id]);\n\t\t\tinfoTexts[id] = textNode;\n\t\t}\n\n\t\tfunction makeInfoButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Info';\n\t\t\tbutton.title = 'Show/hide game info';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (gameInfoTable.style.display === 'none' && gameInfoTable.firstChild) {\n\t\t\t\t\tgameInfoTable.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tgameInfoEdit.style.display = 'none';\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t\tfunction makeInfoEditButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Edit Info';\n\t\t\tbutton.title = 'Edit game info';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (gameInfoEdit.style.display === 'none') {\n\t\t\t\t\tgameInfoEdit.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoEdit.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t\tfunction makeCommentButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Comment';\n\t\t\tbutton.title = 'Edit comment';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (commentEdit.style.display === 'none') { // Comment edit box hidden\n\t\t\t\t\tcommentBox.style.display = 'none'; // Hide static comment display\n\t\t\t\t\tgameInfoTable.style.display = 'none'; // Hide game info table\n\t\t\t\t\tcommentEdit.value = editor.getCurrent().comment;\n\t\t\t\t\tcommentEdit.style.display = 'block'; // Show comment edit box\n\t\t\t\t} else { // Comment edit box open\n\t\t\t\t\tcommentEdit.style.display = 'none'; // Hide comment edit box\n\t\t\t\t\tcommentBox.style.display = 'block'; // Show static comment display\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t};\n\tbesogo.makeControlPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar leftElements = [], // SVG elements for previous node buttons\n\t\t\trightElements = [], // SVG elements for next node buttons\n\t\t\tsiblingElements = [], // SVG elements for sibling buttons\n\t\t\tvariantStyleButton, // Button for changing variant style\n\t\t\thideVariantButton, // Button for toggling show/hide variants\n\t\t\tchildVariantElement, // SVG element for child style variants\n\t\t\tsiblingVariantElement, // SVG element for sibling style variants\n\t\t\thideVariantElement; // SVG element for hiding variants\n\n\t\tdrawNavButtons();\n\t\tdrawStyleButtons();\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tvariantStyle: editor.getVariantStyle()\n\t\t}); // Initialize\n\n\t\t// Callback for variant style and nav state changes\n\t\tfunction update(msg) {\n\t\t\tvar current;\n\n\t\t\tif (msg.variantStyle !== undefined) {\n\t\t\t\tupdateStyleButtons(msg.variantStyle);\n\t\t\t}\n\n\t\t\tif (msg.navChange || msg.treeChange) { // Update the navigation buttons\n\t\t\t\tcurrent = editor.getCurrent();\n\t\t\t\tif (current.parent) { // Has parent\n\t\t\t\t\tarraySetColor(leftElements, 'black');\n\t\t\t\t\tif (current.parent.children.length > 1) { // Has siblings\n\t\t\t\t\t\tarraySetColor(siblingElements, 'black');\n\t\t\t\t\t} else { // No siblings\n\t\t\t\t\t\tarraySetColor(siblingElements, besogo.GREY);\n\t\t\t\t\t}\n\t\t\t\t} else { // No parent\n\t\t\t\t\tarraySetColor(leftElements, besogo.GREY);\n\t\t\t\t\tarraySetColor(siblingElements, besogo.GREY);\n\t\t\t\t}\n\t\t\t\tif (current.children.length) { // Has children\n\t\t\t\t\tarraySetColor(rightElements, 'black');\n\t\t\t\t} else { // No children\n\t\t\t\t\tarraySetColor(rightElements, besogo.GREY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction updateStyleButtons(style) { // Updates the variant style buttons\n\t\t\t\tif (style % 2) { // Sibling style variants\n\t\t\t\t\tchildVariantElement.setAttribute('fill', 'black');\n\t\t\t\t\tsiblingVariantElement.setAttribute('fill', besogo.BLUE);\n\t\t\t\t\tvariantStyleButton.title = 'Variants: child/[sibling]';\n\t\t\t\t} else { // Child style variants\n\t\t\t\t\tchildVariantElement.setAttribute('fill', besogo.BLUE);\n\t\t\t\t\tsiblingVariantElement.setAttribute('fill', besogo.RED);\n\t\t\t\t\tvariantStyleButton.title = 'Variants: [child]/sibling';\n\t\t\t\t}\n\t\t\t\tif (style >= 2) { // Hide auto-markup for variants\n\t\t\t\t\thideVariantElement.setAttribute('visibility', 'visible');\n\t\t\t\t\thideVariantButton.title = 'Variants: show/[hide]';\n\t\t\t\t} else { // Show auto-markup for variants\n\t\t\t\t\thideVariantElement.setAttribute('visibility', 'hidden');\n\t\t\t\t\thideVariantButton.title = 'Variants: [show]/hide';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction arraySetColor(list, color) { // Changes fill color of list of svg elements\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < list.length; i++) {\n\t\t\t\t\tlist[i].setAttribute('fill', color);\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function update\n\n\t\t// Draws the navigation buttons\n\t\tfunction drawNavButtons() {\n\t\t\tleftElements.push(makeNavButton('First node',\n\t\t\t\t'5,10 5,90 25,90 25,50 95,90 95,10 25,50 25,10',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.prevNode(-1);\n\t\t\t\t}));\n\t\t\tleftElements.push(makeNavButton('Jump back',\n\t\t\t\t'95,10 50,50 50,10 5,50 50,90 50,50 95,90',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.prevNode(10);\n\t\t\t\t}));\n\t\t\tleftElements.push(makeNavButton('Previous node', '85,10 85,90 15,50', function() {\n\t\t\t\teditor.prevNode(1);\n\t\t\t}));\n\n\t\t\trightElements.push(makeNavButton('Next node', '15,10 15,90 85,50', function() {\n\t\t\t\teditor.nextNode(1);\n\t\t\t}));\n\t\t\trightElements.push(makeNavButton('Jump forward',\n\t\t\t\t'5,10 50,50 50,10 95,50 50,90 50,50 5,90',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.nextNode(10);\n\t\t\t\t}));\n\t\t\trightElements.push(makeNavButton('Last node',\n\t\t\t\t'95,10 95,90 75,90 75,50 5,90 5,10 75,50 75,10',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.nextNode(-1);\n\t\t\t\t}));\n\n\t\t\tsiblingElements.push(makeNavButton('Previous sibling', '10,85 90,85 50,15', function() {\n\t\t\t\teditor.nextSibling(-1);\n\t\t\t}));\n\t\t\tsiblingElements.push(makeNavButton('Next sibling', '10,15 90,15 50,85', function() {\n\t\t\t\teditor.nextSibling(1);\n\t\t\t}));\n\n\t\t\tfunction makeNavButton(tooltip, pointString, action) { // Creates a navigation button\n\t\t\t\tvar button = document.createElement('button'),\n\t\t\t\t\tsvg = makeButtonContainer(),\n\t\t\t\t\telement = besogo.svgEl(\"polygon\", {\n\t\t\t\t\t\tpoints: pointString,\n\t\t\t\t\t\tstroke: 'none',\n\t\t\t\t\t\tfill: 'black'\n\t\t\t\t\t});\n\n\t\t\t\tbutton.title = tooltip;\n\t\t\t\tbutton.onclick = action;\n\t\t\t\tbutton.appendChild(svg);\n\t\t\t\tsvg.appendChild(element);\n\t\t\t\tcontainer.appendChild(button);\n\n\t\t\t\treturn element;\n\t\t\t} // END function makeNavButton\n\t\t} // END function drawNavButtons\n\n\t\t// Draws the variant style buttons\n\t\tfunction drawStyleButtons() {\n\t\t\tvar svg, element, coordStyleButton;\n\n\t\t\tvariantStyleButton = document.createElement('button');\n\t\t\tvariantStyleButton.onclick = function() {\n\t\t\t\teditor.toggleVariantStyle(false); // Toggles child/sibling variants\n\t\t\t};\n\t\t\tcontainer.appendChild(variantStyleButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\tvariantStyleButton.appendChild(svg);\n\t\t\telement = besogo.svgEl(\"path\", {\n\t\t\t\td: 'm75,25h-50l50,50',\n\t\t\t\tstroke: 'black',\n\t\t\t\t\"stroke-width\": 5,\n\t\t\t\tfill: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(element);\n\t\t\tchildVariantElement = besogo.svgEl('circle', {\n\t\t\t\tcx: 25,\n\t\t\t\tcy: 25,\n\t\t\t\tr: 20,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(childVariantElement);\n\t\t\tsiblingVariantElement = besogo.svgEl('circle', {\n\t\t\t\tcx: 75,\n\t\t\t\tcy: 25,\n\t\t\t\tr: 20,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(siblingVariantElement);\n\t\t\telement = besogo.svgEl('circle', {\n\t\t\t\tcx: 75,\n\t\t\t\tcy: 75,\n\t\t\t\tr: 20,\n\t\t\t\tfill: besogo.RED,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(element);\n\n\t\t\thideVariantButton = document.createElement('button');\n\t\t\thideVariantButton.onclick = function() {\n\t\t\t\teditor.toggleVariantStyle(true); // Toggles show/hide variants\n\t\t\t};\n\t\t\tcontainer.appendChild(hideVariantButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\thideVariantButton.appendChild(svg);\n\t\t\tsvg.appendChild(besogo.svgLabel(50, 50, besogo.RED, 'A'));\n\t\t\thideVariantElement = besogo.svgCross(50, 50, 'black');\n\t\t\tsvg.appendChild(hideVariantElement);\n\n\t\t\tcoordStyleButton = document.createElement('button');\n\t\t\tcoordStyleButton.onclick = function() {\n\t\t\t\teditor.toggleCoordStyle(); // Toggles coordinate style\n\t\t\t};\n\t\t\tcoordStyleButton.title = 'Toggle coordinates';\n\t\t\tcontainer.appendChild(coordStyleButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\tcoordStyleButton.appendChild(svg);\n\t\t\tsvg.appendChild(besogo.svgLabel(50, 50, 'black', '4'));\n\t\t} // END function drawStyleButtons\n\n\t\t// Makes an SVG container for the button graphics\n\t\tfunction makeButtonContainer() {\n\t\t\treturn besogo.svgEl('svg', {\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%',\n\t\t\t\tviewBox: \"0 0 100 100\"\n\t\t\t});\n\t\t}\n\t};\n\t(function() {\n\t\t'use strict';\n\n\t\t// Parent object to hold coordinate system helper functions\n\t\tbesogo.coord = {};\n\n\t\t// Null function for no coordinate system\n\t\tbesogo.coord.none = function(sizeX, sizeY) {\n\t\t\treturn false;\n\t\t};\n\n\t\t// Western, chess-like, \"A1\" coordinate system\n\t\tbesogo.coord.western = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = numberToLetter(i);\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Simple purely numeric coordinate system\n\t\tbesogo.coord.numeric = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = i + '';\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = i + '';\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Corner-relative, alpha-numeric, coordinate system\n\t\tbesogo.coord.corner = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tif (i < (sizeX / 2) + 1) {\n\t\t\t\t\tlabels.x[i] = numberToLetter(i);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.x[i] = (sizeX - i + 1) + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t\tif (i > (sizeY / 2)) {\n\t\t\t\t\tlabels.y[i] = numberToLetter(sizeY - i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.y[i] = i + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Corner-relative, numeric and CJK, coordinate system\n\t\tbesogo.coord.eastcor = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tif (i < (sizeX / 2) + 1) {\n\t\t\t\t\tlabels.x[i] = numberToCJK(i);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.x[i] = (sizeX - i + 1) + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t\tif (i > (sizeY / 2)) {\n\t\t\t\t\tlabels.y[i] = numberToCJK(sizeY - i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.y[i] = i + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Eastern, numeric and CJK, coordinate system\n\t\tbesogo.coord.eastern = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = i + ''; // Columns are numeric\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = numberToCJK(i);\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Helper for converting numeric coord to letter (skipping I)\n\t\tfunction numberToLetter(number) {\n\t\t\treturn 'ABCDEFGHJKLMNOPQRSTUVWXYZ'.charAt((number - 1) % 25);\n\t\t}\n\n\t\t// Helper for converting numeric coord to CJK symbol\n\t\tfunction numberToCJK(number) {\n\t\t\tvar label = '',\n\t\t\t\tcjk = '';\n\n\t\t\tif (number >= 20) { // 20 and larger\n\t\t\t\tlabel = cjk.charAt(number / 10 - 1) + '';\n\t\t\t} else if (number >= 10) { // 10 through 19\n\t\t\t\tlabel = '';\n\t\t\t}\n\t\t\tif (number % 10) { // Ones digit if non-zero\n\t\t\t\tlabel = label + cjk.charAt((number - 1) % 10);\n\t\t\t}\n\t\t\treturn label;\n\t\t}\n\n\t})(); // END closure\n\tbesogo.makeEditor = function(sizeX, sizeY) {\n\t\t'use strict';\n\t\t// Creates an associated game state tree\n\t\tvar root = besogo.makeGameRoot(sizeX, sizeY),\n\t\t\tcurrent = root, // Navigation cursor\n\n\t\t\tlisteners = [], // Listeners of general game/editor state changes\n\n\t\t\t// Enumeration of editor tools/modes\n\t\t\tTOOLS = ['navOnly', // read-only navigate mode\n\t\t\t\t'auto', // auto-mode: navigate or auto-play color\n\t\t\t\t'playB', // play black stone\n\t\t\t\t'playW', // play white stone\n\t\t\t\t'addB', // setup black stone\n\t\t\t\t'addW', // setup white stone\n\t\t\t\t'addE', // setup empty stone\n\t\t\t\t'clrMark', // remove markup\n\t\t\t\t'circle', // circle markup\n\t\t\t\t'square', // square markup\n\t\t\t\t'triangle', // triangle markup\n\t\t\t\t'cross', // \"X\" cross markup\n\t\t\t\t'block', // filled square markup\n\t\t\t\t'label'\n\t\t\t], // label markup\n\t\t\ttool = 'auto', // Currently active tool (default: auto-mode)\n\t\t\tlabel = \"1\", // Next label that will be applied\n\n\t\t\tnavHistory = [], // Navigation history\n\n\t\t\tgameInfo = {}, // Game info properties\n\n\t\t\t// Order of coordinate systems\n\t\t\tCOORDS = 'none numeric western eastern corner eastcor'.split(' '),\n\t\t\tcoord = 'none', // Selected coordinate system\n\n\t\t\t// Variant style: even/odd - children/siblings, <2 - show auto markup for variants\n\t\t\tvariantStyle = 0; // 0-3, 0 is default\n\n\t\treturn {\n\t\t\taddListener: addListener,\n\t\t\tclick: click,\n\t\t\tnextNode: nextNode,\n\t\t\tprevNode: prevNode,\n\t\t\tnextSibling: nextSibling,\n\t\t\ttoggleCoordStyle: toggleCoordStyle,\n\t\t\tgetCoordStyle: getCoordStyle,\n\t\t\tsetCoordStyle: setCoordStyle,\n\t\t\ttoggleVariantStyle: toggleVariantStyle,\n\t\t\tgetVariantStyle: getVariantStyle,\n\t\t\tsetVariantStyle: setVariantStyle,\n\t\t\tgetGameInfo: getGameInfo,\n\t\t\tsetGameInfo: setGameInfo,\n\t\t\tsetComment: setComment,\n\t\t\tgetTool: getTool,\n\t\t\tsetTool: setTool,\n\t\t\tgetLabel: getLabel,\n\t\t\tsetLabel: setLabel,\n\t\t\tgetVariants: getVariants, // Returns variants of current node\n\t\t\tgetCurrent: getCurrent,\n\t\t\tsetCurrent: setCurrent,\n\t\t\tcutCurrent: cutCurrent,\n\t\t\tgetRoot: getRoot,\n\t\t\tloadRoot: loadRoot // Loads new game state\n\t\t};\n\n\t\t// Returns the active tool\n\t\tfunction getTool() {\n\t\t\treturn tool;\n\t\t}\n\n\t\t// Sets the active tool, returns false if failed\n\t\tfunction setTool(set) {\n\t\t\t// Toggle label mode if already label tool already selected\n\t\t\tif (set === 'label' && set === tool) {\n\t\t\t\tif (/^-?\\d+$/.test(label)) { // If current label is integer\n\t\t\t\t\tsetLabel('A'); // Toggle to characters\n\t\t\t\t} else {\n\t\t\t\t\tsetLabel('1'); // Toggle back to numbers\n\t\t\t\t}\n\t\t\t\treturn true; // Notification already handled by setLabel\n\t\t\t}\n\t\t\t// Set the tool only if in list and actually changed\n\t\t\tif (TOOLS.indexOf(set) !== -1 && tool !== set) {\n\t\t\t\ttool = set;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\ttool: tool,\n\t\t\t\t\tlabel: label\n\t\t\t\t}); // Notify tool change\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Gets the next label to apply\n\t\tfunction getLabel() {\n\t\t\treturn label;\n\t\t}\n\n\t\t// Sets the next label to apply and sets active tool to label\n\t\tfunction setLabel(set) {\n\t\t\tif (typeof set === 'string') {\n\t\t\t\tset = set.replace(/\\s/g, ' ').trim(); // Convert all whitespace to space and trim\n\t\t\t\tlabel = set || \"1\"; // Default to \"1\" if empty string\n\t\t\t\ttool = 'label'; // Also change current tool to label\n\t\t\t\tnotifyListeners({\n\t\t\t\t\ttool: tool,\n\t\t\t\t\tlabel: label\n\t\t\t\t}); // Notify tool/label change\n\t\t\t}\n\t\t}\n\n\t\t// Toggle the coordinate style\n\t\tfunction toggleCoordStyle() {\n\t\t\tcoord = COORDS[(COORDS.indexOf(coord) + 1) % COORDS.length];\n\t\t\tnotifyListeners({\n\t\t\t\tcoord: coord\n\t\t\t});\n\t\t}\n\n\t\t// Gets the current coordinate style\n\t\tfunction getCoordStyle() {\n\t\t\treturn coord;\n\t\t}\n\n\t\t// Sets the coordinate system style\n\t\tfunction setCoordStyle(setCoord) {\n\t\t\tif (besogo.coord[setCoord]) {\n\t\t\t\tcoord = setCoord;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tcoord: setCoord\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Toggles the style for showing variants\n\t\tfunction toggleVariantStyle(toggleShow) {\n\t\t\tvar childStyle = variantStyle % 2, // 0: children, 1: siblings\n\t\t\t\tshowStyle = variantStyle - childStyle; // 0: show auto-markup, 2: hide\n\t\t\tif (toggleShow) { // Truthy input toggles showing of auto-markup\n\t\t\t\tshowStyle = (showStyle + 2) % 4; // 0 => 2 or 2 => 0\n\t\t\t} else { // Falsy input toggles child vs sibling style\n\t\t\t\tchildStyle = (childStyle + 1) % 2; // 0 => 1 or 1 => 0\n\t\t\t}\n\t\t\tvariantStyle = childStyle + showStyle;\n\t\t\tnotifyListeners({\n\t\t\t\tvariantStyle: variantStyle,\n\t\t\t\tmarkupChange: true\n\t\t\t});\n\t\t}\n\n\t\t// Returns the variant style\n\t\tfunction getVariantStyle() {\n\t\t\treturn variantStyle;\n\t\t}\n\n\t\t// Directly sets the variant style\n\t\tfunction setVariantStyle(style) {\n\t\t\tif (style === 0 || style === 1 || style === 2 || style === 3) {\n\t\t\t\tvariantStyle = style;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tvariantStyle: variantStyle,\n\t\t\t\t\tmarkupChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction getGameInfo() {\n\t\t\treturn gameInfo;\n\t\t}\n\n\t\tfunction setGameInfo(info, id) {\n\t\t\tif (id) {\n\t\t\t\tgameInfo[id] = info;\n\t\t\t} else {\n\t\t\t\tgameInfo = info;\n\t\t\t}\n\t\t\tnotifyListeners({\n\t\t\t\tgameInfo: gameInfo\n\t\t\t});\n\t\t}\n\n\t\tfunction setComment(text) {\n\t\t\ttext = text.trim(); // Trim whitespace and standardize line breaks\n\t\t\ttext = text.replace(/\\r\\n/g, '\\n').replace(/\\n\\r/g, '\\n').replace(/\\r/g, '\\n');\n\t\t\ttext.replace(/\\f\\t\\v\\u0085\\u00a0/g, ' '); // Convert other whitespace to space\n\t\t\tcurrent.comment = text;\n\t\t\tnotifyListeners({\n\t\t\t\tcomment: text\n\t\t\t});\n\t\t}\n\n\t\t// Returns variants of the current node according to the set style\n\t\tfunction getVariants() {\n\t\t\tif (variantStyle >= 2) { // Do not show variants if style >= 2\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tif (variantStyle === 1) { // Display sibling variants\n\t\t\t\t// Root node does not have parent nor siblings\n\t\t\t\treturn current.parent ? current.parent.children : [];\n\t\t\t}\n\t\t\treturn current.children; // Otherwise, style must be 0, display child variants\n\t\t}\n\n\t\t// Returns the currently active node in the game state tree\n\t\tfunction getCurrent() {\n\t\t\treturn current;\n\t\t}\n\n\t\t// Returns the root of the game state tree\n\t\tfunction getRoot() {\n\t\t\treturn root;\n\t\t}\n\n\t\tfunction loadRoot(load) {\n\t\t\troot = load;\n\t\t\tcurrent = load;\n\t\t\tnotifyListeners({\n\t\t\t\ttreeChange: true,\n\t\t\t\tnavChange: true,\n\t\t\t\tstoneChange: true\n\t\t\t});\n\t\t}\n\n\t\t// Navigates forward num nodes (to the end if num === -1)\n\t\tfunction nextNode(num) {\n\t\t\tif (current.children.length === 0) { // Check if no children\n\t\t\t\treturn false; // Do nothing if no children (avoid notification)\n\t\t\t}\n\t\t\twhile (current.children.length > 0 && num !== 0) {\n\t\t\t\tif (navHistory.length) { // Non-empty navigation history\n\t\t\t\t\tcurrent = navHistory.pop();\n\t\t\t\t} else { // Empty navigation history\n\t\t\t\t\tcurrent = current.children[0]; // Go to first child\n\t\t\t\t}\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\tnotifyListeners({\n\t\t\t\tnavChange: true\n\t\t\t}, true); // Preserve history\n\t\t}\n\n\t\t// Navigates backward num nodes (to the root if num === -1)\n\t\tfunction prevNode(num) {\n\t\t\tif (current.parent === null) { // Check if root\n\t\t\t\treturn false; // Do nothing if already at root (avoid notification)\n\t\t\t}\n\t\t\twhile (current.parent && num !== 0) {\n\t\t\t\tnavHistory.push(current); // Save current into navigation history\n\t\t\t\tcurrent = current.parent;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\tnotifyListeners({\n\t\t\t\tnavChange: true\n\t\t\t}, true); // Preserve history\n\t\t}\n\n\t\t// Cyclically switches through siblings\n\t\tfunction nextSibling(change) {\n\t\t\tvar siblings,\n\t\t\t\ti = 0;\n\n\t\t\tif (current.parent) {\n\t\t\t\tsiblings = current.parent.children;\n\n\t\t\t\t// Exit early if only child\n\t\t\t\tif (siblings.length === 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Find index of current amongst siblings\n\t\t\t\ti = siblings.indexOf(current);\n\n\t\t\t\t// Apply change cyclically\n\t\t\t\ti = (i + change) % siblings.length;\n\t\t\t\tif (i < 0) {\n\t\t\t\t\ti += siblings.length;\n\t\t\t\t}\n\n\t\t\t\tcurrent = siblings[i];\n\t\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tnavChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Sets the current node\n\t\tfunction setCurrent(node) {\n\t\t\tif (current !== node) {\n\t\t\t\tcurrent = node;\n\t\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tnavChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Removes current branch from the tree\n\t\tfunction cutCurrent() {\n\t\t\tvar parent = current.parent;\n\t\t\tif (tool === 'navOnly') {\n\t\t\t\treturn; // Tree editing disabled in navOnly mode\n\t\t\t}\n\t\t\tif (parent) {\n\t\t\t\tif (confirm(\"Delete this branch?\") === true) {\n\t\t\t\t\tparent.removeChild(current);\n\t\t\t\t\tcurrent = parent;\n\t\t\t\t\t// Notify navigation and tree edited\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle click with application of selected tool\n\t\tfunction click(i, j, ctrlKey, shiftKey) {\n\t\t\tswitch (tool) {\n\t\t\t\tcase 'navOnly':\n\t\t\t\t\tnavigate(i, j, shiftKey);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'auto':\n\t\t\t\t\tif (!navigate(i, j, shiftKey) && !shiftKey) { // Try to navigate to (i, j)\n\t\t\t\t\t\tplayMove(i, j, 0, ctrlKey); // Play auto-color move if navigate fails\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'playB':\n\t\t\t\t\tplayMove(i, j, -1, ctrlKey); // Black move\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'playW':\n\t\t\t\t\tplayMove(i, j, 1, ctrlKey); // White move\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addB':\n\t\t\t\t\tplaceSetup(i, j, -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addW':\n\t\t\t\t\tplaceSetup(i, j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addE':\n\t\t\t\t\tplaceSetup(i, j, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'clrMark':\n\t\t\t\t\tsetMarkup(i, j, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'circle':\n\t\t\t\t\tsetMarkup(i, j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'square':\n\t\t\t\t\tsetMarkup(i, j, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'triangle':\n\t\t\t\t\tsetMarkup(i, j, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cross':\n\t\t\t\t\tsetMarkup(i, j, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'block':\n\t\t\t\t\tsetMarkup(i, j, 5);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'label':\n\t\t\t\t\tsetMarkup(i, j, label);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Navigates to child with move at (x, y), searching tree if shiftKey pressed\n\t\t// Returns true is successful, false if not\n\t\tfunction navigate(x, y, shiftKey) {\n\t\t\tvar i, move,\n\t\t\t\tchildren = current.children;\n\n\t\t\t// Look for move at same location in children\n\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\tmove = children[i].move;\n\t\t\t\tif (move && move.x === x && move.y === y) {\n\t\t\t\t\tcurrent = children[i]; // Navigate to child if found\n\t\t\t\t\t// Notify navigation (with no tree edits)\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\tnavChange: true\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Plays a move at the given color and location\n\t\t// Set allowAll to truthy to allow illegal moves\n\t\tfunction playMove(i, j, color, allowAll) {\n\t\t\tvar next;\n\t\t\t// Check if current node is immutable or root\n\t\t\tif (!current.isMutable('move') || !current.parent) {\n\t\t\t\tnext = current.makeChild(); // Create a new child node\n\t\t\t\tif (next.playMove(i, j, color, allowAll)) { // Play in new node\n\t\t\t\t\t// Keep (add to game state tree) only if move succeeds\n\t\t\t\t\tcurrent.addChild(next);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t\t// Notify tree change, navigation, and stone change\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true,\n\t\t\t\t\t\tstoneChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// Current node is mutable and not root\n\t\t\t} else if (current.playMove(i, j, color, allowAll)) { // Play in current\n\t\t\t\t// Only need to update if move succeeds\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tstoneChange: true\n\t\t\t\t}); // Stones changed\n\t\t\t}\n\t\t}\n\n\t\t// Places a setup stone at the given color and location\n\t\tfunction placeSetup(i, j, color) {\n\t\t\tvar next;\n\t\t\tif (color === current.getStone(i, j)) { // Compare setup to current\n\t\t\t\tif (color !== 0) {\n\t\t\t\t\tcolor = 0; // Same as current indicates removal desired\n\t\t\t\t} else { // Color and current are both empty\n\t\t\t\t\treturn; // No change if attempting to set empty to empty\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if current node can accept setup stones\n\t\t\tif (!current.isMutable('setup')) {\n\t\t\t\tnext = current.makeChild(); // Create a new child node\n\t\t\t\tif (next.placeSetup(i, j, color)) { // Place setup stone in new node\n\t\t\t\t\t// Keep (add to game state tree) only if change occurs\n\t\t\t\t\tcurrent.addChild(next);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t\t// Notify tree change, navigation, and stone change\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true,\n\t\t\t\t\t\tstoneChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (current.placeSetup(i, j, color)) { // Try setup in current\n\t\t\t\t// Only need to update if change occurs\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tstoneChange: true\n\t\t\t\t}); // Stones changed\n\t\t\t}\n\t\t}\n\n\t\t// Sets the markup at the given location and place\n\t\tfunction setMarkup(i, j, mark) {\n\t\t\tvar temp; // For label incrementing\n\t\t\tif (mark === current.getMarkup(i, j)) { // Compare mark to current\n\t\t\t\tif (mark !== 0) {\n\t\t\t\t\tmark = 0; // Same as current indicates removal desired\n\t\t\t\t} else { // Mark and current are both empty\n\t\t\t\t\treturn; // No change if attempting to set empty to empty\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (current.addMarkup(i, j, mark)) { // Try to add the markup\n\t\t\t\tif (typeof mark === 'string') { // If markup is a label, increment the label\n\t\t\t\t\tif (/^-?\\d+$/.test(mark)) { // Integer number label\n\t\t\t\t\t\ttemp = +mark; // Convert to number\n\t\t\t\t\t\t// Increment and convert back to string\n\t\t\t\t\t\tsetLabel(\"\" + (temp + 1));\n\t\t\t\t\t} else if (/[A-Za-z]$/.test(mark)) { // Ends with [A-Za-z]\n\t\t\t\t\t\t// Get the last character in the label\n\t\t\t\t\t\ttemp = mark.charAt(mark.length - 1);\n\t\t\t\t\t\tif (temp === 'z') { // Cyclical increment\n\t\t\t\t\t\t\ttemp = 'A'; // Move onto uppercase letters\n\t\t\t\t\t\t} else if (temp === 'Z') {\n\t\t\t\t\t\t\ttemp = 'a'; // Move onto lowercase letters\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp = String.fromCharCode(temp.charCodeAt() + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Replace last character of label with incremented char\n\t\t\t\t\t\tsetLabel(mark.slice(0, mark.length - 1) + temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tmarkupChange: true\n\t\t\t\t}); // Notify markup change\n\t\t\t}\n\t\t}\n\n\t\t// Adds a listener (by call back func) that will be notified on game/editor state changes\n\t\tfunction addListener(listener) {\n\t\t\tlisteners.push(listener);\n\t\t}\n\n\t\t// Notify listeners with the given message object\n\t\t//  Data sent to listeners:\n\t\t//    tool: changed tool selection\n\t\t//    label: changed next label\n\t\t//    coord: changed coordinate system \n\t\t//    variantStyle: changed variant style\n\t\t//    gameInfo: changed game info\n\t\t//    comment: changed comment in current node\n\t\t//  Flags sent to listeners:\n\t\t//    treeChange: nodes added or removed from tree\n\t\t//    navChange: current switched to different node\n\t\t//    stoneChange: stones modified in current node\n\t\t//    markupChange: markup modified in current node\n\t\tfunction notifyListeners(msg, keepHistory) {\n\t\t\tvar i;\n\t\t\tif (!keepHistory && msg.navChange) {\n\t\t\t\tnavHistory = []; // Clear navigation history\n\t\t\t}\n\t\t\tfor (i = 0; i < listeners.length; i++) {\n\t\t\t\tlisteners[i](msg);\n\t\t\t}\n\t\t}\n\t};\n\tbesogo.makeFilePanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar fileChooser, // Reference to the file chooser element\n\t\t\telement, // Scratch variable for creating elements\n\t\t\tWARNING = \"Everything not saved will be lost\";\n\n\t\tmakeNewBoardButton(9); // New 9x9 board button\n\t\tmakeNewBoardButton(13); // New 13x13 board button\n\t\tmakeNewBoardButton(19); // New 19x19 board button\n\t\tmakeNewBoardButton('?'); // New custom board button\n\n\t\t// Hidden file chooser element\n\t\tfileChooser = makeFileChooser();\n\t\tcontainer.appendChild(fileChooser);\n\n\t\t// Load file button\n\t\telement = document.createElement('input');\n\t\telement.type = 'button';\n\t\telement.value = 'Open';\n\t\telement.title = 'Import SGF';\n\t\telement.onclick = function() { // Bind click to the hidden file chooser\n\t\t\tfileChooser.click();\n\t\t};\n\t\tcontainer.appendChild(element);\n\n\t\t// Save file button\n\t\telement = document.createElement('input');\n\t\telement.type = 'button';\n\t\telement.value = 'Save';\n\t\telement.title = 'Export SGF';\n\t\telement.onclick = function() {\n\t\t\tvar fileName = prompt('Save file as', 'export.sgf');\n\t\t\tif (fileName) { // Canceled or empty string does nothing\n\t\t\t\tsaveFile(fileName, besogo.composeSgf(editor));\n\t\t\t}\n\t\t};\n\t\tcontainer.appendChild(element);\n\n\n\t\t// Makes a new board button\n\t\tfunction makeNewBoardButton(size) {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = size + \"x\" + size;\n\t\t\tif (size === '?') { // Make button for custom sized board\n\t\t\t\tbutton.title = \"New custom size board\";\n\t\t\t\tbutton.onclick = function() {\n\t\t\t\t\tvar input = prompt(\"Enter custom size for new board\" + \"\\n\" + WARNING, \"19:19\"),\n\t\t\t\t\t\tsize;\n\t\t\t\t\tif (input) { // Canceled or empty string does nothing\n\t\t\t\t\t\tsize = besogo.parseSize(input);\n\t\t\t\t\t\teditor.loadRoot(besogo.makeGameRoot(size.x, size.y));\n\t\t\t\t\t\teditor.setGameInfo({});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else { // Make button for fixed size board\n\t\t\t\tbutton.title = \"New \" + size + \"x\" + size + \" board\";\n\t\t\t\tbutton.onclick = function() {\n\t\t\t\t\tif (confirm(button.title + \"?\\n\" + WARNING)) {\n\t\t\t\t\t\teditor.loadRoot(besogo.makeGameRoot(size, size));\n\t\t\t\t\t\teditor.setGameInfo({});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tcontainer.appendChild(button);\n\t\t}\n\n\t\t// Creates the file selector\n\t\tfunction makeFileChooser() {\n\t\t\tvar chooser = document.createElement('input');\n\t\t\tchooser.type = 'file';\n\t\t\tchooser.style.display = 'none'; // Keep hidden\n\t\t\tchooser.onchange = readFile; // Read, parse and load on file select\n\t\t\treturn chooser;\n\t\t}\n\n\t\t// Reads, parses and loads an SGF file\n\t\tfunction readFile(evt) {\n\t\t\tvar file = evt.target.files[0], // Selected file\n\t\t\t\treader = new FileReader(),\n\t\t\t\tnewChooser = makeFileChooser(); // Create new file input to reset selection\n\n\t\t\tcontainer.replaceChild(newChooser, fileChooser); // Replace with the reset selector\n\t\t\tfileChooser = newChooser;\n\n\t\t\treader.onload = function(e) { // Parse and load game tree\n\t\t\t\tvar sgf;\n\t\t\t\ttry {\n\t\t\t\t\tsgf = besogo.parseSgf(e.target.result);\n\t\t\t\t} catch (error) {\n\t\t\t\t\talert('SGF parse error at ' + error.at + ':\\n' + error.message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbesogo.loadSgf(sgf, editor);\n\t\t\t};\n\t\t\tif (confirm(\"Load '\" + file.name + \"'?\\n\" + WARNING)) {\n\t\t\t\treader.readAsText(file); // Initiate file read\n\t\t\t}\n\t\t}\n\n\t\t// Composes SGF file and initializes download\n\t\tfunction saveFile(fileName, text) {\n\t\t\tvar link = document.createElement('a'),\n\t\t\t\tblob = new Blob([text], {\n\t\t\t\t\tencoding: \"UTF-8\",\n\t\t\t\t\ttype: \"text/plain;charset=UTF-8\"\n\t\t\t\t});\n\n\t\t\tlink.download = fileName; // Set download file name\n\t\t\tlink.href = URL.createObjectURL(blob);\n\t\t\tlink.style.display = 'none'; // Make link hidden\n\t\t\tcontainer.appendChild(link); // Add link to ensure that clicking works\n\t\t\tlink.click(); // Click on link to initiate download\n\t\t\tcontainer.removeChild(link); // Immediately remove the link\n\t\t}\n\t};\n\tbesogo.makeGameRoot = function(sizeX, sizeY) {\n\t\t'use strict';\n\t\tvar BLACK = -1, // Stone state constants\n\t\t\tWHITE = 1, // Equal to -BLACK\n\t\t\tEMPTY = 0, // Any falsy (e.g., undefined) value is also empty\n\n\t\t\troot = { // Inherited attributes of root node\n\t\t\t\tnextToMove: BLACK,\n\t\t\t\tblackCaps: 0,\n\t\t\t\twhiteCaps: 0,\n\t\t\t\tmoveNumber: 0\n\t\t\t};\n\n\t\t// Initializes non-inherited attributes\n\t\tfunction initNode(node, parent) {\n\t\t\tnode.parent = parent;\n\t\t\tnode.children = [];\n\n\t\t\tnode.move = null;\n\t\t\tnode.setupStones = [];\n\t\t\tnode.markup = [];\n\t\t\tnode.comment = ''; // Comment on this node\n\t\t}\n\t\tinitNode(root, null); // Initialize root node with null parent\n\n\n\t\t// Plays a move, returns true if successful\n\t\t// Set allow to truthy to allow overwrite, suicide and ko\n\t\troot.playMove = function(x, y, color, allow) {\n\t\t\tvar captures = 0, // Number of captures made by this move\n\t\t\t\toverwrite = false, // Flags whether move overwrites a stone\n\t\t\t\tprevMove, // Previous move for ko check\n\t\t\t\ttestBoard, // Copy of board state to test captures, ko, and suicide\n\t\t\t\tpending, // Pending capture locations\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!this.isMutable('move')) {\n\t\t\t\treturn false; // Move fails if node is immutable\n\t\t\t}\n\n\t\t\tif (!color) { // Falsy color indicates auto-color\n\t\t\t\tcolor = this.nextToMove;\n\t\t\t}\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\tthis.move = { // Register as pass move if out of bounds\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0, // Log pass as position (0, 0)\n\t\t\t\t\tcolor: color,\n\t\t\t\t\tcaptures: 0, // Pass never captures\n\t\t\t\t\toverwrite: false // Pass is never an overwrite\n\t\t\t\t};\n\t\t\t\tthis.nextToMove = -color; // Update next to move\n\t\t\t\tthis.moveNumber++; // Increment move number\n\t\t\t\treturn true; // Pass move successful\n\t\t\t}\n\n\t\t\tif (this.getStone(x, y)) { // Check for overwrite\n\t\t\t\tif (!allow) {\n\t\t\t\t\treturn false; // Reject overwrite move if not allowed\n\t\t\t\t}\n\t\t\t\toverwrite = true; // Otherwise, flag overwrite and proceed\n\t\t\t}\n\n\t\t\ttestBoard = Object.create(this); // Copy board state (no need to initialize)\n\t\t\tpending = []; // Initialize pending capture array\n\n\t\t\tsetStone(testBoard, x, y, color); // Place the move stone\n\n\t\t\t// Check for captures of surrounding chains\n\t\t\tcaptureStones(testBoard, x - 1, y, color, pending);\n\t\t\tcaptureStones(testBoard, x + 1, y, color, pending);\n\t\t\tcaptureStones(testBoard, x, y - 1, color, pending);\n\t\t\tcaptureStones(testBoard, x, y + 1, color, pending);\n\n\t\t\tcaptures = pending.length; // Capture count\n\n\t\t\tprevMove = this.parent ? this.parent.move : null; // Previous move played\n\t\t\tif (!allow && prevMove && // If previous move exists, ...\n\t\t\t\tprevMove.color === -color && // was of the opposite color, ...\n\t\t\t\tprevMove.overwrite === false && // not an overwrite, ...\n\t\t\t\tprevMove.captures === 1 && // captured exactly one stone, and if ...\n\t\t\t\tcaptures === 1 && // this move captured exactly one stone at the location ...\n\t\t\t\t!testBoard.getStone(prevMove.x, prevMove.y)) { // of the previous move\n\t\t\t\treturn false; // Reject ko move if not allowed\n\t\t\t}\n\n\t\t\tif (captures === 0) { // Check for suicide if nothing was captured\n\t\t\t\tcaptureStones(testBoard, x, y, -color, pending); // Invert color for suicide check\n\t\t\t\tcaptures = -pending.length; // Count suicide as negative captures\n\t\t\t\tif (captures < 0 && !allow) {\n\t\t\t\t\treturn false; // Reject suicidal move if not allowed\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (color * captures < 0) { // Capture by black or suicide by white\n\t\t\t\tthis.blackCaps += Math.abs(captures); // Tally captures for black\n\t\t\t} else { // Capture by white or suicide by black\n\t\t\t\tthis.whiteCaps += Math.abs(captures); // Tally captures for white\n\t\t\t}\n\n\t\t\tsetStone(this, x, y, color); // Place the stone\n\t\t\tfor (i = 0; i < pending.length; i++) { // Remove the captures\n\t\t\t\tsetStone(this, pending[i].x, pending[i].y, EMPTY);\n\t\t\t}\n\n\t\t\tthis.move = { // Log the move\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tcolor: color,\n\t\t\t\tcaptures: captures,\n\t\t\t\toverwrite: overwrite\n\t\t\t};\n\t\t\tthis.nextToMove = -color; // Update next to move\n\t\t\tthis.moveNumber++; // Increment move number\n\t\t\treturn true;\n\t\t}; // END func root.playMove\n\n\t\t// Check for and perform capture of opposite color chain at (x, y)\n\t\tfunction captureStones(board, x, y, color, captures) {\n\t\t\tvar pending = [],\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!recursiveCapture(board, x, y, color, pending)) { // Captured chain found\n\t\t\t\tfor (i = 0; i < pending.length; i++) { // Remove captured stones\n\t\t\t\t\tsetStone(board, pending[i].x, pending[i].y, EMPTY);\n\t\t\t\t\tcaptures.push(pending[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Recursively builds a chain of pending captures starting from (x, y)\n\t\t// Stops and returns true if chain has liberties\n\t\tfunction recursiveCapture(board, x, y, color, pending) {\n\t\t\tvar i; // Scratch iteration variable\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Stop if out of bounds\n\t\t\t}\n\t\t\tif (board.getStone(x, y) === color) {\n\t\t\t\treturn false; // Stop if other color found\n\t\t\t}\n\t\t\tif (!board.getStone(x, y)) {\n\t\t\t\treturn true; // Stop and signal that liberty was found\n\t\t\t}\n\t\t\tfor (i = 0; i < pending.length; i++) {\n\t\t\t\tif (pending[i].x === x && pending[i].y === y) {\n\t\t\t\t\treturn false; // Stop if already in pending captures\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpending.push({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t}); // Add new stone into chain of pending captures\n\n\t\t\t// Recursively check for liberties and expand chain\n\t\t\tif (recursiveCapture(board, x - 1, y, color, pending) ||\n\t\t\t\trecursiveCapture(board, x + 1, y, color, pending) ||\n\t\t\t\trecursiveCapture(board, x, y - 1, color, pending) ||\n\t\t\t\trecursiveCapture(board, x, y + 1, color, pending)) {\n\t\t\t\treturn true; // Stop and signal liberty found in subchain\n\t\t\t}\n\t\t\treturn false; // Otherwise, no liberties found\n\t\t}\n\n\t\t// Places a setup stone, returns true if successful\n\t\troot.placeSetup = function(x, y, color) {\n\t\t\tvar prevColor = (this.parent && this.parent.getStone(x, y)) || EMPTY;\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Do not allow out of bounds setup\n\t\t\t}\n\t\t\tif (!this.isMutable('setup') || this.getStone(x, y) === color) {\n\t\t\t\t// Prevent setup changes in immutable node or quit early if no change\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsetStone(this, x, y, color); // Place the setup stone\n\t\t\tthis.setupStones[fromXY(x, y)] = color - prevColor; // Record the necessary change\n\t\t\treturn true;\n\t\t};\n\n\t\t// Adds markup, returns true if successful\n\t\troot.addMarkup = function(x, y, mark) {\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Do not allow out of bounds markup\n\t\t\t}\n\t\t\tif (this.getMarkup(x, y) === mark) { // Quit early if no change to make\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.markup[fromXY(x, y)] = mark;\n\t\t\treturn true;\n\t\t};\n\n\t\t// Returns the stone status of the given position\n\t\troot.getStone = function(x, y) {\n\t\t\treturn this['board' + x + '-' + y] || EMPTY;\n\t\t};\n\n\t\t// Directly sets the stone state for the given game node\n\t\tfunction setStone(node, x, y, color) {\n\t\t\tnode['board' + x + '-' + y] = color;\n\t\t}\n\n\t\t// Gets the setup stone placed at (x, y), returns false if none\n\t\troot.getSetup = function(x, y) {\n\t\t\tif (!this.setupStones[fromXY(x, y)]) { // No setup stone placed\n\t\t\t\treturn false;\n\t\t\t} else { // Determine net effect of setup stone\n\t\t\t\tswitch (this.getStone(x, y)) {\n\t\t\t\t\tcase EMPTY:\n\t\t\t\t\t\treturn 'AE';\n\t\t\t\t\tcase BLACK:\n\t\t\t\t\t\treturn 'AB';\n\t\t\t\t\tcase WHITE:\n\t\t\t\t\t\treturn 'AW';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Gets the markup at (x, y)\n\t\troot.getMarkup = function(x, y) {\n\t\t\treturn this.markup[fromXY(x, y)] || EMPTY;\n\t\t};\n\n\t\t// Determines the type of this node\n\t\troot.getType = function() {\n\t\t\tvar i;\n\n\t\t\tif (this.move) { // Logged move implies move node\n\t\t\t\treturn 'move';\n\t\t\t}\n\n\t\t\tfor (i = 0; i < this.setupStones.length; i++) {\n\t\t\t\tif (this.setupStones[i]) { // Any setup stones implies setup node\n\t\t\t\t\treturn 'setup';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'empty'; // Otherwise, \"empty\" (neither move nor setup)\n\t\t};\n\n\t\t// Checks if this node can be modified by a 'type' action\n\t\troot.isMutable = function(type) {\n\t\t\t// Can only add a move to an empty node with no children\n\t\t\tif (type === 'move' && this.getType() === 'empty' && this.children.length === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Can only add setup stones to a non-move node with no children\n\t\t\tif (type === 'setup' && this.getType() !== 'move' && this.children.length === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// Gets siblings of this node\n\t\troot.getSiblings = function() {\n\t\t\treturn (this.parent && this.parent.children) || [];\n\t\t};\n\n\t\t// Makes a child node of this node, but does NOT add it to children\n\t\troot.makeChild = function() {\n\t\t\tvar child = Object.create(this); // Child inherits properties\n\t\t\tinitNode(child, this); // Initialize other properties\n\n\t\t\treturn child;\n\t\t};\n\n\t\t// Adds a child to this node\n\t\troot.addChild = function(child) {\n\t\t\tthis.children.push(child);\n\t\t};\n\n\t\t// Remove child node from this node, returning false if failed\n\t\troot.removeChild = function(child) {\n\t\t\tvar i = this.children.indexOf(child);\n\t\t\tif (i !== -1) {\n\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// Gets board size\n\t\troot.getSize = function() {\n\t\t\treturn {\n\t\t\t\tx: sizeX,\n\t\t\t\ty: sizeY\n\t\t\t};\n\t\t};\n\n\t\treturn root;\n\n\t\t// Convert (x, y) coordinates to linear index\n\t\tfunction fromXY(x, y) {\n\t\t\treturn (x - 1) * sizeY + (y - 1);\n\t\t}\n\t};\n\t// Load a parsed SGF object into a game state tree\n\tbesogo.loadSgf = function(sgf, editor) {\n\t\t'use strict';\n\t\tvar size = {\n\t\t\t\tx: 19,\n\t\t\t\ty: 19\n\t\t\t}, // Default size (may be changed by load)\n\t\t\troot;\n\n\t\tloadRootProps(sgf); // Load size, variants style and game info\n\t\troot = besogo.makeGameRoot(size.x, size.y);\n\n\t\tloadNodeTree(sgf, root); // Load the rest of game tree\n\t\teditor.loadRoot(root); // Load root into the editor\n\n\n\t\t// Loads the game tree\n\t\tfunction loadNodeTree(sgfNode, gameNode) {\n\t\t\tvar i, nextGameNode;\n\n\t\t\t// Load properties from the SGF node into the game state node\n\t\t\tfor (i = 0; i < sgfNode.props.length; i++) {\n\t\t\t\tloadProp(gameNode, sgfNode.props[i]);\n\t\t\t}\n\n\t\t\t// Recursively load the rest of the tree\n\t\t\tfor (i = 0; i < sgfNode.children.length; i++) {\n\t\t\t\tnextGameNode = gameNode.makeChild();\n\t\t\t\tgameNode.addChild(nextGameNode);\n\t\t\t\tloadNodeTree(sgfNode.children[i], nextGameNode);\n\t\t\t}\n\t\t}\n\n\t\t// Loads property into node\n\t\tfunction loadProp(node, prop) {\n\t\t\tvar setupFunc = 'placeSetup',\n\t\t\t\tmarkupFunc = 'addMarkup',\n\t\t\t\tmove;\n\n\t\t\tswitch (prop.id) {\n\t\t\t\tcase 'B': // Play a black move\n\t\t\t\t\tmove = lettersToCoords(prop.values[0]);\n\t\t\t\t\tnode.playMove(move.x, move.y, -1, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W': // Play a white move\n\t\t\t\t\tmove = lettersToCoords(prop.values[0]);\n\t\t\t\t\tnode.playMove(move.x, move.y, 1, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AB': // Setup black stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AW': // Setup white stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AE': // Setup empty stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'CR': // Add circle markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SQ': // Add square markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'TR': // Add triangle markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M': // Intentional fallthrough treats 'M' as 'MA'\n\t\t\t\tcase 'MA': // Add 'X' cross markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SL': // Add 'selected' (small filled square) markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 5);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L': // Intentional fallthrough treats 'L' as 'LB'\n\t\t\t\tcase 'LB': // Add label markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 'label');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C': // Comment placed on node\n\t\t\t\t\tif (node.comment) {\n\t\t\t\t\t\tnode.comment += '\\n' + prop.values.join().trim();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.comment = prop.values.join().trim();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} // END function loadProp\n\n\t\t// Extracts point list and calls func on each\n\t\t// Set param to 'label' to signal handling of label markup property\n\t\tfunction applyPointList(values, node, func, param) {\n\t\t\tvar i, x, y, // Scratch iteration variables\n\t\t\t\tpoint, // Current point in iteration\n\t\t\t\totherPoint, // Bottom-right point of compressed point lists\n\t\t\t\tlabel; // Label extracted from value\n\t\t\tfor (i = 0; i < values.length; i++) {\n\t\t\t\tpoint = lettersToCoords(values[i].slice(0, 2));\n\t\t\t\tif (param === 'label') { // Label markup property\n\t\t\t\t\tlabel = values[i].slice(3).replace(/\\n/g, ' ');\n\t\t\t\t\tnode[func](point.x, point.y, label); // Apply with extracted label\n\t\t\t\t} else { // Not a label markup property\n\t\t\t\t\tif (values[i].charAt(2) === ':') { // Expand compressed point list\n\t\t\t\t\t\totherPoint = lettersToCoords(values[i].slice(3));\n\t\t\t\t\t\tif (otherPoint.x === point.x && otherPoint.y === point.y) {\n\t\t\t\t\t\t\t// Redundant compressed pointlist\n\t\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t\t} else if (otherPoint.x < point.x || otherPoint.y < point.y) {\n\t\t\t\t\t\t\t// Only apply to corners if not arranged properly\n\t\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t\t\tnode[func](otherPoint.x, otherPoint.y, param);\n\t\t\t\t\t\t} else { // Iterate over the compressed points\n\t\t\t\t\t\t\tfor (x = point.x; x <= otherPoint.x; x++) {\n\t\t\t\t\t\t\t\tfor (y = point.y; y <= otherPoint.y; y++) {\n\t\t\t\t\t\t\t\t\tnode[func](x, y, param);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // Apply on single point\n\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function applyPointList\n\n\t\t// Loads root properties (size, variant style and game info)\n\t\tfunction loadRootProps(node) {\n\t\t\tvar gameInfoIds = ['PB', 'BR', 'BT', 'PW', 'WR', 'WT', // Player info\n\t\t\t\t\t'HA', 'KM', 'RU', 'TM', 'OT', // Game parameters\n\t\t\t\t\t'DT', 'EV', 'GN', 'PC', 'RO', // Event info\n\t\t\t\t\t'GC', 'ON', 'RE', // General comments\n\t\t\t\t\t'AN', 'CP', 'SO', 'US'\n\t\t\t\t], // IP credits\n\t\t\t\tgameInfo = {}, // Structure for game info properties\n\t\t\t\ti, id, value; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < node.props.length; i++) {\n\t\t\t\tid = node.props[i].id; // Property ID\n\t\t\t\tvalue = node.props[i].values.join().trim(); // Join the values array\n\t\t\t\tif (id === 'SZ') { // Size property\n\t\t\t\t\tsize = besogo.parseSize(value);\n\t\t\t\t} else if (id === 'ST') { // Style property\n\t\t\t\t\teditor.setVariantStyle(+value); // Converts value to number\n\t\t\t\t} else if (gameInfoIds.indexOf(id) !== -1) { // Game info property\n\t\t\t\t\tif (id !== 'GC') { // Treat all but GC as simpletext\n\t\t\t\t\t\tvalue = value.replace(/\\n/g, ' '); // Convert line breaks to spaces\n\t\t\t\t\t}\n\t\t\t\t\tif (value) { // Skip load of empty game info strings\n\t\t\t\t\t\tgameInfo[id] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teditor.setGameInfo(gameInfo);\n\t\t}\n\n\t\t// Converts letters to numerical coordinates\n\t\tfunction lettersToCoords(letters) {\n\t\t\tif (letters.match(/^[A-Za-z]{2}$/)) { // Verify input is two letters\n\t\t\t\treturn {\n\t\t\t\t\tx: charToNum(letters.charAt(0)),\n\t\t\t\t\ty: charToNum(letters.charAt(1))\n\t\t\t\t};\n\t\t\t} else { // Anything but two letters\n\t\t\t\treturn {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t}; // Return (0, 0) coordinates\n\t\t\t}\n\t\t}\n\n\t\tfunction charToNum(c) { // Helper for lettersToCoords\n\t\t\tif (c.match(/[A-Z]/)) { // Letters A-Z to 27-52\n\t\t\t\treturn c.charCodeAt(0) - 'A'.charCodeAt(0) + 27;\n\t\t\t} else { // Letters a-z to 1-26\n\t\t\t\treturn c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n\t\t\t}\n\t\t}\n\t};\n\tbesogo.makeNamesPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar playerBox = document.createElement('div'),\n\t\t\twhiteBox = document.createElement('div'),\n\t\t\tblackBox = document.createElement('div'),\n\t\t\twhiteInfo = document.createTextNode(''),\n\t\t\tblackInfo = document.createTextNode(''),\n\t\t\twhiteCaps = document.createElement('span'),\n\t\t\tblackCaps = document.createElement('span');\n\n\t\tplayerBox.className = 'besogo-playerInfo';\n\t\twhiteBox.className = 'besogo-whiteInfo';\n\t\tblackBox.className = 'besogo-blackInfo';\n\t\twhiteCaps.className = 'besogo-whiteCaps';\n\t\twhiteCaps.title = 'White captures';\n\t\tblackCaps.className = 'besogo-blackCaps';\n\t\tblackCaps.title = 'Black captures';\n\t\twhiteBox.appendChild(whiteInfo);\n\t\twhiteBox.appendChild(whiteCaps);\n\t\tblackBox.appendChild(blackInfo);\n\t\tblackBox.appendChild(blackCaps);\n\t\tplayerBox.appendChild(whiteBox);\n\t\tplayerBox.appendChild(blackBox);\n\t\tcontainer.appendChild(playerBox);\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tgameInfo: editor.getGameInfo()\n\t\t});\n\n\t\tfunction update(msg) {\n\t\t\tvar infoString, // Scratch string\n\t\t\t\ttextNode,\n\t\t\t\tcurrent,\n\t\t\t\tpassFlag = 0;\n\n\t\t\tif (msg.gameInfo) {\n\t\t\t\tinfoString = (msg.gameInfo.PW || 'White') + // White name\n\t\t\t\t\t' (' + (msg.gameInfo.WR || '?') + ')' + // White rank\n\t\t\t\t\t(msg.gameInfo.WT ? ' ' + msg.gameInfo.WT : ''); // White team\n\t\t\t\ttextNode = document.createTextNode(infoString);\n\t\t\t\twhiteBox.replaceChild(textNode, whiteInfo);\n\t\t\t\twhiteInfo = textNode;\n\n\t\t\t\tinfoString = (msg.gameInfo.PB || 'Black') + // Black name\n\t\t\t\t\t' (' + (msg.gameInfo.BR || '?') + ')' + // Black rank\n\t\t\t\t\t(msg.gameInfo.BT ? ' ' + msg.gameInfo.BT : ''); // Black team\n\t\t\t\ttextNode = document.createTextNode(infoString);\n\t\t\t\tblackBox.replaceChild(textNode, blackInfo);\n\t\t\t\tblackInfo = textNode;\n\t\t\t}\n\n\t\t\tif (msg.navChange || msg.stoneChange) {\n\t\t\t\tcurrent = editor.getCurrent();\n\t\t\t\tif (current.move && current.move.x === 0 && current.move.y === 0) {\n\t\t\t\t\tpassFlag = current.move.color;\n\t\t\t\t}\n\t\t\t\tupdateText(whiteCaps, (passFlag === 1 ? 'Passed  ' : '') + current.whiteCaps);\n\t\t\t\tupdateText(blackCaps, current.blackCaps + (passFlag === -1 ? '  Passed' : ''));\n\t\t\t}\n\t\t}\n\n\t\tfunction updateText(parent, text) {\n\t\t\tvar textNode = document.createTextNode(text);\n\t\t\twhile (parent.firstChild) {\n\t\t\t\tparent.removeChild(parent.firstChild);\n\t\t\t}\n\t\t\tparent.appendChild(textNode);\n\t\t}\n\t};\n\tbesogo.parseSgf = function(text) {\n\t\t'use strict';\n\t\tvar at = 0, // Current position\n\t\t\tch = text.charAt(at); // Current character at position\n\n\t\tfindOpenParens(); // Find beginning of game tree\n\t\treturn parseTree(); // Parse game tree\n\n\t\t// Builds and throws an error\n\t\tfunction error(msg) {\n\t\t\tthrow {\n\t\t\t\tname: \"Syntax Error\",\n\t\t\t\tmessage: msg,\n\t\t\t\tat: at,\n\t\t\t\ttext: text\n\t\t\t};\n\t\t}\n\n\t\t// Advances text position by one\n\t\tfunction next(check) {\n\t\t\tif (check && check !== ch) { // Verify current character if param given\n\t\t\t\terror(\"Expected '\" + check + \"' instead of '\" + ch + \"'\");\n\t\t\t}\n\t\t\tat++;\n\t\t\tch = text.charAt(at);\n\t\t\treturn ch;\n\t\t}\n\n\t\t// Skips over whitespace until non-whitespace found\n\t\tfunction white() {\n\t\t\twhile (ch && ch <= ' ') {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t\t// Skips all chars until '(' or end found\n\t\tfunction findOpenParens() {\n\t\t\twhile (ch && ch !== '(') {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t\t// Returns true if line break (CR, LF, CR+LF, LF+CR) found\n\t\t// Advances the cursor ONCE for double character (CR+LF, LF+CR) line breaks\n\t\tfunction lineBreak() {\n\t\t\tif (ch === '\\n') { // Line Feed (LF)\n\t\t\t\tif (text.charAt(at + 1) === '\\r') { // LF+CR, double character line break\n\t\t\t\t\tnext(); // Advance cursor only once (pointing at second character)\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (ch === '\\r') { // Carriage Return (CR)\n\t\t\t\tif (text.charAt(at + 1) === '\\n') { // CR+LF, double character line break\n\t\t\t\t\tnext(); // Advance cursor only once (pointing at second character)\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false; // Did not find a line break or advance\n\t\t}\n\n\t\t// Parses a sub-tree of the game record\n\t\tfunction parseTree() {\n\t\t\tvar rootNode, // Root of this sub-tree\n\t\t\t\tcurrentNode, // Pointer to parent of the next node\n\t\t\t\tnextNode; // Scratch for parsing the next node or sub-tree\n\n\t\t\tnext('('); // Double-check opening parens at start of sub-tree\n\t\t\twhite(); // Skip whitespace before root node\n\n\t\t\tif (ch !== \";\") { // Error on sub-tree missing root node\n\t\t\t\terror(\"Sub-tree missing root\");\n\t\t\t}\n\t\t\trootNode = parseNode(); // Get the first node of this sub-tree\n\t\t\twhite(); // Skip whitespace before parsing next node\n\n\t\t\tcurrentNode = rootNode; // Parent of the next node parsed\n\t\t\twhile (ch === ';') { // Get sequence of nodes within this sub-tree\n\t\t\t\tnextNode = parseNode(); // Parse the next node\n\t\t\t\t// Add next node as child of current\n\t\t\t\tcurrentNode.children.push(nextNode);\n\t\t\t\tcurrentNode = nextNode; // Advance current pointer to this child\n\t\t\t\twhite(); // Skip whitespace between/after sequence nodes\n\t\t\t}\n\n\t\t\t// Look for sub-trees of this sub-tree\n\t\t\twhile (ch === \"(\") {\n\t\t\t\tnextNode = parseTree(); // Parse the next sub-tree\n\t\t\t\t// Add sub-tree as child of last sequence node\n\t\t\t\tcurrentNode.children.push(nextNode); // Do NOT advance current\n\t\t\t\twhite(); // Skip whitespace between/after sub-trees\n\t\t\t}\n\t\t\tnext(')'); // Expect closing parenthesis at end of this sub-tree\n\n\t\t\treturn rootNode;\n\t\t}\n\n\t\t// Parses a node and its properties\n\t\tfunction parseNode() {\n\t\t\tvar property, // Scratch for parsing properties\n\t\t\t\tnode = {\n\t\t\t\t\tprops: [],\n\t\t\t\t\tchildren: []\n\t\t\t\t}; // Node to construct\n\n\t\t\tnext(';'); // Double-check semi-colon at start of node\n\t\t\twhite(); // Skip whitespace before properties\n\t\t\t// Parse properties until end of node detected\n\t\t\twhile (ch && ch !== ';' && ch !== '(' && ch !== ')') {\n\t\t\t\tproperty = parseProperty(); // Parse the property and values\n\t\t\t\tnode.props.push(property); // Add property to node\n\t\t\t\twhite(); // Skip whitespace between/after properties\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\n\t\t// Parses a property and its values\n\t\tfunction parseProperty() {\n\t\t\tvar property = {\n\t\t\t\tid: '',\n\t\t\t\tvalues: []\n\t\t\t}; // Property to construct\n\n\t\t\t// Look for property ID within letters\n\t\t\twhile (ch && /[A-Za-z]/.test(ch)) {\n\t\t\t\tif (/[A-Z]/.test(ch)) { // Ignores lower case letters\n\t\t\t\t\tproperty.id += ch; // Only adds upper case letters\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t}\n\t\t\tif (!property.id) { // Error if id empty\n\t\t\t\terror('Missing property ID');\n\t\t\t}\n\n\t\t\twhite(); // Skip whitespace before values\n\t\t\twhile (ch === '[') { // Look for values of this property\n\t\t\t\tproperty.values.push(parseValue());\n\t\t\t\twhite(); // Skip whitespace between/after values\n\t\t\t}\n\t\t\tif (property.values.length === 0) { // Error on empty list of values\n\t\t\t\terror('Missing property values');\n\t\t\t}\n\n\t\t\treturn property;\n\t\t}\n\n\t\t// Parses a value\n\t\tfunction parseValue() {\n\t\t\tvar value = '';\n\t\t\tnext('['); // Double-check opening bracket at start of value\n\n\t\t\t// Read until end of value (unescaped closing bracket)\n\t\t\twhile (ch && ch !== ']') {\n\t\t\t\tif (ch === '\\\\') { // Backslash escape handling\n\t\t\t\t\tnext('\\\\');\n\t\t\t\t\tif (lineBreak()) { // Soft (escaped) line break\n\t\t\t\t\t\t// Nothing, soft line breaks are removed\n\t\t\t\t\t} else if (ch <= ' ') { // Other whitespace\n\t\t\t\t\t\tvalue += ' '; // Convert to space\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += ch; // Pass other escaped characters verbatim\n\t\t\t\t\t}\n\t\t\t\t} else { // Non-escaped character\n\t\t\t\t\tif (lineBreak()) { // Hard (non-escaped) line break\n\t\t\t\t\t\tvalue += '\\n'; // Convert all new lines to just LF\n\t\t\t\t\t} else if (ch <= ' ') { // Other whitespace\n\t\t\t\t\t\tvalue += ' '; // Convert to space\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += ch; // Other characters\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t}\n\t\t\tnext(']'); // Expect closing bracket at end of value\n\n\t\t\treturn value;\n\t\t}\n\t};\n\t// Convert game state tree into SGF string\n\tbesogo.composeSgf = function(editor) {\n\t\t'use strict';\n\t\treturn '(' + composeNode(editor.getRoot()) + ')';\n\n\t\t// Recursively composes game node tree\n\t\tfunction composeNode(tree) {\n\t\t\tvar string = ';', // Node starts with semi-colon\n\t\t\t\tchildren = tree.children,\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!tree.parent) { // Null parent means node is root\n\t\t\t\t// Compose root-specific properties\n\t\t\t\tstring += composeRootProps(tree);\n\t\t\t}\n\t\t\tstring += composeNodeProps(tree); // Compose general properties\n\n\t\t\t// Recurse composition on child nodes\n\t\t\tif (children.length === 1) { // Continue sequence if only one child\n\t\t\t\tstring += '\\n' + composeNode(children[0]);\n\t\t\t} else if (children.length > 1) {\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tstring += '\\n(' + composeNode(children[i]) + ')';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn string;\n\t\t}\n\n\t\t// Composes root specific properties\n\t\tfunction composeRootProps(tree) {\n\t\t\tvar string = 'FF[4]GM[1]CA[UTF-8]AP[besogo:' + besogo.VERSION + ']',\n\t\t\t\tx = tree.getSize().x,\n\t\t\t\ty = tree.getSize().y,\n\t\t\t\tgameInfo = editor.getGameInfo(), // Game info structure\n\t\t\t\thasGameInfo = false, // Flag for existence of game info\n\t\t\t\tid; // Scratch iteration variable\n\n\t\t\tif (x === y) { // Square board size\n\t\t\t\tstring += 'SZ[' + x + ']';\n\t\t\t} else { // Non-square board size\n\t\t\t\tstring += 'SZ[' + x + ':' + y + ']';\n\t\t\t}\n\t\t\tstring += 'ST[' + editor.getVariantStyle() + ']\\n'; // Line break after header\n\n\t\t\tfor (id in gameInfo) { // Compose game info properties\n\t\t\t\tif (gameInfo.hasOwnProperty(id) && gameInfo[id]) { // Skip empty strings\n\t\t\t\t\tstring += id + '[' + escapeText(gameInfo[id]) + ']';\n\t\t\t\t\thasGameInfo = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += (hasGameInfo ? '\\n' : ''); // Line break if game info exists\n\n\t\t\treturn string;\n\t\t}\n\n\t\t// Composes other properties\n\t\tfunction composeNodeProps(node) {\n\t\t\tvar string = '',\n\t\t\t\tprops, // Scratch variable for property structures\n\t\t\t\tstone, i, j; // Scratch iteration variables\n\n\t\t\t// Compose either move or setup properties depending on type of node\n\t\t\tif (node.getType() === 'move') { // Compose move properties\n\t\t\t\tstone = node.move;\n\t\t\t\tstring += (stone.color === 1) ? 'W' : 'B';\n\t\t\t\tstring += '[' + coordsToLetters(stone.x, stone.y) + ']';\n\t\t\t} else if (node.getType() === 'setup') { // Compose setup properties\n\t\t\t\tprops = {\n\t\t\t\t\tAB: [],\n\t\t\t\t\tAW: [],\n\t\t\t\t\tAE: []\n\t\t\t\t};\n\t\t\t\tfor (i = 1; i <= node.getSize().x; i++) {\n\t\t\t\t\tfor (j = 1; j <= node.getSize().y; j++) {\n\t\t\t\t\t\tstone = node.getSetup(i, j);\n\t\t\t\t\t\tif (stone) { // If setup stone placed, add to structure\n\t\t\t\t\t\t\tprops[stone].push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstring += composePointLists(props);\n\t\t\t}\n\n\t\t\t// Compose markup properties\n\t\t\tprops = {\n\t\t\t\tCR: [],\n\t\t\t\tSQ: [],\n\t\t\t\tTR: [],\n\t\t\t\tMA: [],\n\t\t\t\tSL: [],\n\t\t\t\tLB: []\n\t\t\t};\n\t\t\tfor (i = 1; i <= node.getSize().x; i++) {\n\t\t\t\tfor (j = 1; j <= node.getSize().y; j++) {\n\t\t\t\t\tstone = node.getMarkup(i, j);\n\t\t\t\t\tif (stone) { // If markup placed\n\t\t\t\t\t\tif (typeof stone === 'string') { // String is label mark\n\t\t\t\t\t\t\tprops.LB.push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j,\n\t\t\t\t\t\t\t\tlabel: stone\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else { // Numerical code for markup\n\t\t\t\t\t\t\t// Convert numerical code to property ID\n\t\t\t\t\t\t\tstone = (['CR', 'SQ', 'TR', 'MA', 'SL'])[stone - 1];\n\t\t\t\t\t\t\tprops[stone].push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += composePointLists(props);\n\n\t\t\tif (node.comment) { // Compose comment property\n\t\t\t\tstring += (string ? '\\n' : ''); // Add line break if other properties exist\n\t\t\t\tstring += 'C[' + escapeText(node.comment) + ']';\n\t\t\t}\n\n\t\t\treturn string;\n\t\t} // END function composeNodeProps\n\n\t\t// Composes properties from structure of point lists\n\t\t// Each member should be an array of points for property ID = key\n\t\t// Each point should specify point with (x, y) and may have optional label\n\t\tfunction composePointLists(lists) {\n\t\t\tvar string = '',\n\t\t\t\tid, points, i; // Scratch iteration variables\n\n\t\t\tfor (id in lists) { // Object own keys specifies property IDs\n\t\t\t\tif (lists.hasOwnProperty(id)) {\n\t\t\t\t\tpoints = lists[id]; // Corresponding members are point lists\n\t\t\t\t\tif (points.length > 0) { // Only add property if list non-empty\n\t\t\t\t\t\tstring += id;\n\t\t\t\t\t\tfor (i = 0; i < points.length; i++) {\n\t\t\t\t\t\t\tstring += '[' + coordsToLetters(points[i].x, points[i].y);\n\t\t\t\t\t\t\tif (points[i].label) { // Add optional composed label\n\t\t\t\t\t\t\t\tstring += ':' + escapeText(points[i].label);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstring += ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\n\t\t// Escapes backslash and close bracket for text output\n\t\tfunction escapeText(input) {\n\t\t\tinput = input.replace(/\\\\/g, '\\\\\\\\'); // Escape backslash\n\t\t\treturn input.replace(/\\]/g, '\\\\]'); // Escape close bracket\n\t\t}\n\n\t\t// Converts numerical coordinates to letters\n\t\tfunction coordsToLetters(x, y) {\n\t\t\tif (x === 0 || y === 0) {\n\t\t\t\treturn '';\n\t\t\t} else {\n\t\t\t\treturn numToChar(x) + numToChar(y);\n\t\t\t}\n\t\t}\n\n\t\tfunction numToChar(num) { // Helper for coordsToLetters\n\t\t\tif (num > 26) { // Numbers 27-52 to A-Z\n\t\t\t\treturn String.fromCharCode('A'.charCodeAt(0) + num - 27);\n\t\t\t} else { // Numbers 1-26 to a-z\n\t\t\t\treturn String.fromCharCode('a'.charCodeAt(0) + num - 1);\n\t\t\t}\n\t\t}\n\t};\n\t(function() {\n\t\t'use strict';\n\n\t\t// Color palette\n\t\tbesogo.RED = '#be0119'; // Darker red (marked variant)\n\t\tbesogo.LRED = '#ff474c'; // Lighter red (auto-marked variant)\n\t\tbesogo.BLUE = '#0165fc'; // Bright blue (last move)\n\t\tbesogo.PURP = '#9a0eea'; // Red + blue (variant + last move)\n\t\tbesogo.GREY = '#929591'; // Between white and black\n\t\tbesogo.GOLD = '#dbb40c'; // Tool selection\n\t\tbesogo.TURQ = '#06c2ac'; // Turqoise (nav selection)\n\n\t\tbesogo.BLACK_STONES = 4; // Number of black stone images\n\t\tbesogo.WHITE_STONES = 11; // Number of white stone images\n\n\t\t// Makes an SVG element with given name and attributes\n\t\tbesogo.svgEl = function(name, attributes) {\n\t\t\tvar attr, // Scratch iteration variable\n\t\t\t\telement = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n\n\t\t\tfor (attr in (attributes || {})) { // Add attributes if supplied\n\t\t\t\tif (attributes.hasOwnProperty(attr)) {\n\t\t\t\t\telement.setAttribute(attr, attributes[attr]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn element;\n\t\t};\n\n\t\t// Makes an SVG group for containing the shadow layer\n\t\tbesogo.svgShadowGroup = function() {\n\t\t\tvar group = besogo.svgEl('g'),\n\t\t\t\tfilter = besogo.svgEl('filter', {\n\t\t\t\t\tid: 'blur'\n\t\t\t\t}),\n\t\t\t\tblur = besogo.svgEl('feGaussianBlur', {\n\t\t\t\t\tin: 'SourceGraphic',\n\t\t\t\t\tstdDeviation: '2'\n\t\t\t\t});\n\n\t\t\tfilter.appendChild(blur);\n\t\t\tgroup.appendChild(filter);\n\t\t\treturn group;\n\t\t};\n\n\t\t// Makes a stone shadow\n\t\tbesogo.svgShadow = function(x, y) {\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 43,\n\t\t\t\tstroke: 'none',\n\t\t\t\tfill: 'black',\n\t\t\t\topacity: 0.32,\n\t\t\t\tfilter: 'url(#blur)'\n\t\t\t});\n\t\t};\n\n\t\t// Makes a photo realistic stone element\n\t\tbesogo.realStone = function(x, y, color, index) {\n\t\t\tvar element;\n\n\t\t\tif (color < 0) {\n\t\t\t\tcolor = 'black' + (index % besogo.BLACK_STONES);\n\t\t\t} else {\n\t\t\t\tcolor = 'white' + (index % besogo.WHITE_STONES);\n\t\t\t}\n\t\t\tcolor = 'img/' + color + '.png';\n\n\t\t\telement = besogo.svgEl(\"image\", {\n\t\t\t\tx: (x - 44),\n\t\t\t\ty: (y - 44),\n\t\t\t\theight: 88,\n\t\t\t\twidth: 88\n\t\t\t});\n\t\t\telement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', color);\n\n\t\t\treturn element;\n\t\t};\n\n\t\t// Makes a stone element\n\t\tbesogo.svgStone = function(x, y, color) {\n\t\t\tvar className = \"besogo-svg-greyStone\"; // Grey stone by default\n\n\t\t\tif (color === -1) { // Black stone\n\t\t\t\tclassName = \"besogo-svg-blackStone\";\n\t\t\t} else if (color === 1) { // White stone\n\t\t\t\tclassName = \"besogo-svg-whiteStone\";\n\t\t\t}\n\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 42,\n\t\t\t\t'class': className\n\t\t\t});\n\t\t};\n\n\t\t// Makes a circle at (x, y)\n\t\tbesogo.svgCircle = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 27,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes a square at (x, y)\n\t\tbesogo.svgSquare = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: (x - 23),\n\t\t\t\ty: (y - 23),\n\t\t\t\twidth: 46,\n\t\t\t\theight: 46,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an equilateral triangle at (x, y)\n\t\tbesogo.svgTriangle = function(x, y, color) {\n\t\t\t// Approximates an equilateral triangle centered on (x, y)\n\t\t\tvar pointString = \"\" + x + \",\" + (y - 30) + \" \" +\n\t\t\t\t(x - 26) + \",\" + (y + 15) + \" \" +\n\t\t\t\t(x + 26) + \",\" + (y + 15);\n\n\t\t\treturn besogo.svgEl(\"polygon\", {\n\t\t\t\tpoints: pointString,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an \"X\" cross at (x, y)\n\t\tbesogo.svgCross = function(x, y, color) {\n\t\t\tvar path = \"m\" + (x - 24) + \",\" + (y - 24) + \"l48,48m0,-48l-48,48\";\n\n\t\t\treturn besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an \"+\" plus sign at (x, y)\n\t\tbesogo.svgPlus = function(x, y, color) {\n\t\t\tvar path = \"m\" + x + \",\" + (y - 28) + \"v56m-28,-28h56\";\n\n\t\t\treturn besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes a small filled square at (x, y)\n\t\tbesogo.svgBlock = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: x - 18,\n\t\t\t\ty: y - 18,\n\t\t\t\twidth: 36,\n\t\t\t\theight: 36,\n\t\t\t\tstroke: \"none\",\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: color\n\t\t\t});\n\t\t};\n\n\t\t// Makes a label at (x, y)\n\t\tbesogo.svgLabel = function(x, y, color, label) {\n\t\t\tvar element,\n\t\t\t\tsize;\n\n\t\t\t// Trims label to 3 characters\n\t\t\tif (label.length > 3) {\n\t\t\t\tlabel = label.slice(0, 2) + '';\n\t\t\t}\n\n\t\t\t// Set font size according to label length\n\t\t\tswitch (label.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsize = 72;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsize = 56;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsize = 36;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\telement = besogo.svgEl(\"text\", {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tdy: \".65ex\", // Seems to work for vertically centering these fonts\n\t\t\t\t\"font-size\": size,\n\t\t\t\t\"text-anchor\": \"middle\", // Horizontal centering\n\t\t\t\t\"font-family\": \"Helvetica, Arial, sans-serif\",\n\t\t\t\tfill: color\n\t\t\t});\n\t\t\telement.appendChild(document.createTextNode(label));\n\n\t\t\treturn element;\n\t\t};\n\n\t})(); // END closure\n\tbesogo.makeToolPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar element, // Scratch for building SVG images\n\t\t\tsvg, // Scratch for building SVG images\n\t\t\tlabelText, // Text area for next label input\n\t\t\tselectors = {}, // Holds selection rects\n\t\t\tpassButton = document.createElement('input'),\n\t\t\tcutButton = document.createElement('input');\n\n\t\tsvg = makeButtonSVG('auto', 'Auto-play/nav'); // Auto-play/nav tool button\n\t\tsvg.appendChild(makeYinYang(0, 0));\n\n\t\tsvg = makeButtonSVG('playB', 'Play black'); // Play black button\n\t\tsvg.appendChild(besogo.svgStone(0, 0, -1));\n\n\t\tsvg = makeButtonSVG('playW', 'Play white'); // Play white button\n\t\tsvg.appendChild(besogo.svgStone(0, 0, 1));\n\n\t\tsvg = makeButtonSVG('addB', 'Set black'); // Add black button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0, -1)); // Black stone\n\t\telement.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('addW', 'Set white'); // Add white button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0, 1)); // White stone\n\t\telement.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('addE', 'Set empty'); // Add empty button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0)); // Grey stone\n\t\telement.appendChild(besogo.svgCross(0, 0, besogo.RED)); // Red cross\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('circle', 'Circle'); // Circle markup button\n\t\tsvg.appendChild(besogo.svgCircle(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('square', 'Square'); // Square markup button\n\t\tsvg.appendChild(besogo.svgSquare(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('triangle', 'Triangle'); // Triangle markup button\n\t\tsvg.appendChild(besogo.svgTriangle(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('cross', 'Cross'); // Cross markup button\n\t\tsvg.appendChild(besogo.svgCross(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('block', 'Block'); // Block markup button\n\t\tsvg.appendChild(besogo.svgBlock(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('clrMark', 'Clear mark'); // Clear markup button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgTriangle(0, 0, besogo.GREY));\n\t\telement.appendChild(besogo.svgCross(0, 0, besogo.RED));\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('label', 'Label'); // Label markup button\n\t\tsvg.appendChild(besogo.svgLabel(0, 0, 'black', 'A1'));\n\n\t\tlabelText = document.createElement(\"input\"); // Label entry text field\n\t\tlabelText.type = \"text\";\n\t\tlabelText.title = 'Next label';\n\t\tlabelText.onblur = function() {\n\t\t\teditor.setLabel(labelText.value);\n\t\t};\n\t\tlabelText.addEventListener('keydown', function(evt) {\n\t\t\tevt = evt || window.event;\n\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t});\n\t\tcontainer.appendChild(labelText);\n\n\t\tpassButton.type = 'button';\n\t\tpassButton.value = 'Pass';\n\t\tpassButton.title = 'Pass move';\n\t\tpassButton.onclick = function() {\n\t\t\tvar tool = editor.getTool();\n\t\t\tif (tool !== 'navOnly' && tool !== 'auto' && tool !== 'playB' && tool !== 'playW') {\n\t\t\t\teditor.setTool('auto'); // Ensures that a move tool is selected\n\t\t\t}\n\t\t\teditor.click(0, 0, false); // Clicking off the board signals a pass\n\t\t};\n\t\tcontainer.appendChild(passButton);\n\n\t\tcutButton.type = 'button';\n\t\tcutButton.value = 'Cut';\n\t\tcutButton.title = 'Remove branch';\n\t\tcutButton.onclick = function() {\n\t\t\teditor.cutCurrent();\n\t\t};\n\t\tcontainer.appendChild(cutButton);\n\n\t\teditor.addListener(toolStateUpdate); // Set up listener for tool state updates\n\t\ttoolStateUpdate({\n\t\t\tlabel: editor.getLabel(),\n\t\t\ttool: editor.getTool()\n\t\t}); // Initialize\n\n\n\t\t// Creates a button holding an SVG image\n\t\tfunction makeButtonSVG(tool, tooltip) {\n\t\t\tvar button = document.createElement('button'),\n\t\t\t\tsvg = besogo.svgEl('svg', { // Icon container\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\theight: '100%',\n\t\t\t\t\tviewBox: '-55 -55 110 110'\n\t\t\t\t}), // Centered on (0, 0)\n\t\t\t\tselected = besogo.svgEl(\"rect\", { // Selection rectangle\n\t\t\t\t\tx: -50, // Center on (0, 0)\n\t\t\t\t\ty: -50,\n\t\t\t\t\twidth: 100,\n\t\t\t\t\theight: 100,\n\t\t\t\t\tfill: 'none',\n\t\t\t\t\t'stroke-width': 8,\n\t\t\t\t\tstroke: besogo.GOLD,\n\t\t\t\t\trx: 20, // Rounded rectangle\n\t\t\t\t\try: 20, // Thanks, Steve\n\t\t\t\t\tvisibility: 'hidden'\n\t\t\t\t});\n\n\t\t\tcontainer.appendChild(button);\n\t\t\tbutton.appendChild(svg);\n\t\t\tbutton.onclick = function() {\n\t\t\t\teditor.setTool(tool);\n\t\t\t};\n\t\t\tbutton.title = tooltip;\n\t\t\tselectors[tool] = selected;\n\t\t\tsvg.appendChild(selected);\n\t\t\treturn svg; // Returns reference to the icon container\n\t\t}\n\n\t\t// Callback for updating tool state and label\n\t\tfunction toolStateUpdate(msg) {\n\t\t\tvar tool;\n\t\t\tif (msg.label) {\n\t\t\t\tlabelText.value = msg.label;\n\t\t\t}\n\t\t\tif (msg.tool) {\n\t\t\t\tfor (tool in selectors) { // Update which tool is selected\n\t\t\t\t\tif (selectors.hasOwnProperty(tool)) {\n\t\t\t\t\t\tif (msg.tool === tool) {\n\t\t\t\t\t\t\tselectors[tool].setAttribute('visibility', 'visible');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselectors[tool].setAttribute('visibility', 'hidden');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draws a yin yang\n\t\tfunction makeYinYang(x, y) {\n\t\t\tvar element = besogo.svgEl('g');\n\n\t\t\t// Draw black half circle on right side\n\t\t\telement.appendChild(besogo.svgEl(\"path\", {\n\t\t\t\td: \"m\" + x + \",\" + (y - 44) + \" a44 44 0 0 1 0,88z\",\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"black\"\n\t\t\t}));\n\n\t\t\t// Draw white part of ying yang on left side\n\t\t\telement.appendChild(besogo.svgEl(\"path\", {\n\t\t\t\td: \"m\" + x + \",\" + (y + 44) + \"a44 44 0 0 1 0,-88a22 22 0 0 1 0,44z\",\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"white\"\n\t\t\t}));\n\n\t\t\t// Draw round part of black half of ying yang\n\t\t\telement.appendChild(besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y + 22,\n\t\t\t\tr: 22,\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"black\"\n\t\t\t}));\n\n\t\t\treturn element;\n\t\t}\n\t};\n\tbesogo.makeTreePanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar svg,\n\t\t\tpathGroup,\n\t\t\tbottomLayer,\n\t\t\tcurrentMarker,\n\t\t\tSCALE = 0.25; // Tree size scaling factor\n\n\t\trebuildNavTree();\n\t\teditor.addListener(treeUpdate);\n\n\n\t\t// Callback for handling tree changes\n\t\tfunction treeUpdate(msg) {\n\t\t\tif (msg.treeChange) { // Tree structure changed\n\t\t\t\trebuildNavTree(); // Rebuild entire tree\n\t\t\t} else if (msg.navChange) { // Only navigation changed\n\t\t\t\tupdateCurrentMarker(); // Update current location marker\n\t\t\t} else if (msg.stoneChange) { // Only stones in current changed\n\t\t\t\tupdateCurrentNodeIcon();\n\t\t\t}\n\t\t}\n\n\t\t// Updates the current marker in the tree\n\t\tfunction updateCurrentMarker() {\n\t\t\tvar current = editor.getCurrent();\n\n\t\t\tsetSelectionMarker(currentMarker);\n\t\t\tsetCurrentMarker(current.navTreeMarker);\n\t\t}\n\n\t\t// Sets marker element to indicate the current node\n\t\tfunction setCurrentMarker(marker) {\n\t\t\tvar width = container.clientWidth,\n\t\t\t\theight = container.clientHeight,\n\t\t\t\ttop = container.scrollTop,\n\t\t\t\tleft = container.scrollLeft,\n\t\t\t\tmarkX = (marker.getAttribute('x') - 5) * SCALE, // Computed position of marker\n\t\t\t\tmarkY = (marker.getAttribute('y') - 5) * SCALE,\n\t\t\t\tGRIDSIZE = 120 * SCALE; // Size of the square grid\n\n\t\t\tif (markX < left) { // Ensure horizontal visibility of current marker\n\t\t\t\tcontainer.scrollLeft = markX;\n\t\t\t} else if (markX + GRIDSIZE > left + width) {\n\t\t\t\tcontainer.scrollLeft = markX + GRIDSIZE - width;\n\t\t\t}\n\t\t\tif (markY < top) { // Ensure vertical visibility of current marker\n\t\t\t\tcontainer.scrollTop = markY;\n\t\t\t} else if (markY + GRIDSIZE > top + height) {\n\t\t\t\tcontainer.scrollTop = markY + GRIDSIZE - height;\n\t\t\t}\n\n\t\t\tmarker.setAttribute('opacity', 1); // Always visible\n\t\t\tmarker.onmouseover = null; // Clear hover over action\n\t\t\tmarker.onmouseout = null; // Clear hover off action\n\t\t\tbottomLayer.appendChild(marker); // Moves marker to the background\n\t\t\tcurrentMarker = marker;\n\t\t}\n\n\t\t// Sets marker\n\t\tfunction setSelectionMarker(marker) {\n\t\t\tmarker.setAttribute('opacity', 0); // Normally invisible\n\t\t\tmarker.onmouseover = function() { // Show on hover over\n\t\t\t\tmarker.setAttribute('opacity', 0.5);\n\t\t\t};\n\t\t\tmarker.onmouseout = function() { // Hide on hover off\n\t\t\t\tmarker.setAttribute('opacity', 0);\n\t\t\t};\n\t\t\tsvg.appendChild(marker); // Move marker to foreground\n\t\t}\n\n\t\t// Rebuilds the entire navigation tree\n\t\tfunction rebuildNavTree() {\n\t\t\tvar current = editor.getCurrent(), // Current location in game state tree\n\t\t\t\troot = editor.getRoot(), // Root node of game state\n\t\t\t\tnextOpen = [], // Tracks occupied grid positions\n\t\t\t\toldSvg = svg, // Store the old SVG root\n\t\t\t\tbackground = besogo.svgEl(\"rect\", { // Background color for tree\n\t\t\t\t\theight: '100%',\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t\t}),\n\t\t\t\tpath, // Root path\n\t\t\t\twidth, // Calculated dimensions of the SVG\n\t\t\t\theight;\n\n\t\t\tsvg = besogo.svgEl(\"svg\");\n\t\t\tbottomLayer = besogo.svgEl(\"g\"); // Holder for the current marker\n\t\t\tpathGroup = besogo.svgEl(\"g\"); // Holder for path elements\n\n\t\t\tsvg.appendChild(background); // Background color first\n\t\t\tsvg.appendChild(bottomLayer); // Bottom layer (for current marker) second\n\t\t\tsvg.appendChild(pathGroup); // Navigation path third\n\n\t\t\tpath = recursiveTreeBuild(root, 0, 0, nextOpen); // Build the tree\n\t\t\tpathGroup.appendChild(finishPath(path, 'black')); // Finish and add root path\n\n\t\t\twidth = 120 * nextOpen.length; // Compute height and width of nav tree\n\t\t\theight = 120 * Math.max.apply(Math, nextOpen);\n\t\t\tsvg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);\n\t\t\tsvg.setAttribute('height', height * SCALE); // Scale down the actual SVG size\n\t\t\tsvg.setAttribute('width', width * SCALE);\n\n\t\t\tif (oldSvg) { // Replace SVG in container\n\t\t\t\tcontainer.replaceChild(svg, oldSvg);\n\t\t\t} else { // SVG not yet added to container\n\t\t\t\tcontainer.appendChild(svg);\n\t\t\t}\n\n\t\t\tsetCurrentMarker(current.navTreeMarker); // Set current marker and ensure visible\n\t\t} // END function rebuildNavTree\n\n\t\t// Recursively builds the tree\n\t\tfunction recursiveTreeBuild(node, x, y, nextOpen) {\n\t\t\tvar children = node.children,\n\t\t\t\tposition,\n\t\t\t\tpath,\n\t\t\t\tchildPath,\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (children.length === 0) { // Reached end of branch\n\t\t\t\tpath = 'm' + svgPos(x) + ',' + svgPos(y); // Start path at end of branch\n\t\t\t} else { // Current node has children\n\t\t\t\tposition = (nextOpen[x + 1] || 0); // First open spot in next column\n\t\t\t\tposition = (position < y) ? y : position; // Bring level with current y\n\n\t\t\t\tif (y < position - 1) { // Check if first child natural drop > 1\n\t\t\t\t\ty = position - 1; // Bring current y within 1 of first child drop\n\t\t\t\t}\n\t\t\t\t// Place first child and extend path\n\t\t\t\tpath = recursiveTreeBuild(children[0], x + 1, position, nextOpen) +\n\t\t\t\t\textendPath(x, y, nextOpen);\n\n\t\t\t\t// Place other children (intentionally starting at i = 1)\n\t\t\t\tfor (i = 1; i < children.length; i++) {\n\t\t\t\t\tposition = nextOpen[x + 1];\n\t\t\t\t\tchildPath = recursiveTreeBuild(children[i], x + 1, position, nextOpen) +\n\t\t\t\t\t\textendPath(x, y, nextOpen, position - 1);\n\t\t\t\t\t// End path at beginning of branch\n\t\t\t\t\tpathGroup.appendChild(finishPath(childPath, 'black'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvg.appendChild(makeNodeIcon(node, x, y));\n\t\t\taddSelectionMarker(node, x, y);\n\n\t\t\tnextOpen[x] = y + 1; // Claims (x, y)\n\t\t\treturn path;\n\t\t} // END function recursiveTreeBuild\n\n\t\tfunction makeNodeIcon(node, x, y) { // Makes a node icon for the tree\n\t\t\tvar element,\n\t\t\t\tcolor;\n\n\t\t\tswitch (node.getType()) {\n\t\t\t\tcase 'move': // Move node\n\t\t\t\t\tcolor = node.move.color;\n\t\t\t\t\telement = besogo.svgEl(\"g\");\n\t\t\t\t\telement.appendChild(besogo.svgStone(svgPos(x), svgPos(y), color));\n\t\t\t\t\tcolor = (color === -1) ? \"white\" : \"black\";\n\t\t\t\t\telement.appendChild(besogo.svgLabel(svgPos(x), svgPos(y), color,\n\t\t\t\t\t\t'' + node.moveNumber));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'setup': // Setup node\n\t\t\t\t\telement = besogo.svgEl(\"g\");\n\t\t\t\t\telement.appendChild(besogo.svgStone(svgPos(x), svgPos(y))); // Grey stone\n\t\t\t\t\telement.appendChild(besogo.svgPlus(svgPos(x), svgPos(y), besogo.RED));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: // Empty node\n\t\t\t\t\telement = besogo.svgStone(svgPos(x), svgPos(y)); // Grey stone\n\t\t\t}\n\t\t\tnode.navTreeIcon = element; // Save icon reference in game state tree\n\t\t\tnode.navTreeX = x; // Save position of the icon\n\t\t\tnode.navTreeY = y;\n\n\t\t\treturn element;\n\t\t} // END function makeNodeIcon\n\n\t\tfunction updateCurrentNodeIcon() { // Updates the current node icon\n\t\t\tvar current = editor.getCurrent(), // Current location in game state tree\n\t\t\t\toldIcon = current.navTreeIcon,\n\t\t\t\tnewIcon = makeNodeIcon(current, current.navTreeX, current.navTreeY);\n\t\t\tsvg.replaceChild(newIcon, oldIcon);\n\t\t}\n\n\t\tfunction addSelectionMarker(node, x, y) {\n\t\t\tvar element = besogo.svgEl(\"rect\", { // Create selection marker\n\t\t\t\tx: svgPos(x) - 55,\n\t\t\t\ty: svgPos(y) - 55,\n\t\t\t\twidth: 110,\n\t\t\t\theight: 110,\n\t\t\t\tfill: besogo.TURQ\n\t\t\t});\n\t\t\telement.onclick = function() {\n\t\t\t\teditor.setCurrent(node);\n\t\t\t};\n\n\t\t\tnode.navTreeMarker = element; // Save selection marker in node\n\t\t\tsetSelectionMarker(element); // Add as and set selection marker properties\n\t\t}\n\n\t\tfunction extendPath(x, y, nextOpen, prevChildPos) { // Extends path from child to current\n\t\t\tvar childPos = nextOpen[x + 1] - 1; // Position of child\n\t\t\tif (childPos === y) { // Child is horizontally level with current\n\t\t\t\treturn 'h-120'; // Horizontal line back to current\n\t\t\t} else if (childPos === y + 1) { // Child is one drop from current\n\t\t\t\treturn 'l-120,-120'; // Diagonal drop line back to current\n\t\t\t} else if (prevChildPos && prevChildPos !== y) {\n\t\t\t\t// Previous is already dropped, extend back to previous child drop line\n\t\t\t\treturn 'l-60,-60v-' + (120 * (childPos - prevChildPos));\n\t\t\t} else { // Extend double-bend drop line back to parent\n\t\t\t\treturn 'l-60,-60v-' + (120 * (childPos - y - 1)) + 'l-60,-60';\n\t\t\t}\n\t\t}\n\n\t\tfunction finishPath(path, color) { // Finishes path element\n\t\t\tvar element = besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction svgPos(x) { // Converts (x, y) coordinates to SVG position\n\t\t\treturn (x * 120) + 60;\n\t\t}\n\t};\n\n\tbesogo.autoInit();\n\tif (Persistence.isAvailable()) {\n\terrorCheck = Persistence.getItem(\"errorCheck\");\n\tif (errorCheck == true) {\n\t\tdocument.getElementsByClassName(\"besogo-board\")[0].style.border = \"5px solid indianred\";\n\t} else {\n\t\tdocument.getElementsByClassName(\"besogo-board\")[0].style.border = \"5px solid limegreen\";\n\t}\n\tPersistence.clear();\n\t}\n</script>",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "<script>\n// v1.0.0 - https://github.com/SimonLammer/anki-persistence/blob/cd2ca88e019dc3b8f32dad623932c1eabdba7e21/script.js\nif(void 0===window.Persistence){var _persistenceKey=\"github.com/SimonLammer/anki-persistence/\",_defaultKey=\"_default\";if(window.Persistence_sessionStorage=function(){var e=!1;try{\"object\"==typeof window.sessionStorage&&(e=!0,this.clear=function(){for(var e=0;e<sessionStorage.length;e++){var t=sessionStorage.key(e);0==t.indexOf(_persistenceKey)&&(sessionStorage.removeItem(t),e--)}},this.setItem=function(e,t){null==t&&(t=e,e=_defaultKey),sessionStorage.setItem(_persistenceKey+e,JSON.stringify(t))},this.getItem=function(e){return null==e&&(e=_defaultKey),JSON.parse(sessionStorage.getItem(_persistenceKey+e))},this.removeItem=function(e){null==e&&(e=_defaultKey),sessionStorage.removeItem(_persistenceKey+e)})}catch(e){}this.isAvailable=function(){return e}},window.Persistence_windowKey=function(e){var t=window[e],n=!1;\"object\"==typeof t&&(n=!0,this.clear=function(){t[_persistenceKey]={}},this.setItem=function(e,n){null==n&&(n=e,e=_defaultKey),t[_persistenceKey][e]=n},this.getItem=function(e){return null==e&&(e=_defaultKey),null==t[_persistenceKey][e]?null:t[_persistenceKey][e]},this.removeItem=function(e){null==e&&(e=_defaultKey),delete t[_persistenceKey][e]},null==t[_persistenceKey]&&this.clear()),this.isAvailable=function(){return n}},window.Persistence=new Persistence_sessionStorage,Persistence.isAvailable()||(window.Persistence=new Persistence_windowKey(\"py\")),!Persistence.isAvailable()){var titleStartIndex=window.location.toString().indexOf(\"title\"),titleContentIndex=window.location.toString().indexOf(\"main\",titleStartIndex);titleStartIndex>0&&titleContentIndex>0&&titleContentIndex-titleStartIndex<10&&(window.Persistence=new Persistence_windowKey(\"qt\"))}}\n</script>\n\n<div id=frontGo class=\"besogo-diagram\" nokeys=1 nowheel=1 maxwidth=700 realstones=1 transwidth=0>{{text:SGF}}</div>\n\n<script>\n\tvar errorCheck;\n\tvar goScrollVariationHandler = function(event) {\n\t\tif (!document.body.contains(document.getElementById('frontGo'))) {} else if (event.originalEvent.wheelDelta >= 0) {\n\t\t\tdocument.querySelector('[title=\"Previous sibling\"]').click();\n\t\t} else {\n\t\t\tdocument.querySelector('[title=\"Next sibling\"]').click();\n\t\t}\n\t}\n\t$(\".besogo-diagram\").bind('mousewheel', goScrollVariationHandler);\n\n\n\n\n\tif (!document.body.contains(document.getElementById('frontGo'))) {} else {\n\t\tvar nextMoveHandler = function(e) {\n\t\t\tif (!document.body.contains(document.getElementById('frontGo'))) {} else {\n\t\t\t\te.preventDefault();\n\t\t\t\tdocument.querySelector('[title=\"Next node\"]').click();\n\t\t\t}\n\t\t}\n\t\t$(\"#frontGo\").bind('contextmenu', nextMoveHandler);\n\t}\n\n\tvar playerColor = \"white\";\n\n\tif (`{{text:SGF}}`.indexOf(';W[') < `{{text:SGF}}`.indexOf(';B[') && `{{text:SGF}}`.indexOf(';W[') !== -1) {\n\t\tplayerColor = \"black\";\n\t}\n\tdocument.getElementById(\"frontGo\").style.background = playerColor;\n\t(function() {\n\t\t'use strict';\n\t\tvar besogo = window.besogo = window.besogo || {}; // Establish our namespace\n\t\tbesogo.VERSION = '0.0.2-alpha';\n\n\t\tbesogo.create = function(container, options) {\n\t\t\tvar editor, // Core editor object\n\t\t\t\tresizer, // Auto-resizing function\n\t\t\t\tboardDiv, // Board display container\n\t\t\t\tpanelsDiv, // Parent container of panel divs\n\t\t\t\tmakers = { // Map to panel creators\n\t\t\t\t\tcontrol: besogo.makeControlPanel,\n\t\t\t\t\tnames: besogo.makeNamesPanel,\n\t\t\t\t\tcomment: besogo.makeCommentPanel,\n\t\t\t\t\ttool: besogo.makeToolPanel,\n\t\t\t\t\ttree: besogo.makeTreePanel,\n\t\t\t\t\tfile: besogo.makeFilePanel\n\t\t\t\t},\n\t\t\t\tinsideText = container.textContent || container.innerText || '',\n\t\t\t\ti, panelName; // Scratch iteration variables\n\n\t\t\tcontainer.className += ' besogo-container'; // Marks this div as initialized\n\n\t\t\t// Process options and set defaults\n\t\t\toptions = options || {}; // Makes option checking simpler\n\t\t\toptions.size = besogo.parseSize(options.size || 19);\n\t\t\toptions.coord = options.coord || 'none';\n\t\t\toptions.tool = options.tool || 'auto';\n\t\t\tif (options.panels === '') {\n\t\t\t\toptions.panels = [];\n\t\t\t}\n\t\t\toptions.panels = options.panels || 'control+names+comment+tool+tree+file';\n\t\t\tif (typeof options.panels === 'string') {\n\t\t\t\toptions.panels = options.panels.split('+');\n\t\t\t}\n\t\t\toptions.path = options.path || '';\n\t\t\tif (options.shadows === undefined) {\n\t\t\t\toptions.shadows = 'auto';\n\t\t\t} else if (options.shadows === 'off') {\n\t\t\t\toptions.shadows = false;\n\t\t\t}\n\n\t\t\t// Make the core editor object\n\t\t\teditor = besogo.makeEditor(options.size.x, options.size.y);\n\t\t\teditor.setTool(options.tool);\n\t\t\teditor.setCoordStyle(options.coord);\n\t\t\tif (options.realstones) { // Using realistic stones\n\t\t\t\teditor.REAL_STONES = true;\n\t\t\t\teditor.SHADOWS = options.shadows;\n\t\t\t} else { // SVG stones\n\t\t\t\teditor.SHADOWS = (options.shadows && options.shadows !== 'auto');\n\t\t\t}\n\n\t\t\tif (!options.nokeys) { // Add keypress handler unless nokeys option is truthy\n\t\t\t\taddKeypressHandler(container, editor);\n\t\t\t}\n\n\t\t\tif (options.sgf) { // Load SGF file from URL\n\t\t\t\ttry {\n\t\t\t\t\tfetchParseLoad(options.sgf, editor, options.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Silently fail on network error\n\t\t\t\t}\n\t\t\t} else if (insideText.match(/\\s*\\(\\s*;/)) { // Text content looks like an SGF file\n\t\t\t\tparseAndLoad(insideText, editor);\n\t\t\t\tnavigatePath(editor, options.path); // Navigate editor along path\n\t\t\t}\n\n\t\t\tif (typeof options.variants === 'number' || typeof options.variants === 'string') {\n\t\t\t\teditor.setVariantStyle(+options.variants); // Converts to number\n\t\t\t}\n\n\t\t\twhile (container.firstChild) { // Remove all children of container\n\t\t\t\tcontainer.removeChild(container.firstChild);\n\t\t\t}\n\n\t\t\tboardDiv = makeDiv('besogo-board'); // Create div for board display\n\t\t\tbesogo.makeBoardDisplay(boardDiv, editor); // Create board display\n\n\t\t\tif (!options.nowheel) { // Add mousewheel handler unless nowheel option is truthy\n\t\t\t\taddWheelHandler(boardDiv, editor);\n\t\t\t}\n\n\t\t\tif (options.panels.length > 0) { // Only create if there are panels to add\n\t\t\t\tpanelsDiv = makeDiv('besogo-panels');\n\t\t\t\tfor (i = 0; i < options.panels.length; i++) {\n\t\t\t\t\tpanelName = options.panels[i];\n\t\t\t\t\tif (makers[panelName]) { // Only add if creator function exists\n\t\t\t\t\t\tmakers[panelName](makeDiv('besogo-' + panelName, panelsDiv), editor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!panelsDiv.firstChild) { // If no panels were added\n\t\t\t\t\tcontainer.removeChild(panelsDiv); // Remove the panels div\n\t\t\t\t\tpanelsDiv = false; // Flags panels div as removed\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.resize = options.resize || 'auto';\n\t\t\tif (options.resize === 'auto') { // Add auto-resizing unless resize option is truthy\n\t\t\t\tresizer = function() {\n\t\t\t\t\tvar windowHeight = window.innerHeight, // Viewport height\n\t\t\t\t\t\t// Calculated width of parent element\n\t\t\t\t\t\tparentWidth = parseFloat(getComputedStyle(container).width),\n\t\t\t\t\t\tmaxWidth = +(options.maxwidth || -1),\n\t\t\t\t\t\torientation = options.orient || 'auto',\n\n\t\t\t\t\t\tportraitRatio = +(options.portratio || 200) / 100,\n\t\t\t\t\t\tlandscapeRatio = +(options.landratio || 200) / 100,\n\t\t\t\t\t\tminPanelsWidth = +(options.minpanelswidth || 350),\n\t\t\t\t\t\tminPanelsHeight = +(options.minpanelsheight || 400),\n\t\t\t\t\t\tminLandscapeWidth = +(options.transwidth || 600),\n\n\t\t\t\t\t\t// Initial width parent\n\t\t\t\t\t\twidth = (maxWidth > 0 && maxWidth < parentWidth) ? maxWidth : parentWidth,\n\t\t\t\t\t\theight; // Initial height is undefined\n\n\t\t\t\t\t// Determine orientation if 'auto' or 'view'\n\t\t\t\t\tif (orientation !== 'portrait' && orientation !== 'landscape') {\n\t\t\t\t\t\tif (width < minLandscapeWidth || (orientation === 'view' && width < windowHeight)) {\n\t\t\t\t\t\t\torientation = 'portrait';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\torientation = 'landscape';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (orientation === 'portrait') { // Portrait mode\n\t\t\t\t\t\tif (!isNaN(portraitRatio)) {\n\t\t\t\t\t\t\theight = portraitRatio * width;\n\t\t\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\t\t\theight = (height - width < minPanelsHeight) ? width + minPanelsHeight : height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // Otherwise, leave height undefined\n\t\t\t\t\t} else if (orientation === 'landscape') { // Landscape mode\n\t\t\t\t\t\tif (!panelsDiv) { // No panels div\n\t\t\t\t\t\t\theight = width; // Square overall\n\t\t\t\t\t\t} else if (isNaN(landscapeRatio)) {\n\t\t\t\t\t\t\theight = windowHeight;\n\t\t\t\t\t\t} else { // Otherwise use ratio\n\t\t\t\t\t\t\theight = width / landscapeRatio;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\t\t// Reduce height to ensure minimum width of panels div\n\t\t\t\t\t\t\theight = width;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsetDimensions(width, height);\n\t\t\t\t\tcontainer.style.width = width + 'px';\n\t\t\t\t};\n\t\t\t\twindow.addEventListener(\"resize\", resizer);\n\t\t\t\tresizer(); // Initial div sizing\n\t\t\t} else if (options.resize === 'fixed') {\n\t\t\t\tsetDimensions(container.clientWidth, container.clientHeight);\n\t\t\t}\n\n\t\t\t// Sets dimensions with optional height param\n\t\t\tfunction setDimensions(width, height) {\n\t\t\t\tif (height && width > height) { // Landscape mode\n\t\t\t\t\tcontainer.style['flex-direction'] = 'row';\n\t\t\t\t\tboardDiv.style.height = height + 'px';\n\t\t\t\t\tboardDiv.style.width = height + 'px';\n\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\tpanelsDiv.style.height = height + 'px';\n\t\t\t\t\t\tpanelsDiv.style.width = (width - height) + 'px';\n\t\t\t\t\t}\n\t\t\t\t} else { // Portrait mode (implied if height is missing)\n\t\t\t\t\tcontainer.style['flex-direction'] = 'column';\n\t\t\t\t\tboardDiv.style.height = width + 'px';\n\t\t\t\t\tboardDiv.style.width = width + 'px';\n\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\tif (height) { // Only set height if param present\n\t\t\t\t\t\t\tpanelsDiv.style.height = (height - width) + 'px';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpanelsDiv.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Creates and adds divs to specified parent or container\n\t\t\tfunction makeDiv(className, parent) {\n\t\t\t\tvar div = document.createElement(\"div\");\n\t\t\t\tif (className) {\n\t\t\t\t\tdiv.className = className;\n\t\t\t\t}\n\t\t\t\tparent = parent || container;\n\t\t\t\tparent.appendChild(div);\n\t\t\t\treturn div;\n\t\t\t}\n\t\t}; // END function besogo.create\n\n\t\t// Parses size parameter from SGF format\n\t\tbesogo.parseSize = function(input) {\n\t\t\tvar matches,\n\t\t\t\tsizeX,\n\t\t\t\tsizeY;\n\n\t\t\tinput = (input + '').replace(/\\s/g, ''); // Convert to string and remove whitespace\n\n\t\t\tmatches = input.match(/^(\\d+):(\\d+)$/); // Check for #:# pattern\n\t\t\tif (matches) { // Composed value pattern found\n\t\t\t\tsizeX = +matches[1]; // Convert to numbers\n\t\t\t\tsizeY = +matches[2];\n\t\t\t} else if (input.match(/^\\d+$/)) { // Check for # pattern\n\t\t\t\tsizeX = +input; // Convert to numbers\n\t\t\t\tsizeY = +input; // Implied square\n\t\t\t} else { // Invalid input format\n\t\t\t\tsizeX = sizeY = 19; // Default size value\n\t\t\t}\n\t\t\tif (sizeX > 52 || sizeX < 1 || sizeY > 52 || sizeY < 1) {\n\t\t\t\tsizeX = sizeY = 19; // Out of range, set to default\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: sizeX,\n\t\t\t\ty: sizeY\n\t\t\t};\n\t\t};\n\n\t\t// Automatically converts document elements into besogo instances\n\t\tbesogo.autoInit = function() {\n\t\t\tvar allDivs = document.getElementsByTagName('div'), // Live collection of divs\n\t\t\t\ttargetDivs = [], // List of divs to auto-initialize\n\t\t\t\toptions, // Structure to hold options\n\t\t\t\ti, j, attrs; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < allDivs.length; i++) { // Iterate over all divs\n\t\t\t\tif ((hasClass(allDivs[i], 'besogo-editor') || // Has an auto-init class\n\t\t\t\t\t\thasClass(allDivs[i], 'besogo-viewer') ||\n\t\t\t\t\t\thasClass(allDivs[i], 'besogo-diagram')) &&\n\t\t\t\t\t!hasClass(allDivs[i], 'besogo-container')) { // Not already initialized\n\t\t\t\t\ttargetDivs.push(allDivs[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targetDivs.length; i++) { // Iterate over target divs\n\t\t\t\toptions = {}; // Clear the options struct\n\t\t\t\tif (hasClass(targetDivs[i], 'besogo-editor')) {\n\t\t\t\t\toptions.panels = ['control', 'names', 'comment', 'tool', 'tree', 'file'];\n\t\t\t\t\toptions.tool = 'auto';\n\t\t\t\t} else if (hasClass(targetDivs[i], 'besogo-viewer')) {\n\t\t\t\t\toptions.panels = ['control', 'names', 'comment'];\n\t\t\t\t\toptions.tool = 'navOnly';\n\t\t\t\t} else if (hasClass(targetDivs[i], 'besogo-diagram')) {\n\t\t\t\t\toptions.panels = ['control'];\n\t\t\t\t\toptions.tool = 'navOnly';\n\t\t\t\t}\n\n\t\t\t\tattrs = targetDivs[i].attributes;\n\t\t\t\tfor (j = 0; j < attrs.length; j++) { // Load attributes as options\n\t\t\t\t\toptions[attrs[j].name] = attrs[j].value;\n\t\t\t\t}\n\t\t\t\tbesogo.create(targetDivs[i], options);\n\t\t\t}\n\n\t\t\tfunction hasClass(element, str) {\n\t\t\t\treturn (element.className.split(' ').indexOf(str) !== -1);\n\t\t\t}\n\t\t};\n\n\t\t// Sets up keypress handling\n\t\tfunction addKeypressHandler(container, editor) {\n\t\t\tif (!container.getAttribute('tabindex')) {\n\t\t\t\tcontainer.setAttribute('tabindex', '0'); // Set tabindex to allow div focusing\n\t\t\t}\n\n\t\t\tcontainer.addEventListener('keydown', function(evt) {\n\t\t\t\tevt = evt || window.event;\n\t\t\t\tswitch (evt.keyCode) {\n\t\t\t\t\tcase 33: // page up\n\t\t\t\t\t\teditor.prevNode(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 34: // page down\n\t\t\t\t\t\teditor.nextNode(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 35: // end\n\t\t\t\t\t\teditor.nextNode(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 36: // home\n\t\t\t\t\t\teditor.prevNode(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 37: // left\n\t\t\t\t\t\teditor.prevNode(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 38: // up\n\t\t\t\t\t\teditor.nextSibling(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 39: // right\n\t\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 40: // down\n\t\t\t\t\t\teditor.nextSibling(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 46: // delete\n\t\t\t\t\t\teditor.cutCurrent();\n\t\t\t\t\t\tbreak;\n\t\t\t\t} // END switch (evt.keyCode)\n\t\t\t\tif (evt.keyCode >= 33 && evt.keyCode <= 40) {\n\t\t\t\t\tevt.preventDefault(); // Suppress page nav controls\n\t\t\t\t}\n\t\t\t}); // END func() and addEventListener\n\t\t} // END function addKeypressHandler\n\n\t\t// Sets up mousewheel handling\n\t\tfunction addWheelHandler(boardDiv, editor) {\n\t\t\tboardDiv.addEventListener('wheel', function(evt) {\n\t\t\t\tevt = evt || window.event;\n\t\t\t\tif (evt.deltaY > 0) {\n\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t} else if (evt.deltaY < 0) {\n\t\t\t\t\teditor.prevNode(1);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Parses SGF string and loads into editor\n\t\tfunction parseAndLoad(text, editor) {\n\t\t\tvar sgf;\n\t\t\ttry {\n\t\t\t\tsgf = besogo.parseSgf(text);\n\t\t\t} catch (error) {\n\t\t\t\treturn; // Silently fail on parse error\n\t\t\t}\n\t\t\tbesogo.loadSgf(sgf, editor);\n\t\t}\n\n\t\t// Fetches text file at url from same domain\n\t\tfunction fetchParseLoad(url, editor, path) {\n\t\t\tvar http = new XMLHttpRequest();\n\n\t\t\thttp.onreadystatechange = function() {\n\t\t\t\tif (http.readyState === 4 && http.status === 200) { // Successful fetch\n\t\t\t\t\tparseAndLoad(http.responseText, editor);\n\t\t\t\t\tnavigatePath(editor, path);\n\t\t\t\t}\n\t\t\t};\n\t\t\thttp.overrideMimeType('text/plain'); // Prevents XML parsing and warnings\n\t\t\thttp.open(\"GET\", url, true); // Asynchronous load\n\t\t\thttp.send();\n\t\t}\n\n\t\tfunction navigatePath(editor, path) {\n\t\t\tvar subPaths,\n\t\t\t\ti, j; // Scratch iteration variables\n\n\t\t\tpath = path.split(/[Nn]+/); // Split into parts that start in next mode\n\t\t\tfor (i = 0; i < path.length; i++) {\n\t\t\t\tsubPaths = path[i].split(/[Bb]+/); // Split on switches into branch mode\n\t\t\t\texecuteMoves(subPaths[0], false); // Next mode moves\n\t\t\t\tfor (j = 1; j < subPaths.length; j++) { // Intentionally starting at 1\n\t\t\t\t\texecuteMoves(subPaths[j], true); // Branch mode moves\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction executeMoves(part, branch) {\n\t\t\t\tvar i;\n\t\t\t\tpart = part.split(/\\D+/); // Split on non-digits\n\t\t\t\tfor (i = 0; i < part.length; i++) {\n\t\t\t\t\tif (part[i]) { // Skip empty strings\n\t\t\t\t\t\tif (branch) { // Branch mode\n\t\t\t\t\t\t\tif (editor.getCurrent().children.length) {\n\t\t\t\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\t\t\t\teditor.nextSibling(part[i] - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // Next mode\n\t\t\t\t\t\t\teditor.nextNode(+part[i]); // Converts to number\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t})(); // END closure\n\tbesogo.makeBoardDisplay = function(container, editor) {\n\t\t'use strict';\n\t\tvar CELL_SIZE = 88, // Including line width\n\t\t\tCOORD_MARGIN = 75, // Margin for coordinate labels\n\t\t\tEXTRA_MARGIN = 6, // Extra margin on the edge of board\n\t\t\tBOARD_MARGIN, // Total board margin\n\n\t\t\t// Board size parameters\n\t\t\tsizeX = editor.getCurrent().getSize().x,\n\t\t\tsizeY = editor.getCurrent().getSize().y,\n\n\t\t\tsvg, // Holds the overall board display SVG element\n\t\t\tstoneGroup, // Group for stones\n\t\t\tmarkupGroup, // Group for markup\n\t\t\thoverGroup, // Group for hover layer\n\t\t\tmarkupLayer, // Array of markup layer elements\n\t\t\thoverLayer, // Array of hover layer elements\n\n\t\t\trandIndex, // Random index for stone images\n\n\t\t\tTOUCH_FLAG = false; // Flag for touch interfaces\n\n\t\tinitializeBoard(editor.getCoordStyle()); // Initialize SVG element and draw the board\n\t\tcontainer.appendChild(svg); // Add the SVG element to the document\n\t\teditor.addListener(update); // Register listener to handle editor/game state updates\n\t\tredrawAll(editor.getCurrent()); // Draw stones, markup and hover layer\n\n\t\t// Set listener to detect touch interfaces\n\t\tcontainer.addEventListener('touchstart', setTouchFlag);\n\n\t\t// Function for setting the flag for touch interfaces\n\t\tfunction setTouchFlag() {\n\t\t\tTOUCH_FLAG = true; // Set flag to prevent needless function calls\n\t\t\thoverLayer = []; // Drop hover layer references, kills events\n\t\t\tsvg.removeChild(hoverGroup); // Remove hover group from SVG\n\t\t\t// Remove self when done\n\t\t\tcontainer.removeEventListener('touchstart', setTouchFlag);\n\t\t}\n\n\t\t// Initializes the SVG and draws the board\n\t\tfunction initializeBoard(coord) {\n\t\t\tdrawBoard(coord); // Initialize the SVG element and draw the board\n\n\t\t\tstoneGroup = besogo.svgEl(\"g\");\n\t\t\tmarkupGroup = besogo.svgEl(\"g\");\n\n\t\t\tsvg.appendChild(stoneGroup); // Add placeholder group for stone layer\n\t\t\tsvg.appendChild(markupGroup); // Add placeholder group for markup layer\n\n\t\t\tif (!TOUCH_FLAG) {\n\t\t\t\thoverGroup = besogo.svgEl(\"g\");\n\t\t\t\tsvg.appendChild(hoverGroup);\n\t\t\t}\n\n\t\t\taddEventTargets(); // Add mouse event listener layer\n\n\t\t\tif (editor.REAL_STONES) { // Generate index for realistic stone images\n\t\t\t\trandomizeIndex();\n\t\t\t}\n\t\t}\n\n\t\t// Callback for board display redraws\n\t\tfunction update(msg) {\n\t\t\tvar current = editor.getCurrent(),\n\t\t\t\tcurrentSize = current.getSize(),\n\t\t\t\treinit = false, // Board redraw flag\n\t\t\t\toldSvg = svg;\n\n\t\t\t// Check if board size has changed\n\t\t\tif (currentSize.x !== sizeX || currentSize.y !== sizeY || msg.coord) {\n\t\t\t\tsizeX = currentSize.x;\n\t\t\t\tsizeY = currentSize.y;\n\t\t\t\tinitializeBoard(msg.coord || editor.getCoordStyle()); // Reinitialize board\n\t\t\t\tcontainer.replaceChild(svg, oldSvg);\n\t\t\t\treinit = true; // Flag board redrawn\n\t\t\t}\n\n\t\t\t// Redraw stones only if needed\n\t\t\tif (reinit || msg.navChange || msg.stoneChange) {\n\t\t\t\tredrawStones(current);\n\t\t\t\tredrawMarkup(current);\n\t\t\t\tredrawHover(current);\n\t\t\t} else if (msg.markupChange) {\n\t\t\t\tredrawMarkup(current);\n\t\t\t\tredrawHover(current);\n\t\t\t} else if (msg.tool || msg.label) {\n\t\t\t\tredrawHover(current);\n\t\t\t}\n\t\t}\n\n\t\tfunction redrawAll(current) {\n\t\t\tredrawStones(current);\n\t\t\tredrawMarkup(current);\n\t\t\tredrawHover(current);\n\t\t}\n\n\t\t// Initializes the SVG element and draws the board\n\t\tfunction drawBoard(coord) {\n\t\t\tvar boardWidth,\n\t\t\t\tboardHeight,\n\t\t\t\tstring = \"\", // Path string for inner board lines\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tBOARD_MARGIN = (coord === 'none' ? 0 : COORD_MARGIN) + EXTRA_MARGIN;\n\t\t\tboardWidth = 2 * BOARD_MARGIN + sizeX * CELL_SIZE;\n\t\t\tboardHeight = 2 * BOARD_MARGIN + sizeY * CELL_SIZE;\n\n\t\t\tsvg = besogo.svgEl(\"svg\", { // Initialize the SVG element\n\t\t\t\twidth: \"100%\",\n\t\t\t\theight: \"100%\",\n\t\t\t\tviewBox: \"0 0 \" + boardWidth + \" \" + boardHeight\n\t\t\t});\n\n\t\t\tsvg.appendChild(besogo.svgEl(\"rect\", { // Fill background color\n\t\t\t\twidth: boardWidth,\n\t\t\t\theight: boardHeight,\n\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t}));\n\n\t\t\tsvg.appendChild(besogo.svgEl(\"rect\", { // Draw outer square of board\n\t\t\t\twidth: CELL_SIZE * (sizeX - 1),\n\t\t\t\theight: CELL_SIZE * (sizeY - 1),\n\t\t\t\tx: svgPos(1),\n\t\t\t\ty: svgPos(1),\n\t\t\t\t'class': 'besogo-svg-lines'\n\t\t\t}));\n\n\t\t\tfor (i = 2; i <= (sizeY - 1); i++) { // Horizontal inner lines\n\t\t\t\tstring += \"M\" + svgPos(1) + \",\" + svgPos(i) + \"h\" + CELL_SIZE * (sizeX - 1);\n\t\t\t}\n\t\t\tfor (i = 2; i <= (sizeX - 1); i++) { // Vertical inner lines\n\t\t\t\tstring += \"M\" + svgPos(i) + \",\" + svgPos(1) + \"v\" + CELL_SIZE * (sizeY - 1);\n\t\t\t}\n\t\t\tsvg.appendChild(besogo.svgEl(\"path\", { // Draw inner lines of board\n\t\t\t\td: string,\n\t\t\t\t'class': 'besogo-svg-lines'\n\t\t\t}));\n\n\t\t\tdrawHoshi(); // Draw the hoshi points\n\t\t\tif (coord !== 'none') {\n\t\t\t\tdrawCoords(coord); // Draw the coordinate labels\n\t\t\t}\n\t\t}\n\n\t\t// Draws coordinate labels on the board\n\t\tfunction drawCoords(coord) {\n\t\t\tvar labels = besogo.coord[coord](sizeX, sizeY),\n\t\t\t\tshift = COORD_MARGIN + 10,\n\t\t\t\ti, x, y; // Scratch iteration variable\n\n\t\t\tfor (i = 1; i <= sizeX; i++) { // Draw column coordinate labels\n\t\t\t\tx = svgPos(i);\n\t\t\t\tdrawCoordLabel(x, svgPos(1) - shift, labels.x[i]);\n\t\t\t\tdrawCoordLabel(x, svgPos(sizeY) + shift, labels.x[i]);\n\t\t\t}\n\n\t\t\tfor (i = 1; i <= sizeY; i++) { // Draw row coordinate labels\n\t\t\t\ty = svgPos(i);\n\t\t\t\tdrawCoordLabel(svgPos(1) - shift, y, labels.y[i]);\n\t\t\t\tdrawCoordLabel(svgPos(sizeX) + shift, y, labels.y[i]);\n\t\t\t}\n\n\t\t\tfunction drawCoordLabel(x, y, label) {\n\t\t\t\tvar element = besogo.svgEl(\"text\", {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\tdy: \".65ex\", // Seems to work for vertically centering these fonts\n\t\t\t\t\t\"font-size\": 32,\n\t\t\t\t\t\"text-anchor\": \"middle\", // Horizontal centering\n\t\t\t\t\t\"font-family\": \"Helvetica, Arial, sans-serif\",\n\t\t\t\t\tfill: 'black'\n\t\t\t\t});\n\t\t\t\telement.appendChild(document.createTextNode(label));\n\t\t\t\tsvg.appendChild(element);\n\t\t\t}\n\t\t}\n\n\t\t// Draws hoshi onto the board at procedurally generated locations\n\t\tfunction drawHoshi() {\n\t\t\tvar cx, cy, // Center point calculation\n\t\t\t\tpathStr = \"\"; // Path string for drawing star points\n\n\t\t\tif (sizeX % 2 && sizeY % 2) { // Draw center hoshi if both dimensions are odd\n\t\t\t\tcx = (sizeX - 1) / 2 + 1; // Calculate the center of the board\n\t\t\t\tcy = (sizeY - 1) / 2 + 1;\n\t\t\t\tdrawStar(cx, cy);\n\n\t\t\t\tif (sizeX >= 17 && sizeY >= 17) { // Draw side hoshi if at least 17x17 and odd\n\t\t\t\t\tdrawStar(4, cy);\n\t\t\t\t\tdrawStar(sizeX - 3, cy);\n\t\t\t\t\tdrawStar(cx, 4);\n\t\t\t\t\tdrawStar(cx, sizeY - 3);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sizeX >= 11 && sizeY >= 11) { // Corner hoshi at (4, 4) for larger sizes\n\t\t\t\tdrawStar(4, 4);\n\t\t\t\tdrawStar(4, sizeY - 3);\n\t\t\t\tdrawStar(sizeX - 3, 4);\n\t\t\t\tdrawStar(sizeX - 3, sizeY - 3);\n\t\t\t} else if (sizeX >= 8 && sizeY >= 8) { // Corner hoshi at (3, 3) for medium sizes\n\t\t\t\tdrawStar(3, 3);\n\t\t\t\tdrawStar(3, sizeY - 2);\n\t\t\t\tdrawStar(sizeX - 2, 3);\n\t\t\t\tdrawStar(sizeX - 2, sizeY - 2);\n\t\t\t} // No corner hoshi for smaller sizes\n\n\t\t\tif (pathStr) { // Only need to add if hoshi drawn\n\t\t\t\tsvg.appendChild(besogo.svgEl('path', { // Drawing circles via path points\n\t\t\t\t\td: pathStr, // Hack to allow radius adjustment via stroke-width\n\t\t\t\t\t'stroke-linecap': 'round', // Makes the points round\n\t\t\t\t\t'class': 'besogo-svg-hoshi'\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tfunction drawStar(i, j) { // Extend path string to draw star point\n\t\t\t\tpathStr += \"M\" + svgPos(i) + ',' + svgPos(j) + 'l0,0'; // Draws a point\n\t\t\t}\n\t\t}\n\n\t\t// Remakes the randomized index for stone images\n\t\tfunction randomizeIndex() {\n\t\t\tvar maxIndex = besogo.BLACK_STONES * besogo.WHITE_STONES,\n\t\t\t\ti, j;\n\n\t\t\trandIndex = [];\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\trandIndex[fromXY(i, j)] = Math.floor(Math.random() * maxIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adds a grid of squares to register mouse events\n\t\tfunction addEventTargets() {\n\t\t\tvar element,\n\t\t\t\ti, j;\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\telement = besogo.svgEl(\"rect\", { // Make a transparent event target\n\t\t\t\t\t\tx: svgPos(i) - CELL_SIZE / 2,\n\t\t\t\t\t\ty: svgPos(j) - CELL_SIZE / 2,\n\t\t\t\t\t\twidth: CELL_SIZE,\n\t\t\t\t\t\theight: CELL_SIZE,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t});\n\n\t\t\t\t\t// Add event listeners, using closures to decouple (i, j)\n\t\t\t\t\telement.addEventListener(\"click\", handleClick(i, j));\n\n\t\t\t\t\tif (!TOUCH_FLAG) { // Skip hover listeners for touch interfaces\n\t\t\t\t\t\telement.addEventListener(\"mouseover\", handleOver(i, j));\n\t\t\t\t\t\telement.addEventListener(\"mouseout\", handleOut(i, j));\n\t\t\t\t\t}\n\n\t\t\t\t\tsvg.appendChild(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction handleClick(i, j) { // Returns function for click handling\n\t\t\treturn function(event) {\n\t\t\t\t// Call click handler in editor\n\t\t\t\teditor.click(i, j, event.ctrlKey, event.shiftKey);\n\t\t\t\tif (!TOUCH_FLAG) {\n\t\t\t\t\t(handleOver(i, j))(); // Ensures that any updated tool is visible\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction handleOver(i, j) { // Returns function for mouse over\n\t\t\treturn function() {\n\t\t\t\tvar element = hoverLayer[fromXY(i, j)];\n\t\t\t\tif (element) { // Make tool action visible on hover over\n\t\t\t\t\telement.setAttribute('visibility', 'visible');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction handleOut(i, j) { // Returns function for mouse off\n\t\t\treturn function() {\n\t\t\t\tvar element = hoverLayer[fromXY(i, j)];\n\t\t\t\tif (element) { // Make tool action invisible on hover off\n\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Redraws the stones\n\t\tfunction redrawStones(current) {\n\t\t\tvar group = besogo.svgEl(\"g\"), // New stone layer group\n\t\t\t\tshadowGroup, // Group for shadow layer\n\t\t\t\ti, j, x, y, color; // Scratch iteration variables\n\n\t\t\tif (editor.SHADOWS) { // Add group for shawdows\n\t\t\t\tshadowGroup = besogo.svgShadowGroup();\n\t\t\t\tgroup.appendChild(shadowGroup);\n\t\t\t}\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\tcolor = current.getStone(i, j);\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\n\t\t\t\t\t\tif (editor.REAL_STONES) { // Realistic stone\n\t\t\t\t\t\t\tgroup.appendChild(besogo.realStone(x, y, color, randIndex[fromXY(i, j)]));\n\t\t\t\t\t\t} else { // SVG stone\n\t\t\t\t\t\t\tgroup.appendChild(besogo.svgStone(x, y, color));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (editor.SHADOWS) { // Draw shadows\n\t\t\t\t\t\t\tshadowGroup.appendChild(besogo.svgShadow(x - 2, y - 4));\n\t\t\t\t\t\t\tshadowGroup.appendChild(besogo.svgShadow(x + 2, y + 4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsvg.replaceChild(group, stoneGroup); // Replace the stone group\n\t\t\tstoneGroup = group;\n\t\t}\n\n\t\t// Redraws the markup\n\t\tfunction redrawMarkup(current) {\n\t\t\tvar element, i, j, x, y, // Scratch iteration variables\n\t\t\t\tgroup = besogo.svgEl(\"g\"), // Group holding markup layer elements\n\t\t\t\tlastMove = current.move,\n\t\t\t\tvariants = editor.getVariants(),\n\t\t\t\tmark, // Scratch mark state {0, 1, 2, 3, 4, 5}\n\t\t\t\tstone, // Scratch stone state {0, -1, 1}\n\t\t\t\tcolor; // Scratch color string\n\n\t\t\tmarkupLayer = []; // Clear the references to the old layer\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\tmark = current.getMarkup(i, j);\n\t\t\t\t\tif (mark) {\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\t\t\t\t\t\tstone = current.getStone(i, j);\n\t\t\t\t\t\tcolor = (stone === -1) ? \"white\" : \"black\"; // White on black\n\t\t\t\t\t\tif (lastMove && lastMove.x === i && lastMove.y === j) {\n\t\t\t\t\t\t\t// Mark last move blue or violet if also a variant\n\t\t\t\t\t\t\tcolor = checkVariants(variants, current, i, j) ?\n\t\t\t\t\t\t\t\tbesogo.PURP : besogo.BLUE;\n\t\t\t\t\t\t} else if (checkVariants(variants, current, i, j)) {\n\t\t\t\t\t\t\tcolor = besogo.RED; // Natural variant marks are red\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof mark === 'number') { // Markup is a basic shape\n\t\t\t\t\t\t\tswitch (mark) {\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\telement = besogo.svgCircle(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\telement = besogo.svgSquare(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\telement = besogo.svgTriangle(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\telement = besogo.svgBlock(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // Markup is a label\n\t\t\t\t\t\t\tif (!stone) { // If placing label on empty spot\n\t\t\t\t\t\t\t\telement = makeBacker(x, y);\n\t\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telement = besogo.svgLabel(x, y, color, mark);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\tmarkupLayer[fromXY(i, j)] = element;\n\t\t\t\t\t} // END if (mark)\n\t\t\t\t} // END for j\n\t\t\t} // END for i\n\n\t\t\t// Mark last move with plus if not already marked\n\t\t\tif (lastMove && lastMove.x !== 0 && lastMove.y !== 0) {\n\t\t\t\ti = lastMove.x;\n\t\t\t\tj = lastMove.y;\n\t\t\t\tif (!markupLayer[fromXY(i, j)]) { // Last move not marked\n\t\t\t\t\tcolor = checkVariants(variants, current, i, j) ? besogo.PURP : besogo.BLUE;\n\t\t\t\t\telement = besogo.svgPlus(svgPos(i), svgPos(j), color);\n\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\tmarkupLayer[fromXY(i, j)] = element;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mark variants that have not already been marked above\n\t\t\tmarkRemainingVariants(variants, current, group);\n\n\t\t\tsvg.replaceChild(group, markupGroup); // Replace the markup group\n\t\t\tmarkupGroup = group;\n\t\t} // END function redrawMarkup\n\n\t\tfunction makeBacker(x, y) { // Makes a label markup backer at (x, y)\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: x - CELL_SIZE / 2,\n\t\t\t\ty: y - CELL_SIZE / 2,\n\t\t\t\theight: CELL_SIZE,\n\t\t\t\twidth: CELL_SIZE,\n\t\t\t\topacity: 0.85,\n\t\t\t\tstroke: \"none\",\n\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t});\n\t\t}\n\n\t\t// Checks if (x, y) is in variants\n\t\tfunction checkVariants(variants, current, x, y) {\n\t\t\tvar i, move;\n\t\t\tfor (i = 0; i < variants.length; i++) {\n\t\t\t\tif (variants[i] !== current) { // Skip current (within siblings)\n\t\t\t\t\tmove = variants[i].move;\n\t\t\t\t\tif (move && move.x === x && move.y === y) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Marks variants that have not already been marked\n\t\tfunction markRemainingVariants(variants, current, group) {\n\t\t\tvar element,\n\t\t\t\tmove, // Variant move\n\t\t\t\tlabel, // Variant label\n\t\t\t\tstone, // Stone state\n\t\t\t\ti, x, y; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < variants.length; i++) {\n\t\t\t\tif (variants[i] !== current) { // Skip current (within siblings)\n\t\t\t\t\tmove = variants[i].move;\n\t\t\t\t\t// Check if move, not a pass, and no mark yet\n\t\t\t\t\tif (move && move.x !== 0 && !markupLayer[fromXY(move.x, move.y)]) {\n\t\t\t\t\t\tstone = current.getStone(move.x, move.y);\n\t\t\t\t\t\tx = svgPos(move.x); // Get SVG positions\n\t\t\t\t\t\ty = svgPos(move.y);\n\t\t\t\t\t\tif (!stone) { // If placing label on empty spot\n\t\t\t\t\t\t\telement = makeBacker(x, y);\n\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Label variants with letters A-Z cyclically\n\t\t\t\t\t\tlabel = String.fromCharCode('A'.charCodeAt(0) + (i % 26));\n\t\t\t\t\t\telement = besogo.svgLabel(x, y, besogo.LRED, label);\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\tmarkupLayer[fromXY(move.x, move.y)] = element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function markRemainingVariants\n\n\t\t// Redraws the hover layer\n\t\tfunction redrawHover(current) {\n\t\t\tif (TOUCH_FLAG) {\n\t\t\t\treturn; // Do nothing for touch interfaces\n\t\t\t}\n\n\t\t\tvar element, i, j, x, y, // Scratch iteration variables\n\t\t\t\tgroup = besogo.svgEl(\"g\"), // Group holding hover layer elements\n\t\t\t\ttool = editor.getTool(),\n\t\t\t\tchildren,\n\t\t\t\tstone, // Scratch stone state {0, -1, 1} or move\n\t\t\t\tcolor; // Scratch color string\n\n\t\t\thoverLayer = []; // Clear the references to the old layer\n\t\t\tgroup.setAttribute('opacity', '0.35');\n\n\t\t\tif (tool === 'navOnly') { // Render navOnly hover by iterating over children\n\t\t\t\tchildren = current.children;\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tstone = children[i].move;\n\t\t\t\t\tif (stone && stone.x !== 0) { // Child node is move and not a pass\n\t\t\t\t\t\tx = svgPos(stone.x);\n\t\t\t\t\t\ty = svgPos(stone.y);\n\t\t\t\t\t\telement = besogo.svgStone(x, y, stone.color);\n\t\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t\t\tgroup.appendChild(element);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { // Render hover for other tools by iterating over grid\n\t\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\t\telement = null;\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\t\t\t\t\t\tstone = current.getStone(i, j);\n\t\t\t\t\t\tcolor = (stone === -1) ? \"white\" : \"black\"; // White on black\n\t\t\t\t\t\tswitch (tool) {\n\t\t\t\t\t\t\tcase 'auto':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, current.nextToMove);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'playB':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, -1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'playW':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addB':\n\t\t\t\t\t\t\t\tif (stone === -1) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = besogo.svgEl('g');\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgStone(x, y, -1));\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgPlus(x, y, besogo.RED));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addW':\n\t\t\t\t\t\t\t\tif (stone === 1) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = besogo.svgEl('g');\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgStone(x, y, 1));\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgPlus(x, y, besogo.RED));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addE':\n\t\t\t\t\t\t\t\tif (stone) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'clrMark':\n\t\t\t\t\t\t\t\tbreak; // Nothing\n\t\t\t\t\t\t\tcase 'circle':\n\t\t\t\t\t\t\t\telement = besogo.svgCircle(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'square':\n\t\t\t\t\t\t\t\telement = besogo.svgSquare(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'triangle':\n\t\t\t\t\t\t\t\telement = besogo.svgTriangle(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'cross':\n\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'block':\n\t\t\t\t\t\t\t\telement = besogo.svgBlock(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'label':\n\t\t\t\t\t\t\t\telement = besogo.svgLabel(x, y, color, editor.getLabel());\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // END switch (tool)\n\t\t\t\t\t\tif (element) {\n\t\t\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t\thoverLayer[fromXY(i, j)] = element;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // END for j\n\t\t\t\t} // END for i\n\t\t\t} // END else\n\n\t\t\tsvg.replaceChild(group, hoverGroup); // Replace the hover layer group\n\t\t\thoverGroup = group;\n\t\t} // END function redrawHover\n\n\t\tfunction svgPos(x) { // Converts (x, y) coordinates to SVG position\n\t\t\treturn BOARD_MARGIN + CELL_SIZE / 2 + (x - 1) * CELL_SIZE;\n\t\t}\n\n\t\tfunction fromXY(x, y) { // Converts (x, y) coordinates to linear index\n\t\t\treturn (x - 1) * sizeY + (y - 1);\n\t\t}\n\t};\n\tbesogo.makeCommentPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar infoTexts = {}, // Holds text nodes for game info properties\n\t\t\tgameInfoTable = document.createElement('table'),\n\t\t\tgameInfoEdit = document.createElement('table'),\n\t\t\tcommentBox = document.createElement('div'),\n\t\t\tcommentEdit = document.createElement('textarea'),\n\t\t\tplayerInfoOrder = 'PW WR WT PB BR BT'.split(' '),\n\t\t\tinfoOrder = 'HA KM RU TM OT GN EV PC RO DT RE ON GC AN US SO CP'.split(' '),\n\t\t\tinfoIds = {\n\t\t\t\tPW: 'White Player',\n\t\t\t\tWR: 'White Rank',\n\t\t\t\tWT: 'White Team',\n\t\t\t\tPB: 'Black Player',\n\t\t\t\tBR: 'Black Rank',\n\t\t\t\tBT: 'Black Team',\n\n\t\t\t\tHA: 'Handicap',\n\t\t\t\tKM: 'Komi',\n\t\t\t\tRU: 'Rules',\n\t\t\t\tTM: 'Timing',\n\t\t\t\tOT: 'Overtime',\n\n\t\t\t\tGN: 'Game Name',\n\t\t\t\tEV: 'Event',\n\t\t\t\tPC: 'Place',\n\t\t\t\tRO: 'Round',\n\t\t\t\tDT: 'Date',\n\n\t\t\t\tRE: 'Result',\n\t\t\t\tON: 'Opening',\n\t\t\t\tGC: 'Comments',\n\n\t\t\t\tAN: 'Annotator',\n\t\t\t\tUS: 'Recorder',\n\t\t\t\tSO: 'Source',\n\t\t\t\tCP: 'Copyright'\n\t\t\t};\n\n\t\tcontainer.appendChild(makeInfoButton());\n\t\tcontainer.appendChild(makeInfoEditButton());\n\t\tcontainer.appendChild(makeCommentButton());\n\t\tcontainer.appendChild(gameInfoTable);\n\t\tcontainer.appendChild(gameInfoEdit);\n\t\tinfoTexts.C = document.createTextNode('');\n\t\tcontainer.appendChild(commentBox);\n\t\tcommentBox.appendChild(infoTexts.C);\n\t\tcontainer.appendChild(commentEdit);\n\n\t\tcommentEdit.onblur = function() {\n\t\t\teditor.setComment(commentEdit.value);\n\t\t};\n\t\tcommentEdit.addEventListener('keydown', function(evt) {\n\t\t\tevt = evt || window.event;\n\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t});\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tgameInfo: editor.getGameInfo()\n\t\t});\n\t\tgameInfoEdit.style.display = 'none'; // Hide game info editting table initially\n\n\t\tfunction update(msg) {\n\t\t\tvar temp; // Scratch for strings\n\n\t\t\tif (msg.navChange) {\n\t\t\t\ttemp = editor.getCurrent().comment || '';\n\t\t\t\tupdateText(commentBox, temp, 'C');\n\t\t\t\tif (editor.getCurrent() === editor.getRoot() &&\n\t\t\t\t\tgameInfoTable.firstChild &&\n\t\t\t\t\tgameInfoEdit.style.display === 'none') {\n\t\t\t\t\tgameInfoTable.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tcommentEdit.style.display = 'none';\n\t\t\t\tcommentBox.style.display = 'block';\n\t\t\t} else if (msg.comment !== undefined) {\n\t\t\t\tupdateText(commentBox, msg.comment, 'C');\n\t\t\t\tcommentEdit.value = msg.comment;\n\t\t\t}\n\n\t\t\tif (msg.gameInfo) { // Update game info\n\t\t\t\tupdateGameInfoTable(msg.gameInfo);\n\t\t\t\tupdateGameInfoEdit(msg.gameInfo);\n\t\t\t}\n\t\t} // END function update\n\n\t\tfunction updateGameInfoTable(gameInfo) {\n\t\t\tvar table = document.createElement('table'),\n\t\t\t\ti, id, row, cell, text; // Scratch iteration variable\n\n\t\t\ttable.className = 'besogo-gameInfo';\n\t\t\tfor (i = 0; i < infoOrder.length; i++) { // Iterate in specified order\n\t\t\t\tid = infoOrder[i];\n\n\t\t\t\tif (gameInfo[id]) { // Only add row if property exists\n\t\t\t\t\trow = document.createElement('tr');\n\t\t\t\t\ttable.appendChild(row);\n\n\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\tcell.appendChild(document.createTextNode(infoIds[id]));\n\t\t\t\t\trow.appendChild(cell);\n\n\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\ttext = document.createTextNode(gameInfo[id]);\n\t\t\t\t\tcell.appendChild(text);\n\t\t\t\t\trow.appendChild(cell);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!table.firstChild || gameInfoTable.style.display === 'none') {\n\t\t\t\ttable.style.display = 'none'; // Do not display empty table or if already hidden\n\t\t\t}\n\t\t\tcontainer.replaceChild(table, gameInfoTable);\n\t\t\tgameInfoTable = table;\n\t\t}\n\n\t\tfunction updateGameInfoEdit(gameInfo) {\n\t\t\tvar table = document.createElement('table'),\n\t\t\t\tinfoTableOrder = playerInfoOrder.concat(infoOrder),\n\t\t\t\ti, id, row, cell, text;\n\n\t\t\ttable.className = 'besogo-gameInfo';\n\t\t\tfor (i = 0; i < infoTableOrder.length; i++) { // Iterate in specified order\n\t\t\t\tid = infoTableOrder[i];\n\t\t\t\trow = document.createElement('tr');\n\t\t\t\ttable.appendChild(row);\n\n\t\t\t\tcell = document.createElement('td');\n\t\t\t\tcell.appendChild(document.createTextNode(infoIds[id]));\n\t\t\t\trow.appendChild(cell);\n\n\t\t\t\tcell = document.createElement('td');\n\t\t\t\ttext = document.createElement('input');\n\t\t\t\tif (gameInfo[id]) {\n\t\t\t\t\ttext.value = gameInfo[id];\n\t\t\t\t}\n\t\t\t\ttext.onblur = function(t, id) {\n\t\t\t\t\treturn function() { // Commit change on blur\n\t\t\t\t\t\teditor.setGameInfo(t.value, id);\n\t\t\t\t\t};\n\t\t\t\t}(text, id);\n\t\t\t\ttext.addEventListener('keydown', function(evt) {\n\t\t\t\t\tevt = evt || window.event;\n\t\t\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t\t\t});\n\t\t\t\tcell.appendChild(text);\n\t\t\t\trow.appendChild(cell);\n\t\t\t}\n\t\t\tif (gameInfoEdit.style.display === 'none') {\n\t\t\t\ttable.style.display = 'none'; // Hide if already hidden\n\t\t\t}\n\t\t\tcontainer.replaceChild(table, gameInfoEdit);\n\t\t\tgameInfoEdit = table;\n\t\t}\n\n\t\tfunction updateText(parent, text, id) {\n\t\t\tvar textNode = document.createTextNode(text);\n\t\t\tparent.replaceChild(textNode, infoTexts[id]);\n\t\t\tinfoTexts[id] = textNode;\n\t\t}\n\n\t\tfunction makeInfoButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Info';\n\t\t\tbutton.title = 'Show/hide game info';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (gameInfoTable.style.display === 'none' && gameInfoTable.firstChild) {\n\t\t\t\t\tgameInfoTable.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tgameInfoEdit.style.display = 'none';\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t\tfunction makeInfoEditButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Edit Info';\n\t\t\tbutton.title = 'Edit game info';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (gameInfoEdit.style.display === 'none') {\n\t\t\t\t\tgameInfoEdit.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoEdit.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t\tfunction makeCommentButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Comment';\n\t\t\tbutton.title = 'Edit comment';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (commentEdit.style.display === 'none') { // Comment edit box hidden\n\t\t\t\t\tcommentBox.style.display = 'none'; // Hide static comment display\n\t\t\t\t\tgameInfoTable.style.display = 'none'; // Hide game info table\n\t\t\t\t\tcommentEdit.value = editor.getCurrent().comment;\n\t\t\t\t\tcommentEdit.style.display = 'block'; // Show comment edit box\n\t\t\t\t} else { // Comment edit box open\n\t\t\t\t\tcommentEdit.style.display = 'none'; // Hide comment edit box\n\t\t\t\t\tcommentBox.style.display = 'block'; // Show static comment display\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t};\n\tbesogo.makeControlPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar leftElements = [], // SVG elements for previous node buttons\n\t\t\trightElements = [], // SVG elements for next node buttons\n\t\t\tsiblingElements = [], // SVG elements for sibling buttons\n\t\t\tvariantStyleButton, // Button for changing variant style\n\t\t\thideVariantButton, // Button for toggling show/hide variants\n\t\t\tchildVariantElement, // SVG element for child style variants\n\t\t\tsiblingVariantElement, // SVG element for sibling style variants\n\t\t\thideVariantElement; // SVG element for hiding variants\n\n\t\tdrawNavButtons();\n\t\tdrawStyleButtons();\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tvariantStyle: editor.getVariantStyle()\n\t\t}); // Initialize\n\n\t\t// Callback for variant style and nav state changes\n\t\tfunction update(msg) {\n\t\t\tvar current;\n\n\t\t\tif (msg.variantStyle !== undefined) {\n\t\t\t\tupdateStyleButtons(msg.variantStyle);\n\t\t\t}\n\n\t\t\tif (msg.navChange || msg.treeChange) { // Update the navigation buttons\n\t\t\t\tcurrent = editor.getCurrent();\n\t\t\t\tif (current.parent) { // Has parent\n\t\t\t\t\tarraySetColor(leftElements, 'black');\n\t\t\t\t\tif (current.parent.children.length > 1) { // Has siblings\n\t\t\t\t\t\tarraySetColor(siblingElements, 'black');\n\t\t\t\t\t} else { // No siblings\n\t\t\t\t\t\tarraySetColor(siblingElements, besogo.GREY);\n\t\t\t\t\t}\n\t\t\t\t} else { // No parent\n\t\t\t\t\tarraySetColor(leftElements, besogo.GREY);\n\t\t\t\t\tarraySetColor(siblingElements, besogo.GREY);\n\t\t\t\t}\n\t\t\t\tif (current.children.length) { // Has children\n\t\t\t\t\tarraySetColor(rightElements, 'black');\n\t\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.borderColor = \"indianred\";\n\t\t\t\t} else { // No children\n\t\t\t\t\tarraySetColor(rightElements, besogo.GREY);\n\t\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.borderColor = \"limegreen\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction updateStyleButtons(style) { // Updates the variant style buttons\n\t\t\t\tif (style % 2) { // Sibling style variants\n\t\t\t\t\tchildVariantElement.setAttribute('fill', 'black');\n\t\t\t\t\tsiblingVariantElement.setAttribute('fill', besogo.BLUE);\n\t\t\t\t\tvariantStyleButton.title = 'Variants: child/[sibling]';\n\t\t\t\t} else { // Child style variants\n\t\t\t\t\tchildVariantElement.setAttribute('fill', besogo.BLUE);\n\t\t\t\t\tsiblingVariantElement.setAttribute('fill', besogo.RED);\n\t\t\t\t\tvariantStyleButton.title = 'Variants: [child]/sibling';\n\t\t\t\t}\n\t\t\t\tif (style >= 2) { // Hide auto-markup for variants\n\t\t\t\t\thideVariantElement.setAttribute('visibility', 'visible');\n\t\t\t\t\thideVariantButton.title = 'Variants: show/[hide]';\n\t\t\t\t} else { // Show auto-markup for variants\n\t\t\t\t\thideVariantElement.setAttribute('visibility', 'hidden');\n\t\t\t\t\thideVariantButton.title = 'Variants: [show]/hide';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction arraySetColor(list, color) { // Changes fill color of list of svg elements\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < list.length; i++) {\n\t\t\t\t\tlist[i].setAttribute('fill', color);\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function update\n\n\t\t// Draws the navigation buttons\n\t\tfunction drawNavButtons() {\n\t\t\tleftElements.push(makeNavButton('First node',\n\t\t\t\t'5,10 5,90 25,90 25,50 95,90 95,10 25,50 25,10',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.prevNode(-1);\n\t\t\t\t}));\n\t\t\tleftElements.push(makeNavButton('Jump back',\n\t\t\t\t'95,10 50,50 50,10 5,50 50,90 50,50 95,90',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.prevNode(10);\n\t\t\t\t}));\n\t\t\tleftElements.push(makeNavButton('Previous node', '85,10 85,90 15,50', function() {\n\t\t\t\teditor.prevNode(1);\n\t\t\t}));\n\n\t\t\trightElements.push(makeNavButton('Next node', '15,10 15,90 85,50', function() {\n\t\t\t\teditor.nextNode(1);\n\t\t\t}));\n\t\t\trightElements.push(makeNavButton('Jump forward',\n\t\t\t\t'5,10 50,50 50,10 95,50 50,90 50,50 5,90',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.nextNode(10);\n\t\t\t\t}));\n\t\t\trightElements.push(makeNavButton('Last node',\n\t\t\t\t'95,10 95,90 75,90 75,50 5,90 5,10 75,50 75,10',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.nextNode(-1);\n\t\t\t\t}));\n\n\t\t\tsiblingElements.push(makeNavButton('Previous sibling', '10,85 90,85 50,15', function() {\n\t\t\t\teditor.nextSibling(-1);\n\t\t\t}));\n\t\t\tsiblingElements.push(makeNavButton('Next sibling', '10,15 90,15 50,85', function() {\n\t\t\t\teditor.nextSibling(1);\n\t\t\t}));\n\n\t\t\tfunction makeNavButton(tooltip, pointString, action) { // Creates a navigation button\n\t\t\t\tvar button = document.createElement('button'),\n\t\t\t\t\tsvg = makeButtonContainer(),\n\t\t\t\t\telement = besogo.svgEl(\"polygon\", {\n\t\t\t\t\t\tpoints: pointString,\n\t\t\t\t\t\tstroke: 'none',\n\t\t\t\t\t\tfill: 'black'\n\t\t\t\t\t});\n\n\t\t\t\tbutton.title = tooltip;\n\t\t\t\tbutton.onclick = action;\n\t\t\t\tbutton.appendChild(svg);\n\t\t\t\tsvg.appendChild(element);\n\t\t\t\tcontainer.appendChild(button);\n\n\t\t\t\treturn element;\n\t\t\t} // END function makeNavButton\n\t\t} // END function drawNavButtons\n\n\t\t// Draws the variant style buttons\n\t\tfunction drawStyleButtons() {\n\t\t\tvar svg, element, coordStyleButton;\n\n\t\t\tvariantStyleButton = document.createElement('button');\n\t\t\tvariantStyleButton.onclick = function() {\n\t\t\t\teditor.toggleVariantStyle(false); // Toggles child/sibling variants\n\t\t\t};\n\t\t\tcontainer.appendChild(variantStyleButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\tvariantStyleButton.appendChild(svg);\n\t\t\telement = besogo.svgEl(\"path\", {\n\t\t\t\td: 'm75,25h-50l50,50',\n\t\t\t\tstroke: 'black',\n\t\t\t\t\"stroke-width\": 5,\n\t\t\t\tfill: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(element);\n\t\t\tchildVariantElement = besogo.svgEl('circle', {\n\t\t\t\tcx: 25,\n\t\t\t\tcy: 25,\n\t\t\t\tr: 20,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(childVariantElement);\n\t\t\tsiblingVariantElement = besogo.svgEl('circle', {\n\t\t\t\tcx: 75,\n\t\t\t\tcy: 25,\n\t\t\t\tr: 20,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(siblingVariantElement);\n\t\t\telement = besogo.svgEl('circle', {\n\t\t\t\tcx: 75,\n\t\t\t\tcy: 75,\n\t\t\t\tr: 20,\n\t\t\t\tfill: besogo.RED,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(element);\n\n\t\t\thideVariantButton = document.createElement('button');\n\t\t\thideVariantButton.onclick = function() {\n\t\t\t\teditor.toggleVariantStyle(true); // Toggles show/hide variants\n\t\t\t};\n\t\t\tcontainer.appendChild(hideVariantButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\thideVariantButton.appendChild(svg);\n\t\t\tsvg.appendChild(besogo.svgLabel(50, 50, besogo.RED, 'A'));\n\t\t\thideVariantElement = besogo.svgCross(50, 50, 'black');\n\t\t\tsvg.appendChild(hideVariantElement);\n\n\t\t\tcoordStyleButton = document.createElement('button');\n\t\t\tcoordStyleButton.onclick = function() {\n\t\t\t\teditor.toggleCoordStyle(); // Toggles coordinate style\n\t\t\t};\n\t\t\tcoordStyleButton.title = 'Toggle coordinates';\n\t\t\tcontainer.appendChild(coordStyleButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\tcoordStyleButton.appendChild(svg);\n\t\t\tsvg.appendChild(besogo.svgLabel(50, 50, 'black', '4'));\n\t\t} // END function drawStyleButtons\n\n\t\t// Makes an SVG container for the button graphics\n\t\tfunction makeButtonContainer() {\n\t\t\treturn besogo.svgEl('svg', {\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%',\n\t\t\t\tviewBox: \"0 0 100 100\"\n\t\t\t});\n\t\t}\n\t};\n\t(function() {\n\t\t'use strict';\n\n\t\t// Parent object to hold coordinate system helper functions\n\t\tbesogo.coord = {};\n\n\t\t// Null function for no coordinate system\n\t\tbesogo.coord.none = function(sizeX, sizeY) {\n\t\t\treturn false;\n\t\t};\n\n\t\t// Western, chess-like, \"A1\" coordinate system\n\t\tbesogo.coord.western = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = numberToLetter(i);\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Simple purely numeric coordinate system\n\t\tbesogo.coord.numeric = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = i + '';\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = i + '';\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Corner-relative, alpha-numeric, coordinate system\n\t\tbesogo.coord.corner = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tif (i < (sizeX / 2) + 1) {\n\t\t\t\t\tlabels.x[i] = numberToLetter(i);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.x[i] = (sizeX - i + 1) + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t\tif (i > (sizeY / 2)) {\n\t\t\t\t\tlabels.y[i] = numberToLetter(sizeY - i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.y[i] = i + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Corner-relative, numeric and CJK, coordinate system\n\t\tbesogo.coord.eastcor = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tif (i < (sizeX / 2) + 1) {\n\t\t\t\t\tlabels.x[i] = numberToCJK(i);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.x[i] = (sizeX - i + 1) + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t\tif (i > (sizeY / 2)) {\n\t\t\t\t\tlabels.y[i] = numberToCJK(sizeY - i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.y[i] = i + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Eastern, numeric and CJK, coordinate system\n\t\tbesogo.coord.eastern = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = i + ''; // Columns are numeric\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = numberToCJK(i);\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Helper for converting numeric coord to letter (skipping I)\n\t\tfunction numberToLetter(number) {\n\t\t\treturn 'ABCDEFGHJKLMNOPQRSTUVWXYZ'.charAt((number - 1) % 25);\n\t\t}\n\n\t\t// Helper for converting numeric coord to CJK symbol\n\t\tfunction numberToCJK(number) {\n\t\t\tvar label = '',\n\t\t\t\tcjk = '';\n\n\t\t\tif (number >= 20) { // 20 and larger\n\t\t\t\tlabel = cjk.charAt(number / 10 - 1) + '';\n\t\t\t} else if (number >= 10) { // 10 through 19\n\t\t\t\tlabel = '';\n\t\t\t}\n\t\t\tif (number % 10) { // Ones digit if non-zero\n\t\t\t\tlabel = label + cjk.charAt((number - 1) % 10);\n\t\t\t}\n\t\t\treturn label;\n\t\t}\n\n\t})(); // END closure\n\tbesogo.makeEditor = function(sizeX, sizeY) {\n\t\t'use strict';\n\t\t// Creates an associated game state tree\n\t\tvar root = besogo.makeGameRoot(sizeX, sizeY),\n\t\t\tcurrent = root, // Navigation cursor\n\n\t\t\tlisteners = [], // Listeners of general game/editor state changes\n\n\t\t\t// Enumeration of editor tools/modes\n\t\t\tTOOLS = ['navOnly', // read-only navigate mode\n\t\t\t\t'auto', // auto-mode: navigate or auto-play color\n\t\t\t\t'playB', // play black stone\n\t\t\t\t'playW', // play white stone\n\t\t\t\t'addB', // setup black stone\n\t\t\t\t'addW', // setup white stone\n\t\t\t\t'addE', // setup empty stone\n\t\t\t\t'clrMark', // remove markup\n\t\t\t\t'circle', // circle markup\n\t\t\t\t'square', // square markup\n\t\t\t\t'triangle', // triangle markup\n\t\t\t\t'cross', // \"X\" cross markup\n\t\t\t\t'block', // filled square markup\n\t\t\t\t'label'\n\t\t\t], // label markup\n\t\t\ttool = 'auto', // Currently active tool (default: auto-mode)\n\t\t\tlabel = \"1\", // Next label that will be applied\n\n\t\t\tnavHistory = [], // Navigation history\n\n\t\t\tgameInfo = {}, // Game info properties\n\n\t\t\t// Order of coordinate systems\n\t\t\tCOORDS = 'none numeric western eastern corner eastcor'.split(' '),\n\t\t\tcoord = 'none', // Selected coordinate system\n\n\t\t\t// Variant style: even/odd - children/siblings, <2 - show auto markup for variants\n\t\t\tvariantStyle = 2; // 0-3, 0 is default\n\n\t\treturn {\n\t\t\taddListener: addListener,\n\t\t\tclick: click,\n\t\t\tnextNode: nextNode,\n\t\t\tprevNode: prevNode,\n\t\t\tnextSibling: nextSibling,\n\t\t\ttoggleCoordStyle: toggleCoordStyle,\n\t\t\tgetCoordStyle: getCoordStyle,\n\t\t\tsetCoordStyle: setCoordStyle,\n\t\t\ttoggleVariantStyle: toggleVariantStyle,\n\t\t\tgetVariantStyle: getVariantStyle,\n\t\t\tsetVariantStyle: setVariantStyle,\n\t\t\tgetGameInfo: getGameInfo,\n\t\t\tsetGameInfo: setGameInfo,\n\t\t\tsetComment: setComment,\n\t\t\tgetTool: getTool,\n\t\t\tsetTool: setTool,\n\t\t\tgetLabel: getLabel,\n\t\t\tsetLabel: setLabel,\n\t\t\tgetVariants: getVariants, // Returns variants of current node\n\t\t\tgetCurrent: getCurrent,\n\t\t\tsetCurrent: setCurrent,\n\t\t\tcutCurrent: cutCurrent,\n\t\t\tgetRoot: getRoot,\n\t\t\tloadRoot: loadRoot // Loads new game state\n\t\t};\n\n\t\t// Returns the active tool\n\t\tfunction getTool() {\n\t\t\treturn tool;\n\t\t}\n\n\t\t// Sets the active tool, returns false if failed\n\t\tfunction setTool(set) {\n\t\t\t// Toggle label mode if already label tool already selected\n\t\t\tif (set === 'label' && set === tool) {\n\t\t\t\tif (/^-?\\d+$/.test(label)) { // If current label is integer\n\t\t\t\t\tsetLabel('A'); // Toggle to characters\n\t\t\t\t} else {\n\t\t\t\t\tsetLabel('1'); // Toggle back to numbers\n\t\t\t\t}\n\t\t\t\treturn true; // Notification already handled by setLabel\n\t\t\t}\n\t\t\t// Set the tool only if in list and actually changed\n\t\t\tif (TOOLS.indexOf(set) !== -1 && tool !== set) {\n\t\t\t\ttool = set;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\ttool: tool,\n\t\t\t\t\tlabel: label\n\t\t\t\t}); // Notify tool change\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Gets the next label to apply\n\t\tfunction getLabel() {\n\t\t\treturn label;\n\t\t}\n\n\t\t// Sets the next label to apply and sets active tool to label\n\t\tfunction setLabel(set) {\n\t\t\tif (typeof set === 'string') {\n\t\t\t\tset = set.replace(/\\s/g, ' ').trim(); // Convert all whitespace to space and trim\n\t\t\t\tlabel = set || \"1\"; // Default to \"1\" if empty string\n\t\t\t\ttool = 'label'; // Also change current tool to label\n\t\t\t\tnotifyListeners({\n\t\t\t\t\ttool: tool,\n\t\t\t\t\tlabel: label\n\t\t\t\t}); // Notify tool/label change\n\t\t\t}\n\t\t}\n\n\t\t// Toggle the coordinate style\n\t\tfunction toggleCoordStyle() {\n\t\t\tcoord = COORDS[(COORDS.indexOf(coord) + 1) % COORDS.length];\n\t\t\tnotifyListeners({\n\t\t\t\tcoord: coord\n\t\t\t});\n\t\t}\n\n\t\t// Gets the current coordinate style\n\t\tfunction getCoordStyle() {\n\t\t\treturn coord;\n\t\t}\n\n\t\t// Sets the coordinate system style\n\t\tfunction setCoordStyle(setCoord) {\n\t\t\tif (besogo.coord[setCoord]) {\n\t\t\t\tcoord = setCoord;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tcoord: setCoord\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Toggles the style for showing variants\n\t\tfunction toggleVariantStyle(toggleShow) {\n\t\t\tvar childStyle = variantStyle % 2, // 0: children, 1: siblings\n\t\t\t\tshowStyle = variantStyle - childStyle; // 0: show auto-markup, 2: hide\n\t\t\tif (toggleShow) { // Truthy input toggles showing of auto-markup\n\t\t\t\tshowStyle = (showStyle + 2) % 4; // 0 => 2 or 2 => 0\n\t\t\t} else { // Falsy input toggles child vs sibling style\n\t\t\t\tchildStyle = (childStyle + 1) % 2; // 0 => 1 or 1 => 0\n\t\t\t}\n\t\t\tvariantStyle = childStyle + showStyle;\n\t\t\tnotifyListeners({\n\t\t\t\tvariantStyle: variantStyle,\n\t\t\t\tmarkupChange: true\n\t\t\t});\n\t\t}\n\n\t\t// Returns the variant style\n\t\tfunction getVariantStyle() {\n\t\t\treturn variantStyle;\n\t\t}\n\n\t\t// Directly sets the variant style\n\t\tfunction setVariantStyle(style) {\n\t\t\tif (style === 0 || style === 1 || style === 2 || style === 3) {\n\t\t\t\tvariantStyle = 3;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tvariantStyle: variantStyle,\n\t\t\t\t\tmarkupChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction getGameInfo() {\n\t\t\treturn gameInfo;\n\t\t}\n\n\t\tfunction setGameInfo(info, id) {\n\t\t\tif (id) {\n\t\t\t\tgameInfo[id] = info;\n\t\t\t} else {\n\t\t\t\tgameInfo = info;\n\t\t\t}\n\t\t\tnotifyListeners({\n\t\t\t\tgameInfo: gameInfo\n\t\t\t});\n\t\t}\n\n\t\tfunction setComment(text) {\n\t\t\ttext = text.trim(); // Trim whitespace and standardize line breaks\n\t\t\ttext = text.replace(/\\r\\n/g, '\\n').replace(/\\n\\r/g, '\\n').replace(/\\r/g, '\\n');\n\t\t\ttext.replace(/\\f\\t\\v\\u0085\\u00a0/g, ' '); // Convert other whitespace to space\n\t\t\tcurrent.comment = text;\n\t\t\tnotifyListeners({\n\t\t\t\tcomment: text\n\t\t\t});\n\t\t}\n\n\t\t// Returns variants of the current node according to the set style\n\t\tfunction getVariants() {\n\t\t\tif (variantStyle >= 2) { // Do not show variants if style >= 2\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tif (variantStyle === 1) { // Display sibling variants\n\t\t\t\t// Root node does not have parent nor siblings\n\t\t\t\treturn current.parent ? current.parent.children : [];\n\t\t\t}\n\t\t\treturn current.children; // Otherwise, style must be 0, display child variants\n\t\t}\n\n\t\t// Returns the currently active node in the game state tree\n\t\tfunction getCurrent() {\n\t\t\treturn current;\n\t\t}\n\n\t\t// Returns the root of the game state tree\n\t\tfunction getRoot() {\n\t\t\treturn root;\n\t\t}\n\n\t\tfunction loadRoot(load) {\n\t\t\troot = load;\n\t\t\tcurrent = load;\n\t\t\tnotifyListeners({\n\t\t\t\ttreeChange: true,\n\t\t\t\tnavChange: true,\n\t\t\t\tstoneChange: true\n\t\t\t});\n\t\t}\n\n\t\t// Navigates forward num nodes (to the end if num === -1)\n\t\tfunction nextNode(num) {\n\t\t\tif (current.children.length === 0) { // Check if no children\n\t\t\t\treturn false; // Do nothing if no children (avoid notification)\n\t\t\t}\n\t\t\twhile (current.children.length > 0 && num !== 0) {\n\t\t\t\tif (navHistory.length) { // Non-empty navigation history\n\t\t\t\t\tcurrent = navHistory.pop();\n\t\t\t\t} else { // Empty navigation history\n\t\t\t\t\tcurrent = current.children[0]; // Go to first child\n\t\t\t\t}\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\tnotifyListeners({\n\t\t\t\tnavChange: true\n\t\t\t}, true); // Preserve history\n\t\t}\n\n\t\t// Navigates backward num nodes (to the root if num === -1)\n\t\tfunction prevNode(num) {\n\t\t\tif (current.parent === null) { // Check if root\n\t\t\t\treturn false; // Do nothing if already at root (avoid notification)\n\t\t\t}\n\t\t\twhile (current.parent && num !== 0) {\n\t\t\t\tnavHistory.push(current); // Save current into navigation history\n\t\t\t\tcurrent = current.parent;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\tnotifyListeners({\n\t\t\t\tnavChange: true\n\t\t\t}, true); // Preserve history\n\t\t}\n\n\t\t// Cyclically switches through siblings\n\t\tfunction nextSibling(change) {\n\t\t\tvar siblings,\n\t\t\t\ti = 0;\n\n\t\t\tif (current.parent) {\n\t\t\t\tsiblings = current.parent.children;\n\n\t\t\t\t// Exit early if only child\n\t\t\t\tif (siblings.length === 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Find index of current amongst siblings\n\t\t\t\ti = siblings.indexOf(current);\n\n\t\t\t\t// Apply change cyclically\n\t\t\t\ti = (i + change) % siblings.length;\n\t\t\t\tif (i < 0) {\n\t\t\t\t\ti += siblings.length;\n\t\t\t\t}\n\n\t\t\t\tcurrent = siblings[i];\n\t\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tnavChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Sets the current node\n\t\tfunction setCurrent(node) {\n\t\t\tif (current !== node) {\n\t\t\t\tcurrent = node;\n\t\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tnavChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Removes current branch from the tree\n\t\tfunction cutCurrent() {\n\t\t\tvar parent = current.parent;\n\t\t\tif (tool === 'navOnly') {\n\t\t\t\treturn; // Tree editing disabled in navOnly mode\n\t\t\t}\n\t\t\tif (parent) {\n\t\t\t\tif (confirm(\"Delete this branch?\") === true) {\n\t\t\t\t\tparent.removeChild(current);\n\t\t\t\t\tcurrent = parent;\n\t\t\t\t\t// Notify navigation and tree edited\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle click with application of selected tool\n\t\tfunction click(i, j, ctrlKey, shiftKey) {\n\t\t\tswitch (tool) {\n\t\t\t\tcase 'navOnly':\n\t\t\t\t\tnavigate(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'auto':\n\t\t\t\t\tif (!navigate(i, j, shiftKey) && !shiftKey) { // Try to navigate to (i, j)\n\t\t\t\t\t\tplayMove(i, j, 0, ctrlKey); // Play auto-color move if navigate fails\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'playB':\n\t\t\t\t\tplayMove(i, j, -1, ctrlKey); // Black move\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'playW':\n\t\t\t\t\tplayMove(i, j, 1, ctrlKey); // White move\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addB':\n\t\t\t\t\tplaceSetup(i, j, -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addW':\n\t\t\t\t\tplaceSetup(i, j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addE':\n\t\t\t\t\tplaceSetup(i, j, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'clrMark':\n\t\t\t\t\tsetMarkup(i, j, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'circle':\n\t\t\t\t\tsetMarkup(i, j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'square':\n\t\t\t\t\tsetMarkup(i, j, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'triangle':\n\t\t\t\t\tsetMarkup(i, j, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cross':\n\t\t\t\t\tsetMarkup(i, j, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'block':\n\t\t\t\t\tsetMarkup(i, j, 5);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'label':\n\t\t\t\t\tsetMarkup(i, j, label);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Navigates to child with move at (x, y), searching tree if shiftKey pressed\n\t\t// Returns true is successful, false if not\n\t\tfunction navigate(x, y, shiftKey) {\n\t\t\tvar i, move,\n\t\t\t\tchildren = current.children;\n\n\t\t\t// Look for move at same location in children\n\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\tmove = children[i].move;\n\t\t\t\tif (move && move.x === x && move.y === y) {\n\t\t\t\t\tcurrent = children[i]; // Navigate to child if found\n\t\t\t\t\t// Notify navigation (with no tree edits)\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\tnavChange: true\n\t\t\t\t\t});\n\t\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.pointerEvents = \"none\";\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdocument.querySelector('[title=\"Next node\"]').click();\n\t\t\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.pointerEvents = \"auto\";\n\t\t\t\t\t}, 400);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (document.getElementsByClassName(\"besogo-diagram\")[0].style.borderColor !== \"limegreen\") {\n\t\t\t\terrorCheck = true;\n\t\t\t}\n\t\t\tif (Persistence.isAvailable()) {\n\t\t\tPersistence.setItem(\"errorCheck\", errorCheck);\n\t\t\t}\n\t\t\treturn false;\n\t\t\t}\n\t\t// Plays a move at the given color and location\n\t\t// Set allowAll to truthy to allow illegal moves\n\t\tfunction playMove(i, j, color, allowAll) {\n\t\t\tvar next;\n\t\t\t// Check if current node is immutable or root\n\t\t\tif (!current.isMutable('move') || !current.parent) {\n\t\t\t\tnext = current.makeChild(); // Create a new child node\n\t\t\t\tif (next.playMove(i, j, color, allowAll)) { // Play in new node\n\t\t\t\t\t// Keep (add to game state tree) only if move succeeds\n\t\t\t\t\tcurrent.addChild(next);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t\t// Notify tree change, navigation, and stone change\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true,\n\t\t\t\t\t\tstoneChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// Current node is mutable and not root\n\t\t\t} else if (current.playMove(i, j, color, allowAll)) { // Play in current\n\t\t\t\t// Only need to update if move succeeds\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tstoneChange: true\n\t\t\t\t}); // Stones changed\n\t\t\t}\n\t\t}\n\n\t\t// Places a setup stone at the given color and location\n\t\tfunction placeSetup(i, j, color) {\n\t\t\tvar next;\n\t\t\tif (color === current.getStone(i, j)) { // Compare setup to current\n\t\t\t\tif (color !== 0) {\n\t\t\t\t\tcolor = 0; // Same as current indicates removal desired\n\t\t\t\t} else { // Color and current are both empty\n\t\t\t\t\treturn; // No change if attempting to set empty to empty\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if current node can accept setup stones\n\t\t\tif (!current.isMutable('setup')) {\n\t\t\t\tnext = current.makeChild(); // Create a new child node\n\t\t\t\tif (next.placeSetup(i, j, color)) { // Place setup stone in new node\n\t\t\t\t\t// Keep (add to game state tree) only if change occurs\n\t\t\t\t\tcurrent.addChild(next);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t\t// Notify tree change, navigation, and stone change\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true,\n\t\t\t\t\t\tstoneChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (current.placeSetup(i, j, color)) { // Try setup in current\n\t\t\t\t// Only need to update if change occurs\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tstoneChange: true\n\t\t\t\t}); // Stones changed\n\t\t\t}\n\t\t}\n\n\t\t// Sets the markup at the given location and place\n\t\tfunction setMarkup(i, j, mark) {\n\t\t\tvar temp; // For label incrementing\n\t\t\tif (mark === current.getMarkup(i, j)) { // Compare mark to current\n\t\t\t\tif (mark !== 0) {\n\t\t\t\t\tmark = 0; // Same as current indicates removal desired\n\t\t\t\t} else { // Mark and current are both empty\n\t\t\t\t\treturn; // No change if attempting to set empty to empty\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (current.addMarkup(i, j, mark)) { // Try to add the markup\n\t\t\t\tif (typeof mark === 'string') { // If markup is a label, increment the label\n\t\t\t\t\tif (/^-?\\d+$/.test(mark)) { // Integer number label\n\t\t\t\t\t\ttemp = +mark; // Convert to number\n\t\t\t\t\t\t// Increment and convert back to string\n\t\t\t\t\t\tsetLabel(\"\" + (temp + 1));\n\t\t\t\t\t} else if (/[A-Za-z]$/.test(mark)) { // Ends with [A-Za-z]\n\t\t\t\t\t\t// Get the last character in the label\n\t\t\t\t\t\ttemp = mark.charAt(mark.length - 1);\n\t\t\t\t\t\tif (temp === 'z') { // Cyclical increment\n\t\t\t\t\t\t\ttemp = 'A'; // Move onto uppercase letters\n\t\t\t\t\t\t} else if (temp === 'Z') {\n\t\t\t\t\t\t\ttemp = 'a'; // Move onto lowercase letters\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp = String.fromCharCode(temp.charCodeAt() + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Replace last character of label with incremented char\n\t\t\t\t\t\tsetLabel(mark.slice(0, mark.length - 1) + temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tmarkupChange: true\n\t\t\t\t}); // Notify markup change\n\t\t\t}\n\t\t}\n\n\t\t// Adds a listener (by call back func) that will be notified on game/editor state changes\n\t\tfunction addListener(listener) {\n\t\t\tlisteners.push(listener);\n\t\t}\n\n\t\t// Notify listeners with the given message object\n\t\t//  Data sent to listeners:\n\t\t//    tool: changed tool selection\n\t\t//    label: changed next label\n\t\t//    coord: changed coordinate system \n\t\t//    variantStyle: changed variant style\n\t\t//    gameInfo: changed game info\n\t\t//    comment: changed comment in current node\n\t\t//  Flags sent to listeners:\n\t\t//    treeChange: nodes added or removed from tree\n\t\t//    navChange: current switched to different node\n\t\t//    stoneChange: stones modified in current node\n\t\t//    markupChange: markup modified in current node\n\t\tfunction notifyListeners(msg, keepHistory) {\n\t\t\tvar i;\n\t\t\tif (!keepHistory && msg.navChange) {\n\t\t\t\tnavHistory = []; // Clear navigation history\n\t\t\t}\n\t\t\tfor (i = 0; i < listeners.length; i++) {\n\t\t\t\tlisteners[i](msg);\n\t\t\t}\n\t\t}\n\t};\n\tbesogo.makeFilePanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar fileChooser, // Reference to the file chooser element\n\t\t\telement, // Scratch variable for creating elements\n\t\t\tWARNING = \"Everything not saved will be lost\";\n\n\t\tmakeNewBoardButton(9); // New 9x9 board button\n\t\tmakeNewBoardButton(13); // New 13x13 board button\n\t\tmakeNewBoardButton(19); // New 19x19 board button\n\t\tmakeNewBoardButton('?'); // New custom board button\n\n\t\t// Hidden file chooser element\n\t\tfileChooser = makeFileChooser();\n\t\tcontainer.appendChild(fileChooser);\n\n\t\t// Load file button\n\t\telement = document.createElement('input');\n\t\telement.type = 'button';\n\t\telement.value = 'Open';\n\t\telement.title = 'Import SGF';\n\t\telement.onclick = function() { // Bind click to the hidden file chooser\n\t\t\tfileChooser.click();\n\t\t};\n\t\tcontainer.appendChild(element);\n\n\t\t// Save file button\n\t\telement = document.createElement('input');\n\t\telement.type = 'button';\n\t\telement.value = 'Save';\n\t\telement.title = 'Export SGF';\n\t\telement.onclick = function() {\n\t\t\tvar fileName = prompt('Save file as', 'export.sgf');\n\t\t\tif (fileName) { // Canceled or empty string does nothing\n\t\t\t\tsaveFile(fileName, besogo.composeSgf(editor));\n\t\t\t}\n\t\t};\n\t\tcontainer.appendChild(element);\n\n\n\t\t// Makes a new board button\n\t\tfunction makeNewBoardButton(size) {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = size + \"x\" + size;\n\t\t\tif (size === '?') { // Make button for custom sized board\n\t\t\t\tbutton.title = \"New custom size board\";\n\t\t\t\tbutton.onclick = function() {\n\t\t\t\t\tvar input = prompt(\"Enter custom size for new board\" + \"\\n\" + WARNING, \"19:19\"),\n\t\t\t\t\t\tsize;\n\t\t\t\t\tif (input) { // Canceled or empty string does nothing\n\t\t\t\t\t\tsize = besogo.parseSize(input);\n\t\t\t\t\t\teditor.loadRoot(besogo.makeGameRoot(size.x, size.y));\n\t\t\t\t\t\teditor.setGameInfo({});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else { // Make button for fixed size board\n\t\t\t\tbutton.title = \"New \" + size + \"x\" + size + \" board\";\n\t\t\t\tbutton.onclick = function() {\n\t\t\t\t\tif (confirm(button.title + \"?\\n\" + WARNING)) {\n\t\t\t\t\t\teditor.loadRoot(besogo.makeGameRoot(size, size));\n\t\t\t\t\t\teditor.setGameInfo({});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tcontainer.appendChild(button);\n\t\t}\n\n\t\t// Creates the file selector\n\t\tfunction makeFileChooser() {\n\t\t\tvar chooser = document.createElement('input');\n\t\t\tchooser.type = 'file';\n\t\t\tchooser.style.display = 'none'; // Keep hidden\n\t\t\tchooser.onchange = readFile; // Read, parse and load on file select\n\t\t\treturn chooser;\n\t\t}\n\n\t\t// Reads, parses and loads an SGF file\n\t\tfunction readFile(evt) {\n\t\t\tvar file = evt.target.files[0], // Selected file\n\t\t\t\treader = new FileReader(),\n\t\t\t\tnewChooser = makeFileChooser(); // Create new file input to reset selection\n\n\t\t\tcontainer.replaceChild(newChooser, fileChooser); // Replace with the reset selector\n\t\t\tfileChooser = newChooser;\n\n\t\t\treader.onload = function(e) { // Parse and load game tree\n\t\t\t\tvar sgf;\n\t\t\t\ttry {\n\t\t\t\t\tsgf = besogo.parseSgf(e.target.result);\n\t\t\t\t} catch (error) {\n\t\t\t\t\talert('SGF parse error at ' + error.at + ':\\n' + error.message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbesogo.loadSgf(sgf, editor);\n\t\t\t};\n\t\t\tif (confirm(\"Load '\" + file.name + \"'?\\n\" + WARNING)) {\n\t\t\t\treader.readAsText(file); // Initiate file read\n\t\t\t}\n\t\t}\n\n\t\t// Composes SGF file and initializes download\n\t\tfunction saveFile(fileName, text) {\n\t\t\tvar link = document.createElement('a'),\n\t\t\t\tblob = new Blob([text], {\n\t\t\t\t\tencoding: \"UTF-8\",\n\t\t\t\t\ttype: \"text/plain;charset=UTF-8\"\n\t\t\t\t});\n\n\t\t\tlink.download = fileName; // Set download file name\n\t\t\tlink.href = URL.createObjectURL(blob);\n\t\t\tlink.style.display = 'none'; // Make link hidden\n\t\t\tcontainer.appendChild(link); // Add link to ensure that clicking works\n\t\t\tlink.click(); // Click on link to initiate download\n\t\t\tcontainer.removeChild(link); // Immediately remove the link\n\t\t}\n\t};\n\tbesogo.makeGameRoot = function(sizeX, sizeY) {\n\t\t'use strict';\n\t\tvar BLACK = -1, // Stone state constants\n\t\t\tWHITE = 1, // Equal to -BLACK\n\t\t\tEMPTY = 0, // Any falsy (e.g., undefined) value is also empty\n\n\t\t\troot = { // Inherited attributes of root node\n\t\t\t\tnextToMove: BLACK,\n\t\t\t\tblackCaps: 0,\n\t\t\t\twhiteCaps: 0,\n\t\t\t\tmoveNumber: 0\n\t\t\t};\n\n\t\t// Initializes non-inherited attributes\n\t\tfunction initNode(node, parent) {\n\t\t\tnode.parent = parent;\n\t\t\tnode.children = [];\n\n\t\t\tnode.move = null;\n\t\t\tnode.setupStones = [];\n\t\t\tnode.markup = [];\n\t\t\tnode.comment = ''; // Comment on this node\n\t\t}\n\t\tinitNode(root, null); // Initialize root node with null parent\n\n\n\t\t// Plays a move, returns true if successful\n\t\t// Set allow to truthy to allow overwrite, suicide and ko\n\t\troot.playMove = function(x, y, color, allow) {\n\t\t\tvar captures = 0, // Number of captures made by this move\n\t\t\t\toverwrite = false, // Flags whether move overwrites a stone\n\t\t\t\tprevMove, // Previous move for ko check\n\t\t\t\ttestBoard, // Copy of board state to test captures, ko, and suicide\n\t\t\t\tpending, // Pending capture locations\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!this.isMutable('move')) {\n\t\t\t\treturn false; // Move fails if node is immutable\n\t\t\t}\n\n\t\t\tif (!color) { // Falsy color indicates auto-color\n\t\t\t\tcolor = this.nextToMove;\n\t\t\t}\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\tthis.move = { // Register as pass move if out of bounds\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0, // Log pass as position (0, 0)\n\t\t\t\t\tcolor: color,\n\t\t\t\t\tcaptures: 0, // Pass never captures\n\t\t\t\t\toverwrite: false // Pass is never an overwrite\n\t\t\t\t};\n\t\t\t\tthis.nextToMove = -color; // Update next to move\n\t\t\t\tthis.moveNumber++; // Increment move number\n\t\t\t\treturn true; // Pass move successful\n\t\t\t}\n\n\t\t\tif (this.getStone(x, y)) { // Check for overwrite\n\t\t\t\tif (!allow) {\n\t\t\t\t\treturn false; // Reject overwrite move if not allowed\n\t\t\t\t}\n\t\t\t\toverwrite = true; // Otherwise, flag overwrite and proceed\n\t\t\t}\n\n\t\t\ttestBoard = Object.create(this); // Copy board state (no need to initialize)\n\t\t\tpending = []; // Initialize pending capture array\n\n\t\t\tsetStone(testBoard, x, y, color); // Place the move stone\n\n\t\t\t// Check for captures of surrounding chains\n\t\t\tcaptureStones(testBoard, x - 1, y, color, pending);\n\t\t\tcaptureStones(testBoard, x + 1, y, color, pending);\n\t\t\tcaptureStones(testBoard, x, y - 1, color, pending);\n\t\t\tcaptureStones(testBoard, x, y + 1, color, pending);\n\n\t\t\tcaptures = pending.length; // Capture count\n\n\t\t\tprevMove = this.parent ? this.parent.move : null; // Previous move played\n\t\t\tif (!allow && prevMove && // If previous move exists, ...\n\t\t\t\tprevMove.color === -color && // was of the opposite color, ...\n\t\t\t\tprevMove.overwrite === false && // not an overwrite, ...\n\t\t\t\tprevMove.captures === 1 && // captured exactly one stone, and if ...\n\t\t\t\tcaptures === 1 && // this move captured exactly one stone at the location ...\n\t\t\t\t!testBoard.getStone(prevMove.x, prevMove.y)) { // of the previous move\n\t\t\t\treturn false; // Reject ko move if not allowed\n\t\t\t}\n\n\t\t\tif (captures === 0) { // Check for suicide if nothing was captured\n\t\t\t\tcaptureStones(testBoard, x, y, -color, pending); // Invert color for suicide check\n\t\t\t\tcaptures = -pending.length; // Count suicide as negative captures\n\t\t\t\tif (captures < 0 && !allow) {\n\t\t\t\t\treturn false; // Reject suicidal move if not allowed\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (color * captures < 0) { // Capture by black or suicide by white\n\t\t\t\tthis.blackCaps += Math.abs(captures); // Tally captures for black\n\t\t\t} else { // Capture by white or suicide by black\n\t\t\t\tthis.whiteCaps += Math.abs(captures); // Tally captures for white\n\t\t\t}\n\n\t\t\tsetStone(this, x, y, color); // Place the stone\n\t\t\tfor (i = 0; i < pending.length; i++) { // Remove the captures\n\t\t\t\tsetStone(this, pending[i].x, pending[i].y, EMPTY);\n\t\t\t}\n\n\t\t\tthis.move = { // Log the move\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tcolor: color,\n\t\t\t\tcaptures: captures,\n\t\t\t\toverwrite: overwrite\n\t\t\t};\n\t\t\tthis.nextToMove = -color; // Update next to move\n\t\t\tthis.moveNumber++; // Increment move number\n\t\t\treturn true;\n\t\t}; // END func root.playMove\n\n\t\t// Check for and perform capture of opposite color chain at (x, y)\n\t\tfunction captureStones(board, x, y, color, captures) {\n\t\t\tvar pending = [],\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!recursiveCapture(board, x, y, color, pending)) { // Captured chain found\n\t\t\t\tfor (i = 0; i < pending.length; i++) { // Remove captured stones\n\t\t\t\t\tsetStone(board, pending[i].x, pending[i].y, EMPTY);\n\t\t\t\t\tcaptures.push(pending[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Recursively builds a chain of pending captures starting from (x, y)\n\t\t// Stops and returns true if chain has liberties\n\t\tfunction recursiveCapture(board, x, y, color, pending) {\n\t\t\tvar i; // Scratch iteration variable\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Stop if out of bounds\n\t\t\t}\n\t\t\tif (board.getStone(x, y) === color) {\n\t\t\t\treturn false; // Stop if other color found\n\t\t\t}\n\t\t\tif (!board.getStone(x, y)) {\n\t\t\t\treturn true; // Stop and signal that liberty was found\n\t\t\t}\n\t\t\tfor (i = 0; i < pending.length; i++) {\n\t\t\t\tif (pending[i].x === x && pending[i].y === y) {\n\t\t\t\t\treturn false; // Stop if already in pending captures\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpending.push({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t}); // Add new stone into chain of pending captures\n\n\t\t\t// Recursively check for liberties and expand chain\n\t\t\tif (recursiveCapture(board, x - 1, y, color, pending) ||\n\t\t\t\trecursiveCapture(board, x + 1, y, color, pending) ||\n\t\t\t\trecursiveCapture(board, x, y - 1, color, pending) ||\n\t\t\t\trecursiveCapture(board, x, y + 1, color, pending)) {\n\t\t\t\treturn true; // Stop and signal liberty found in subchain\n\t\t\t}\n\t\t\treturn false; // Otherwise, no liberties found\n\t\t}\n\n\t\t// Places a setup stone, returns true if successful\n\t\troot.placeSetup = function(x, y, color) {\n\t\t\tvar prevColor = (this.parent && this.parent.getStone(x, y)) || EMPTY;\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Do not allow out of bounds setup\n\t\t\t}\n\t\t\tif (!this.isMutable('setup') || this.getStone(x, y) === color) {\n\t\t\t\t// Prevent setup changes in immutable node or quit early if no change\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsetStone(this, x, y, color); // Place the setup stone\n\t\t\tthis.setupStones[fromXY(x, y)] = color - prevColor; // Record the necessary change\n\t\t\treturn true;\n\t\t};\n\n\t\t// Adds markup, returns true if successful\n\t\troot.addMarkup = function(x, y, mark) {\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Do not allow out of bounds markup\n\t\t\t}\n\t\t\tif (this.getMarkup(x, y) === mark) { // Quit early if no change to make\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.markup[fromXY(x, y)] = mark;\n\t\t\treturn true;\n\t\t};\n\n\t\t// Returns the stone status of the given position\n\t\troot.getStone = function(x, y) {\n\t\t\treturn this['board' + x + '-' + y] || EMPTY;\n\t\t};\n\n\t\t// Directly sets the stone state for the given game node\n\t\tfunction setStone(node, x, y, color) {\n\t\t\tnode['board' + x + '-' + y] = color;\n\t\t}\n\n\t\t// Gets the setup stone placed at (x, y), returns false if none\n\t\troot.getSetup = function(x, y) {\n\t\t\tif (!this.setupStones[fromXY(x, y)]) { // No setup stone placed\n\t\t\t\treturn false;\n\t\t\t} else { // Determine net effect of setup stone\n\t\t\t\tswitch (this.getStone(x, y)) {\n\t\t\t\t\tcase EMPTY:\n\t\t\t\t\t\treturn 'AE';\n\t\t\t\t\tcase BLACK:\n\t\t\t\t\t\treturn 'AB';\n\t\t\t\t\tcase WHITE:\n\t\t\t\t\t\treturn 'AW';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Gets the markup at (x, y)\n\t\troot.getMarkup = function(x, y) {\n\t\t\treturn this.markup[fromXY(x, y)] || EMPTY;\n\t\t};\n\n\t\t// Determines the type of this node\n\t\troot.getType = function() {\n\t\t\tvar i;\n\n\t\t\tif (this.move) { // Logged move implies move node\n\t\t\t\treturn 'move';\n\t\t\t}\n\n\t\t\tfor (i = 0; i < this.setupStones.length; i++) {\n\t\t\t\tif (this.setupStones[i]) { // Any setup stones implies setup node\n\t\t\t\t\treturn 'setup';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'empty'; // Otherwise, \"empty\" (neither move nor setup)\n\t\t};\n\n\t\t// Checks if this node can be modified by a 'type' action\n\t\troot.isMutable = function(type) {\n\t\t\t// Can only add a move to an empty node with no children\n\t\t\tif (type === 'move' && this.getType() === 'empty' && this.children.length === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Can only add setup stones to a non-move node with no children\n\t\t\tif (type === 'setup' && this.getType() !== 'move' && this.children.length === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// Gets siblings of this node\n\t\troot.getSiblings = function() {\n\t\t\treturn (this.parent && this.parent.children) || [];\n\t\t};\n\n\t\t// Makes a child node of this node, but does NOT add it to children\n\t\troot.makeChild = function() {\n\t\t\tvar child = Object.create(this); // Child inherits properties\n\t\t\tinitNode(child, this); // Initialize other properties\n\n\t\t\treturn child;\n\t\t};\n\n\t\t// Adds a child to this node\n\t\troot.addChild = function(child) {\n\t\t\tthis.children.push(child);\n\t\t};\n\n\t\t// Remove child node from this node, returning false if failed\n\t\troot.removeChild = function(child) {\n\t\t\tvar i = this.children.indexOf(child);\n\t\t\tif (i !== -1) {\n\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// Gets board size\n\t\troot.getSize = function() {\n\t\t\treturn {\n\t\t\t\tx: sizeX,\n\t\t\t\ty: sizeY\n\t\t\t};\n\t\t};\n\n\t\treturn root;\n\n\t\t// Convert (x, y) coordinates to linear index\n\t\tfunction fromXY(x, y) {\n\t\t\treturn (x - 1) * sizeY + (y - 1);\n\t\t}\n\t};\n\t// Load a parsed SGF object into a game state tree\n\tbesogo.loadSgf = function(sgf, editor) {\n\t\t'use strict';\n\t\tvar size = {\n\t\t\t\tx: 19,\n\t\t\t\ty: 19\n\t\t\t}, // Default size (may be changed by load)\n\t\t\troot;\n\n\t\tloadRootProps(sgf); // Load size, variants style and game info\n\t\troot = besogo.makeGameRoot(size.x, size.y);\n\n\t\tloadNodeTree(sgf, root); // Load the rest of game tree\n\t\teditor.loadRoot(root); // Load root into the editor\n\n\n\t\t// Loads the game tree\n\t\tfunction loadNodeTree(sgfNode, gameNode) {\n\t\t\tvar i, nextGameNode;\n\n\t\t\t// Load properties from the SGF node into the game state node\n\t\t\tfor (i = 0; i < sgfNode.props.length; i++) {\n\t\t\t\tloadProp(gameNode, sgfNode.props[i]);\n\t\t\t}\n\n\t\t\t// Recursively load the rest of the tree\n\t\t\tfor (i = 0; i < sgfNode.children.length; i++) {\n\t\t\t\tnextGameNode = gameNode.makeChild();\n\t\t\t\tgameNode.addChild(nextGameNode);\n\t\t\t\tloadNodeTree(sgfNode.children[i], nextGameNode);\n\t\t\t}\n\t\t}\n\n\t\t// Loads property into node\n\t\tfunction loadProp(node, prop) {\n\t\t\tvar setupFunc = 'placeSetup',\n\t\t\t\tmarkupFunc = 'addMarkup',\n\t\t\t\tmove;\n\n\t\t\tswitch (prop.id) {\n\t\t\t\tcase 'B': // Play a black move\n\t\t\t\t\tmove = lettersToCoords(prop.values[0]);\n\t\t\t\t\tnode.playMove(move.x, move.y, -1, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W': // Play a white move\n\t\t\t\t\tmove = lettersToCoords(prop.values[0]);\n\t\t\t\t\tnode.playMove(move.x, move.y, 1, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AB': // Setup black stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AW': // Setup white stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AE': // Setup empty stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'CR': // Add circle markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SQ': // Add square markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'TR': // Add triangle markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M': // Intentional fallthrough treats 'M' as 'MA'\n\t\t\t\tcase 'MA': // Add 'X' cross markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SL': // Add 'selected' (small filled square) markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 5);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L': // Intentional fallthrough treats 'L' as 'LB'\n\t\t\t\tcase 'LB': // Add label markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 'label');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C': // Comment placed on node\n\t\t\t\t\tif (node.comment) {\n\t\t\t\t\t\tnode.comment += '\\n' + prop.values.join().trim();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.comment = prop.values.join().trim();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} // END function loadProp\n\n\t\t// Extracts point list and calls func on each\n\t\t// Set param to 'label' to signal handling of label markup property\n\t\tfunction applyPointList(values, node, func, param) {\n\t\t\tvar i, x, y, // Scratch iteration variables\n\t\t\t\tpoint, // Current point in iteration\n\t\t\t\totherPoint, // Bottom-right point of compressed point lists\n\t\t\t\tlabel; // Label extracted from value\n\t\t\tfor (i = 0; i < values.length; i++) {\n\t\t\t\tpoint = lettersToCoords(values[i].slice(0, 2));\n\t\t\t\tif (param === 'label') { // Label markup property\n\t\t\t\t\tlabel = values[i].slice(3).replace(/\\n/g, ' ');\n\t\t\t\t\tnode[func](point.x, point.y, label); // Apply with extracted label\n\t\t\t\t} else { // Not a label markup property\n\t\t\t\t\tif (values[i].charAt(2) === ':') { // Expand compressed point list\n\t\t\t\t\t\totherPoint = lettersToCoords(values[i].slice(3));\n\t\t\t\t\t\tif (otherPoint.x === point.x && otherPoint.y === point.y) {\n\t\t\t\t\t\t\t// Redundant compressed pointlist\n\t\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t\t} else if (otherPoint.x < point.x || otherPoint.y < point.y) {\n\t\t\t\t\t\t\t// Only apply to corners if not arranged properly\n\t\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t\t\tnode[func](otherPoint.x, otherPoint.y, param);\n\t\t\t\t\t\t} else { // Iterate over the compressed points\n\t\t\t\t\t\t\tfor (x = point.x; x <= otherPoint.x; x++) {\n\t\t\t\t\t\t\t\tfor (y = point.y; y <= otherPoint.y; y++) {\n\t\t\t\t\t\t\t\t\tnode[func](x, y, param);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // Apply on single point\n\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function applyPointList\n\n\t\t// Loads root properties (size, variant style and game info)\n\t\tfunction loadRootProps(node) {\n\t\t\tvar gameInfoIds = ['PB', 'BR', 'BT', 'PW', 'WR', 'WT', // Player info\n\t\t\t\t\t'HA', 'KM', 'RU', 'TM', 'OT', // Game parameters\n\t\t\t\t\t'DT', 'EV', 'GN', 'PC', 'RO', // Event info\n\t\t\t\t\t'GC', 'ON', 'RE', // General comments\n\t\t\t\t\t'AN', 'CP', 'SO', 'US'\n\t\t\t\t], // IP credits\n\t\t\t\tgameInfo = {}, // Structure for game info properties\n\t\t\t\ti, id, value; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < node.props.length; i++) {\n\t\t\t\tid = node.props[i].id; // Property ID\n\t\t\t\tvalue = node.props[i].values.join().trim(); // Join the values array\n\t\t\t\tif (id === 'SZ') { // Size property\n\t\t\t\t\tsize = besogo.parseSize(value);\n\t\t\t\t} else if (id === 'ST') { // Style property\n\t\t\t\t\teditor.setVariantStyle(+value); // Converts value to number\n\t\t\t\t} else if (gameInfoIds.indexOf(id) !== -1) { // Game info property\n\t\t\t\t\tif (id !== 'GC') { // Treat all but GC as simpletext\n\t\t\t\t\t\tvalue = value.replace(/\\n/g, ' '); // Convert line breaks to spaces\n\t\t\t\t\t}\n\t\t\t\t\tif (value) { // Skip load of empty game info strings\n\t\t\t\t\t\tgameInfo[id] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teditor.setGameInfo(gameInfo);\n\t\t}\n\n\t\t// Converts letters to numerical coordinates\n\t\tfunction lettersToCoords(letters) {\n\t\t\tif (letters.match(/^[A-Za-z]{2}$/)) { // Verify input is two letters\n\t\t\t\treturn {\n\t\t\t\t\tx: charToNum(letters.charAt(0)),\n\t\t\t\t\ty: charToNum(letters.charAt(1))\n\t\t\t\t};\n\t\t\t} else { // Anything but two letters\n\t\t\t\treturn {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t}; // Return (0, 0) coordinates\n\t\t\t}\n\t\t}\n\n\t\tfunction charToNum(c) { // Helper for lettersToCoords\n\t\t\tif (c.match(/[A-Z]/)) { // Letters A-Z to 27-52\n\t\t\t\treturn c.charCodeAt(0) - 'A'.charCodeAt(0) + 27;\n\t\t\t} else { // Letters a-z to 1-26\n\t\t\t\treturn c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n\t\t\t}\n\t\t}\n\t};\n\tbesogo.makeNamesPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar playerBox = document.createElement('div'),\n\t\t\twhiteBox = document.createElement('div'),\n\t\t\tblackBox = document.createElement('div'),\n\t\t\twhiteInfo = document.createTextNode(''),\n\t\t\tblackInfo = document.createTextNode(''),\n\t\t\twhiteCaps = document.createElement('span'),\n\t\t\tblackCaps = document.createElement('span');\n\n\t\tplayerBox.className = 'besogo-playerInfo';\n\t\twhiteBox.className = 'besogo-whiteInfo';\n\t\tblackBox.className = 'besogo-blackInfo';\n\t\twhiteCaps.className = 'besogo-whiteCaps';\n\t\twhiteCaps.title = 'White captures';\n\t\tblackCaps.className = 'besogo-blackCaps';\n\t\tblackCaps.title = 'Black captures';\n\t\twhiteBox.appendChild(whiteInfo);\n\t\twhiteBox.appendChild(whiteCaps);\n\t\tblackBox.appendChild(blackInfo);\n\t\tblackBox.appendChild(blackCaps);\n\t\tplayerBox.appendChild(whiteBox);\n\t\tplayerBox.appendChild(blackBox);\n\t\tcontainer.appendChild(playerBox);\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tgameInfo: editor.getGameInfo()\n\t\t});\n\n\t\tfunction update(msg) {\n\t\t\tvar infoString, // Scratch string\n\t\t\t\ttextNode,\n\t\t\t\tcurrent,\n\t\t\t\tpassFlag = 0;\n\n\t\t\tif (msg.gameInfo) {\n\t\t\t\tinfoString = (msg.gameInfo.PW || 'White') + // White name\n\t\t\t\t\t' (' + (msg.gameInfo.WR || '?') + ')' + // White rank\n\t\t\t\t\t(msg.gameInfo.WT ? ' ' + msg.gameInfo.WT : ''); // White team\n\t\t\t\ttextNode = document.createTextNode(infoString);\n\t\t\t\twhiteBox.replaceChild(textNode, whiteInfo);\n\t\t\t\twhiteInfo = textNode;\n\n\t\t\t\tinfoString = (msg.gameInfo.PB || 'Black') + // Black name\n\t\t\t\t\t' (' + (msg.gameInfo.BR || '?') + ')' + // Black rank\n\t\t\t\t\t(msg.gameInfo.BT ? ' ' + msg.gameInfo.BT : ''); // Black team\n\t\t\t\ttextNode = document.createTextNode(infoString);\n\t\t\t\tblackBox.replaceChild(textNode, blackInfo);\n\t\t\t\tblackInfo = textNode;\n\t\t\t}\n\n\t\t\tif (msg.navChange || msg.stoneChange) {\n\t\t\t\tcurrent = editor.getCurrent();\n\t\t\t\tif (current.move && current.move.x === 0 && current.move.y === 0) {\n\t\t\t\t\tpassFlag = current.move.color;\n\t\t\t\t}\n\t\t\t\tupdateText(whiteCaps, (passFlag === 1 ? 'Passed  ' : '') + current.whiteCaps);\n\t\t\t\tupdateText(blackCaps, current.blackCaps + (passFlag === -1 ? '  Passed' : ''));\n\t\t\t}\n\t\t}\n\n\t\tfunction updateText(parent, text) {\n\t\t\tvar textNode = document.createTextNode(text);\n\t\t\twhile (parent.firstChild) {\n\t\t\t\tparent.removeChild(parent.firstChild);\n\t\t\t}\n\t\t\tparent.appendChild(textNode);\n\t\t}\n\t};\n\tbesogo.parseSgf = function(text) {\n\t\t'use strict';\n\t\tvar at = 0, // Current position\n\t\t\tch = text.charAt(at); // Current character at position\n\n\t\tfindOpenParens(); // Find beginning of game tree\n\t\treturn parseTree(); // Parse game tree\n\n\t\t// Builds and throws an error\n\t\tfunction error(msg) {\n\t\t\tthrow {\n\t\t\t\tname: \"Syntax Error\",\n\t\t\t\tmessage: msg,\n\t\t\t\tat: at,\n\t\t\t\ttext: text\n\t\t\t};\n\t\t}\n\n\t\t// Advances text position by one\n\t\tfunction next(check) {\n\t\t\tif (check && check !== ch) { // Verify current character if param given\n\t\t\t\terror(\"Expected '\" + check + \"' instead of '\" + ch + \"'\");\n\t\t\t}\n\t\t\tat++;\n\t\t\tch = text.charAt(at);\n\t\t\treturn ch;\n\t\t}\n\n\t\t// Skips over whitespace until non-whitespace found\n\t\tfunction white() {\n\t\t\twhile (ch && ch <= ' ') {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t\t// Skips all chars until '(' or end found\n\t\tfunction findOpenParens() {\n\t\t\twhile (ch && ch !== '(') {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t\t// Returns true if line break (CR, LF, CR+LF, LF+CR) found\n\t\t// Advances the cursor ONCE for double character (CR+LF, LF+CR) line breaks\n\t\tfunction lineBreak() {\n\t\t\tif (ch === '\\n') { // Line Feed (LF)\n\t\t\t\tif (text.charAt(at + 1) === '\\r') { // LF+CR, double character line break\n\t\t\t\t\tnext(); // Advance cursor only once (pointing at second character)\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (ch === '\\r') { // Carriage Return (CR)\n\t\t\t\tif (text.charAt(at + 1) === '\\n') { // CR+LF, double character line break\n\t\t\t\t\tnext(); // Advance cursor only once (pointing at second character)\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false; // Did not find a line break or advance\n\t\t}\n\n\t\t// Parses a sub-tree of the game record\n\t\tfunction parseTree() {\n\t\t\tvar rootNode, // Root of this sub-tree\n\t\t\t\tcurrentNode, // Pointer to parent of the next node\n\t\t\t\tnextNode; // Scratch for parsing the next node or sub-tree\n\n\t\t\tnext('('); // Double-check opening parens at start of sub-tree\n\t\t\twhite(); // Skip whitespace before root node\n\n\t\t\tif (ch !== \";\") { // Error on sub-tree missing root node\n\t\t\t\terror(\"Sub-tree missing root\");\n\t\t\t}\n\t\t\trootNode = parseNode(); // Get the first node of this sub-tree\n\t\t\twhite(); // Skip whitespace before parsing next node\n\n\t\t\tcurrentNode = rootNode; // Parent of the next node parsed\n\t\t\twhile (ch === ';') { // Get sequence of nodes within this sub-tree\n\t\t\t\tnextNode = parseNode(); // Parse the next node\n\t\t\t\t// Add next node as child of current\n\t\t\t\tcurrentNode.children.push(nextNode);\n\t\t\t\tcurrentNode = nextNode; // Advance current pointer to this child\n\t\t\t\twhite(); // Skip whitespace between/after sequence nodes\n\t\t\t}\n\n\t\t\t// Look for sub-trees of this sub-tree\n\t\t\twhile (ch === \"(\") {\n\t\t\t\tnextNode = parseTree(); // Parse the next sub-tree\n\t\t\t\t// Add sub-tree as child of last sequence node\n\t\t\t\tcurrentNode.children.push(nextNode); // Do NOT advance current\n\t\t\t\twhite(); // Skip whitespace between/after sub-trees\n\t\t\t}\n\t\t\tnext(')'); // Expect closing parenthesis at end of this sub-tree\n\n\t\t\treturn rootNode;\n\t\t}\n\n\t\t// Parses a node and its properties\n\t\tfunction parseNode() {\n\t\t\tvar property, // Scratch for parsing properties\n\t\t\t\tnode = {\n\t\t\t\t\tprops: [],\n\t\t\t\t\tchildren: []\n\t\t\t\t}; // Node to construct\n\n\t\t\tnext(';'); // Double-check semi-colon at start of node\n\t\t\twhite(); // Skip whitespace before properties\n\t\t\t// Parse properties until end of node detected\n\t\t\twhile (ch && ch !== ';' && ch !== '(' && ch !== ')') {\n\t\t\t\tproperty = parseProperty(); // Parse the property and values\n\t\t\t\tnode.props.push(property); // Add property to node\n\t\t\t\twhite(); // Skip whitespace between/after properties\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\n\t\t// Parses a property and its values\n\t\tfunction parseProperty() {\n\t\t\tvar property = {\n\t\t\t\tid: '',\n\t\t\t\tvalues: []\n\t\t\t}; // Property to construct\n\n\t\t\t// Look for property ID within letters\n\t\t\twhile (ch && /[A-Za-z]/.test(ch)) {\n\t\t\t\tif (/[A-Z]/.test(ch)) { // Ignores lower case letters\n\t\t\t\t\tproperty.id += ch; // Only adds upper case letters\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t}\n\t\t\tif (!property.id) { // Error if id empty\n\t\t\t\terror('Missing property ID');\n\t\t\t}\n\n\t\t\twhite(); // Skip whitespace before values\n\t\t\twhile (ch === '[') { // Look for values of this property\n\t\t\t\tproperty.values.push(parseValue());\n\t\t\t\twhite(); // Skip whitespace between/after values\n\t\t\t}\n\t\t\tif (property.values.length === 0) { // Error on empty list of values\n\t\t\t\terror('Missing property values');\n\t\t\t}\n\n\t\t\treturn property;\n\t\t}\n\n\t\t// Parses a value\n\t\tfunction parseValue() {\n\t\t\tvar value = '';\n\t\t\tnext('['); // Double-check opening bracket at start of value\n\n\t\t\t// Read until end of value (unescaped closing bracket)\n\t\t\twhile (ch && ch !== ']') {\n\t\t\t\tif (ch === '\\\\') { // Backslash escape handling\n\t\t\t\t\tnext('\\\\');\n\t\t\t\t\tif (lineBreak()) { // Soft (escaped) line break\n\t\t\t\t\t\t// Nothing, soft line breaks are removed\n\t\t\t\t\t} else if (ch <= ' ') { // Other whitespace\n\t\t\t\t\t\tvalue += ' '; // Convert to space\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += ch; // Pass other escaped characters verbatim\n\t\t\t\t\t}\n\t\t\t\t} else { // Non-escaped character\n\t\t\t\t\tif (lineBreak()) { // Hard (non-escaped) line break\n\t\t\t\t\t\tvalue += '\\n'; // Convert all new lines to just LF\n\t\t\t\t\t} else if (ch <= ' ') { // Other whitespace\n\t\t\t\t\t\tvalue += ' '; // Convert to space\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += ch; // Other characters\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t}\n\t\t\tnext(']'); // Expect closing bracket at end of value\n\n\t\t\treturn value;\n\t\t}\n\t};\n\t// Convert game state tree into SGF string\n\tbesogo.composeSgf = function(editor) {\n\t\t'use strict';\n\t\treturn '(' + composeNode(editor.getRoot()) + ')';\n\n\t\t// Recursively composes game node tree\n\t\tfunction composeNode(tree) {\n\t\t\tvar string = ';', // Node starts with semi-colon\n\t\t\t\tchildren = tree.children,\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!tree.parent) { // Null parent means node is root\n\t\t\t\t// Compose root-specific properties\n\t\t\t\tstring += composeRootProps(tree);\n\t\t\t}\n\t\t\tstring += composeNodeProps(tree); // Compose general properties\n\n\t\t\t// Recurse composition on child nodes\n\t\t\tif (children.length === 1) { // Continue sequence if only one child\n\t\t\t\tstring += '\\n' + composeNode(children[0]);\n\t\t\t} else if (children.length > 1) {\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tstring += '\\n(' + composeNode(children[i]) + ')';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn string;\n\t\t}\n\n\t\t// Composes root specific properties\n\t\tfunction composeRootProps(tree) {\n\t\t\tvar string = 'FF[4]GM[1]CA[UTF-8]AP[besogo:' + besogo.VERSION + ']',\n\t\t\t\tx = tree.getSize().x,\n\t\t\t\ty = tree.getSize().y,\n\t\t\t\tgameInfo = editor.getGameInfo(), // Game info structure\n\t\t\t\thasGameInfo = false, // Flag for existence of game info\n\t\t\t\tid; // Scratch iteration variable\n\n\t\t\tif (x === y) { // Square board size\n\t\t\t\tstring += 'SZ[' + x + ']';\n\t\t\t} else { // Non-square board size\n\t\t\t\tstring += 'SZ[' + x + ':' + y + ']';\n\t\t\t}\n\t\t\tstring += 'ST[' + editor.getVariantStyle() + ']\\n'; // Line break after header\n\n\t\t\tfor (id in gameInfo) { // Compose game info properties\n\t\t\t\tif (gameInfo.hasOwnProperty(id) && gameInfo[id]) { // Skip empty strings\n\t\t\t\t\tstring += id + '[' + escapeText(gameInfo[id]) + ']';\n\t\t\t\t\thasGameInfo = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += (hasGameInfo ? '\\n' : ''); // Line break if game info exists\n\n\t\t\treturn string;\n\t\t}\n\n\t\t// Composes other properties\n\t\tfunction composeNodeProps(node) {\n\t\t\tvar string = '',\n\t\t\t\tprops, // Scratch variable for property structures\n\t\t\t\tstone, i, j; // Scratch iteration variables\n\n\t\t\t// Compose either move or setup properties depending on type of node\n\t\t\tif (node.getType() === 'move') { // Compose move properties\n\t\t\t\tstone = node.move;\n\t\t\t\tstring += (stone.color === 1) ? 'W' : 'B';\n\t\t\t\tstring += '[' + coordsToLetters(stone.x, stone.y) + ']';\n\t\t\t} else if (node.getType() === 'setup') { // Compose setup properties\n\t\t\t\tprops = {\n\t\t\t\t\tAB: [],\n\t\t\t\t\tAW: [],\n\t\t\t\t\tAE: []\n\t\t\t\t};\n\t\t\t\tfor (i = 1; i <= node.getSize().x; i++) {\n\t\t\t\t\tfor (j = 1; j <= node.getSize().y; j++) {\n\t\t\t\t\t\tstone = node.getSetup(i, j);\n\t\t\t\t\t\tif (stone) { // If setup stone placed, add to structure\n\t\t\t\t\t\t\tprops[stone].push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstring += composePointLists(props);\n\t\t\t}\n\n\t\t\t// Compose markup properties\n\t\t\tprops = {\n\t\t\t\tCR: [],\n\t\t\t\tSQ: [],\n\t\t\t\tTR: [],\n\t\t\t\tMA: [],\n\t\t\t\tSL: [],\n\t\t\t\tLB: []\n\t\t\t};\n\t\t\tfor (i = 1; i <= node.getSize().x; i++) {\n\t\t\t\tfor (j = 1; j <= node.getSize().y; j++) {\n\t\t\t\t\tstone = node.getMarkup(i, j);\n\t\t\t\t\tif (stone) { // If markup placed\n\t\t\t\t\t\tif (typeof stone === 'string') { // String is label mark\n\t\t\t\t\t\t\tprops.LB.push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j,\n\t\t\t\t\t\t\t\tlabel: stone\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else { // Numerical code for markup\n\t\t\t\t\t\t\t// Convert numerical code to property ID\n\t\t\t\t\t\t\tstone = (['CR', 'SQ', 'TR', 'MA', 'SL'])[stone - 1];\n\t\t\t\t\t\t\tprops[stone].push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += composePointLists(props);\n\n\t\t\tif (node.comment) { // Compose comment property\n\t\t\t\tstring += (string ? '\\n' : ''); // Add line break if other properties exist\n\t\t\t\tstring += 'C[' + escapeText(node.comment) + ']';\n\t\t\t}\n\n\t\t\treturn string;\n\t\t} // END function composeNodeProps\n\n\t\t// Composes properties from structure of point lists\n\t\t// Each member should be an array of points for property ID = key\n\t\t// Each point should specify point with (x, y) and may have optional label\n\t\tfunction composePointLists(lists) {\n\t\t\tvar string = '',\n\t\t\t\tid, points, i; // Scratch iteration variables\n\n\t\t\tfor (id in lists) { // Object own keys specifies property IDs\n\t\t\t\tif (lists.hasOwnProperty(id)) {\n\t\t\t\t\tpoints = lists[id]; // Corresponding members are point lists\n\t\t\t\t\tif (points.length > 0) { // Only add property if list non-empty\n\t\t\t\t\t\tstring += id;\n\t\t\t\t\t\tfor (i = 0; i < points.length; i++) {\n\t\t\t\t\t\t\tstring += '[' + coordsToLetters(points[i].x, points[i].y);\n\t\t\t\t\t\t\tif (points[i].label) { // Add optional composed label\n\t\t\t\t\t\t\t\tstring += ':' + escapeText(points[i].label);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstring += ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\n\t\t// Escapes backslash and close bracket for text output\n\t\tfunction escapeText(input) {\n\t\t\tinput = input.replace(/\\\\/g, '\\\\\\\\'); // Escape backslash\n\t\t\treturn input.replace(/\\]/g, '\\\\]'); // Escape close bracket\n\t\t}\n\n\t\t// Converts numerical coordinates to letters\n\t\tfunction coordsToLetters(x, y) {\n\t\t\tif (x === 0 || y === 0) {\n\t\t\t\treturn '';\n\t\t\t} else {\n\t\t\t\treturn numToChar(x) + numToChar(y);\n\t\t\t}\n\t\t}\n\n\t\tfunction numToChar(num) { // Helper for coordsToLetters\n\t\t\tif (num > 26) { // Numbers 27-52 to A-Z\n\t\t\t\treturn String.fromCharCode('A'.charCodeAt(0) + num - 27);\n\t\t\t} else { // Numbers 1-26 to a-z\n\t\t\t\treturn String.fromCharCode('a'.charCodeAt(0) + num - 1);\n\t\t\t}\n\t\t}\n\t};\n\t(function() {\n\t\t'use strict';\n\n\t\t// Color palette\n\t\tbesogo.RED = '#be0119'; // Darker red (marked variant)\n\t\tbesogo.LRED = '#ff474c'; // Lighter red (auto-marked variant)\n\t\tbesogo.BLUE = '#0165fc'; // Bright blue (last move)\n\t\tbesogo.PURP = '#9a0eea'; // Red + blue (variant + last move)\n\t\tbesogo.GREY = '#929591'; // Between white and black\n\t\tbesogo.GOLD = '#dbb40c'; // Tool selection\n\t\tbesogo.TURQ = '#06c2ac'; // Turqoise (nav selection)\n\n\t\tbesogo.BLACK_STONES = 4; // Number of black stone images\n\t\tbesogo.WHITE_STONES = 11; // Number of white stone images\n\n\t\t// Makes an SVG element with given name and attributes\n\t\tbesogo.svgEl = function(name, attributes) {\n\t\t\tvar attr, // Scratch iteration variable\n\t\t\t\telement = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n\n\t\t\tfor (attr in (attributes || {})) { // Add attributes if supplied\n\t\t\t\tif (attributes.hasOwnProperty(attr)) {\n\t\t\t\t\telement.setAttribute(attr, attributes[attr]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn element;\n\t\t};\n\n\t\t// Makes an SVG group for containing the shadow layer\n\t\tbesogo.svgShadowGroup = function() {\n\t\t\tvar group = besogo.svgEl('g'),\n\t\t\t\tfilter = besogo.svgEl('filter', {\n\t\t\t\t\tid: 'blur'\n\t\t\t\t}),\n\t\t\t\tblur = besogo.svgEl('feGaussianBlur', {\n\t\t\t\t\tin: 'SourceGraphic',\n\t\t\t\t\tstdDeviation: '2'\n\t\t\t\t});\n\n\t\t\tfilter.appendChild(blur);\n\t\t\tgroup.appendChild(filter);\n\t\t\treturn group;\n\t\t};\n\n\t\t// Makes a stone shadow\n\t\tbesogo.svgShadow = function(x, y) {\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 43,\n\t\t\t\tstroke: 'none',\n\t\t\t\tfill: 'black',\n\t\t\t\topacity: 0.32,\n\t\t\t\tfilter: 'url(#blur)'\n\t\t\t});\n\t\t};\n\n\t\t// Makes a photo realistic stone element\n\t\tbesogo.realStone = function(x, y, color, index) {\n\t\t\tvar element;\n\n\t\t\tif (color < 0) {\n\t\t\t\tcolor = 'black' + (index % besogo.BLACK_STONES);\n\t\t\t} else {\n\t\t\t\tcolor = 'white' + (index % besogo.WHITE_STONES);\n\t\t\t}\n\t\t\tcolor = '_' + color + '.png';\n\n\t\t\telement = besogo.svgEl(\"image\", {\n\t\t\t\tx: (x - 44),\n\t\t\t\ty: (y - 44),\n\t\t\t\theight: 88,\n\t\t\t\twidth: 88\n\t\t\t});\n\t\t\telement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', color);\n\n\t\t\treturn element;\n\t\t};\n\n\t\t// Makes a stone element\n\t\tbesogo.svgStone = function(x, y, color) {\n\t\t\tvar className = \"besogo-svg-greyStone\"; // Grey stone by default\n\n\t\t\tif (color === -1) { // Black stone\n\t\t\t\tclassName = \"besogo-svg-blackStone\";\n\t\t\t} else if (color === 1) { // White stone\n\t\t\t\tclassName = \"besogo-svg-whiteStone\";\n\t\t\t}\n\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 42,\n\t\t\t\t'class': className\n\t\t\t});\n\t\t};\n\n\t\t// Makes a circle at (x, y)\n\t\tbesogo.svgCircle = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 27,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes a square at (x, y)\n\t\tbesogo.svgSquare = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: (x - 23),\n\t\t\t\ty: (y - 23),\n\t\t\t\twidth: 46,\n\t\t\t\theight: 46,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an equilateral triangle at (x, y)\n\t\tbesogo.svgTriangle = function(x, y, color) {\n\t\t\t// Approximates an equilateral triangle centered on (x, y)\n\t\t\tvar pointString = \"\" + x + \",\" + (y - 30) + \" \" +\n\t\t\t\t(x - 26) + \",\" + (y + 15) + \" \" +\n\t\t\t\t(x + 26) + \",\" + (y + 15);\n\n\t\t\treturn besogo.svgEl(\"polygon\", {\n\t\t\t\tpoints: pointString,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an \"X\" cross at (x, y)\n\t\tbesogo.svgCross = function(x, y, color) {\n\t\t\tvar path = \"m\" + (x - 24) + \",\" + (y - 24) + \"l48,48m0,-48l-48,48\";\n\n\t\t\treturn besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an \"+\" plus sign at (x, y)\n\t\tbesogo.svgPlus = function(x, y, color) {\n\t\t\tvar path = \"m\" + x + \",\" + (y - 28) + \"v56m-28,-28h56\";\n\n\t\t\treturn besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes a small filled square at (x, y)\n\t\tbesogo.svgBlock = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: x - 18,\n\t\t\t\ty: y - 18,\n\t\t\t\twidth: 36,\n\t\t\t\theight: 36,\n\t\t\t\tstroke: \"none\",\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: color\n\t\t\t});\n\t\t};\n\n\t\t// Makes a label at (x, y)\n\t\tbesogo.svgLabel = function(x, y, color, label) {\n\t\t\tvar element,\n\t\t\t\tsize;\n\n\t\t\t// Trims label to 3 characters\n\t\t\tif (label.length > 3) {\n\t\t\t\tlabel = label.slice(0, 2) + '';\n\t\t\t}\n\n\t\t\t// Set font size according to label length\n\t\t\tswitch (label.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsize = 72;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsize = 56;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsize = 36;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\telement = besogo.svgEl(\"text\", {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tdy: \".65ex\", // Seems to work for vertically centering these fonts\n\t\t\t\t\"font-size\": size,\n\t\t\t\t\"text-anchor\": \"middle\", // Horizontal centering\n\t\t\t\t\"font-family\": \"Helvetica, Arial, sans-serif\",\n\t\t\t\tfill: color\n\t\t\t});\n\t\t\telement.appendChild(document.createTextNode(label));\n\n\t\t\treturn element;\n\t\t};\n\n\t})(); // END closure\n\tbesogo.makeToolPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar element, // Scratch for building SVG images\n\t\t\tsvg, // Scratch for building SVG images\n\t\t\tlabelText, // Text area for next label input\n\t\t\tselectors = {}, // Holds selection rects\n\t\t\tpassButton = document.createElement('input'),\n\t\t\tcutButton = document.createElement('input');\n\n\t\tsvg = makeButtonSVG('auto', 'Auto-play/nav'); // Auto-play/nav tool button\n\t\tsvg.appendChild(makeYinYang(0, 0));\n\n\t\tsvg = makeButtonSVG('playB', 'Play black'); // Play black button\n\t\tsvg.appendChild(besogo.svgStone(0, 0, -1));\n\n\t\tsvg = makeButtonSVG('playW', 'Play white'); // Play white button\n\t\tsvg.appendChild(besogo.svgStone(0, 0, 1));\n\n\t\tsvg = makeButtonSVG('addB', 'Set black'); // Add black button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0, -1)); // Black stone\n\t\telement.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('addW', 'Set white'); // Add white button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0, 1)); // White stone\n\t\telement.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('addE', 'Set empty'); // Add empty button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0)); // Grey stone\n\t\telement.appendChild(besogo.svgCross(0, 0, besogo.RED)); // Red cross\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('circle', 'Circle'); // Circle markup button\n\t\tsvg.appendChild(besogo.svgCircle(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('square', 'Square'); // Square markup button\n\t\tsvg.appendChild(besogo.svgSquare(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('triangle', 'Triangle'); // Triangle markup button\n\t\tsvg.appendChild(besogo.svgTriangle(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('cross', 'Cross'); // Cross markup button\n\t\tsvg.appendChild(besogo.svgCross(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('block', 'Block'); // Block markup button\n\t\tsvg.appendChild(besogo.svgBlock(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('clrMark', 'Clear mark'); // Clear markup button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgTriangle(0, 0, besogo.GREY));\n\t\telement.appendChild(besogo.svgCross(0, 0, besogo.RED));\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('label', 'Label'); // Label markup button\n\t\tsvg.appendChild(besogo.svgLabel(0, 0, 'black', 'A1'));\n\n\t\tlabelText = document.createElement(\"input\"); // Label entry text field\n\t\tlabelText.type = \"text\";\n\t\tlabelText.title = 'Next label';\n\t\tlabelText.onblur = function() {\n\t\t\teditor.setLabel(labelText.value);\n\t\t};\n\t\tlabelText.addEventListener('keydown', function(evt) {\n\t\t\tevt = evt || window.event;\n\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t});\n\t\tcontainer.appendChild(labelText);\n\n\t\tpassButton.type = 'button';\n\t\tpassButton.value = 'Pass';\n\t\tpassButton.title = 'Pass move';\n\t\tpassButton.onclick = function() {\n\t\t\tvar tool = editor.getTool();\n\t\t\tif (tool !== 'navOnly' && tool !== 'auto' && tool !== 'playB' && tool !== 'playW') {\n\t\t\t\teditor.setTool('auto'); // Ensures that a move tool is selected\n\t\t\t}\n\t\t\teditor.click(0, 0, false); // Clicking off the board signals a pass\n\t\t};\n\t\tcontainer.appendChild(passButton);\n\n\t\tcutButton.type = 'button';\n\t\tcutButton.value = 'Cut';\n\t\tcutButton.title = 'Remove branch';\n\t\tcutButton.onclick = function() {\n\t\t\teditor.cutCurrent();\n\t\t};\n\t\tcontainer.appendChild(cutButton);\n\n\t\teditor.addListener(toolStateUpdate); // Set up listener for tool state updates\n\t\ttoolStateUpdate({\n\t\t\tlabel: editor.getLabel(),\n\t\t\ttool: editor.getTool()\n\t\t}); // Initialize\n\n\n\t\t// Creates a button holding an SVG image\n\t\tfunction makeButtonSVG(tool, tooltip) {\n\t\t\tvar button = document.createElement('button'),\n\t\t\t\tsvg = besogo.svgEl('svg', { // Icon container\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\theight: '100%',\n\t\t\t\t\tviewBox: '-55 -55 110 110'\n\t\t\t\t}), // Centered on (0, 0)\n\t\t\t\tselected = besogo.svgEl(\"rect\", { // Selection rectangle\n\t\t\t\t\tx: -50, // Center on (0, 0)\n\t\t\t\t\ty: -50,\n\t\t\t\t\twidth: 100,\n\t\t\t\t\theight: 100,\n\t\t\t\t\tfill: 'none',\n\t\t\t\t\t'stroke-width': 8,\n\t\t\t\t\tstroke: besogo.GOLD,\n\t\t\t\t\trx: 20, // Rounded rectangle\n\t\t\t\t\try: 20, // Thanks, Steve\n\t\t\t\t\tvisibility: 'hidden'\n\t\t\t\t});\n\n\t\t\tcontainer.appendChild(button);\n\t\t\tbutton.appendChild(svg);\n\t\t\tbutton.onclick = function() {\n\t\t\t\teditor.setTool(tool);\n\t\t\t};\n\t\t\tbutton.title = tooltip;\n\t\t\tselectors[tool] = selected;\n\t\t\tsvg.appendChild(selected);\n\t\t\treturn svg; // Returns reference to the icon container\n\t\t}\n\n\t\t// Callback for updating tool state and label\n\t\tfunction toolStateUpdate(msg) {\n\t\t\tvar tool;\n\t\t\tif (msg.label) {\n\t\t\t\tlabelText.value = msg.label;\n\t\t\t}\n\t\t\tif (msg.tool) {\n\t\t\t\tfor (tool in selectors) { // Update which tool is selected\n\t\t\t\t\tif (selectors.hasOwnProperty(tool)) {\n\t\t\t\t\t\tif (msg.tool === tool) {\n\t\t\t\t\t\t\tselectors[tool].setAttribute('visibility', 'visible');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselectors[tool].setAttribute('visibility', 'hidden');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draws a yin yang\n\t\tfunction makeYinYang(x, y) {\n\t\t\tvar element = besogo.svgEl('g');\n\n\t\t\t// Draw black half circle on right side\n\t\t\telement.appendChild(besogo.svgEl(\"path\", {\n\t\t\t\td: \"m\" + x + \",\" + (y - 44) + \" a44 44 0 0 1 0,88z\",\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"black\"\n\t\t\t}));\n\n\t\t\t// Draw white part of ying yang on left side\n\t\t\telement.appendChild(besogo.svgEl(\"path\", {\n\t\t\t\td: \"m\" + x + \",\" + (y + 44) + \"a44 44 0 0 1 0,-88a22 22 0 0 1 0,44z\",\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"white\"\n\t\t\t}));\n\n\t\t\t// Draw round part of black half of ying yang\n\t\t\telement.appendChild(besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y + 22,\n\t\t\t\tr: 22,\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"black\"\n\t\t\t}));\n\n\t\t\treturn element;\n\t\t}\n\t};\n\tbesogo.makeTreePanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar svg,\n\t\t\tpathGroup,\n\t\t\tbottomLayer,\n\t\t\tcurrentMarker,\n\t\t\tSCALE = 0.25; // Tree size scaling factor\n\n\t\trebuildNavTree();\n\t\teditor.addListener(treeUpdate);\n\n\n\t\t// Callback for handling tree changes\n\t\tfunction treeUpdate(msg) {\n\t\t\tif (msg.treeChange) { // Tree structure changed\n\t\t\t\trebuildNavTree(); // Rebuild entire tree\n\t\t\t} else if (msg.navChange) { // Only navigation changed\n\t\t\t\tupdateCurrentMarker(); // Update current location marker\n\t\t\t} else if (msg.stoneChange) { // Only stones in current changed\n\t\t\t\tupdateCurrentNodeIcon();\n\t\t\t}\n\t\t}\n\n\t\t// Updates the current marker in the tree\n\t\tfunction updateCurrentMarker() {\n\t\t\tvar current = editor.getCurrent();\n\n\t\t\tsetSelectionMarker(currentMarker);\n\t\t\tsetCurrentMarker(current.navTreeMarker);\n\t\t}\n\n\t\t// Sets marker element to indicate the current node\n\t\tfunction setCurrentMarker(marker) {\n\t\t\tvar width = container.clientWidth,\n\t\t\t\theight = container.clientHeight,\n\t\t\t\ttop = container.scrollTop,\n\t\t\t\tleft = container.scrollLeft,\n\t\t\t\tmarkX = (marker.getAttribute('x') - 5) * SCALE, // Computed position of marker\n\t\t\t\tmarkY = (marker.getAttribute('y') - 5) * SCALE,\n\t\t\t\tGRIDSIZE = 120 * SCALE; // Size of the square grid\n\n\t\t\tif (markX < left) { // Ensure horizontal visibility of current marker\n\t\t\t\tcontainer.scrollLeft = markX;\n\t\t\t} else if (markX + GRIDSIZE > left + width) {\n\t\t\t\tcontainer.scrollLeft = markX + GRIDSIZE - width;\n\t\t\t}\n\t\t\tif (markY < top) { // Ensure vertical visibility of current marker\n\t\t\t\tcontainer.scrollTop = markY;\n\t\t\t} else if (markY + GRIDSIZE > top + height) {\n\t\t\t\tcontainer.scrollTop = markY + GRIDSIZE - height;\n\t\t\t}\n\n\t\t\tmarker.setAttribute('opacity', 1); // Always visible\n\t\t\tmarker.onmouseover = null; // Clear hover over action\n\t\t\tmarker.onmouseout = null; // Clear hover off action\n\t\t\tbottomLayer.appendChild(marker); // Moves marker to the background\n\t\t\tcurrentMarker = marker;\n\t\t}\n\n\t\t// Sets marker\n\t\tfunction setSelectionMarker(marker) {\n\t\t\tmarker.setAttribute('opacity', 0); // Normally invisible\n\t\t\tmarker.onmouseover = function() { // Show on hover over\n\t\t\t\tmarker.setAttribute('opacity', 0.5);\n\t\t\t};\n\t\t\tmarker.onmouseout = function() { // Hide on hover off\n\t\t\t\tmarker.setAttribute('opacity', 0);\n\t\t\t};\n\t\t\tsvg.appendChild(marker); // Move marker to foreground\n\t\t}\n\n\t\t// Rebuilds the entire navigation tree\n\t\tfunction rebuildNavTree() {\n\t\t\tvar current = editor.getCurrent(), // Current location in game state tree\n\t\t\t\troot = editor.getRoot(), // Root node of game state\n\t\t\t\tnextOpen = [], // Tracks occupied grid positions\n\t\t\t\toldSvg = svg, // Store the old SVG root\n\t\t\t\tbackground = besogo.svgEl(\"rect\", { // Background color for tree\n\t\t\t\t\theight: '100%',\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t\t}),\n\t\t\t\tpath, // Root path\n\t\t\t\twidth, // Calculated dimensions of the SVG\n\t\t\t\theight;\n\n\t\t\tsvg = besogo.svgEl(\"svg\");\n\t\t\tbottomLayer = besogo.svgEl(\"g\"); // Holder for the current marker\n\t\t\tpathGroup = besogo.svgEl(\"g\"); // Holder for path elements\n\n\t\t\tsvg.appendChild(background); // Background color first\n\t\t\tsvg.appendChild(bottomLayer); // Bottom layer (for current marker) second\n\t\t\tsvg.appendChild(pathGroup); // Navigation path third\n\n\t\t\tpath = recursiveTreeBuild(root, 0, 0, nextOpen); // Build the tree\n\t\t\tpathGroup.appendChild(finishPath(path, 'black')); // Finish and add root path\n\n\t\t\twidth = 120 * nextOpen.length; // Compute height and width of nav tree\n\t\t\theight = 120 * Math.max.apply(Math, nextOpen);\n\t\t\tsvg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);\n\t\t\tsvg.setAttribute('height', height * SCALE); // Scale down the actual SVG size\n\t\t\tsvg.setAttribute('width', width * SCALE);\n\n\t\t\tif (oldSvg) { // Replace SVG in container\n\t\t\t\tcontainer.replaceChild(svg, oldSvg);\n\t\t\t} else { // SVG not yet added to container\n\t\t\t\tcontainer.appendChild(svg);\n\t\t\t}\n\n\t\t\tsetCurrentMarker(current.navTreeMarker); // Set current marker and ensure visible\n\t\t} // END function rebuildNavTree\n\n\t\t// Recursively builds the tree\n\t\tfunction recursiveTreeBuild(node, x, y, nextOpen) {\n\t\t\tvar children = node.children,\n\t\t\t\tposition,\n\t\t\t\tpath,\n\t\t\t\tchildPath,\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (children.length === 0) { // Reached end of branch\n\t\t\t\tpath = 'm' + svgPos(x) + ',' + svgPos(y); // Start path at end of branch\n\t\t\t} else { // Current node has children\n\t\t\t\tposition = (nextOpen[x + 1] || 0); // First open spot in next column\n\t\t\t\tposition = (position < y) ? y : position; // Bring level with current y\n\n\t\t\t\tif (y < position - 1) { // Check if first child natural drop > 1\n\t\t\t\t\ty = position - 1; // Bring current y within 1 of first child drop\n\t\t\t\t}\n\t\t\t\t// Place first child and extend path\n\t\t\t\tpath = recursiveTreeBuild(children[0], x + 1, position, nextOpen) +\n\t\t\t\t\textendPath(x, y, nextOpen);\n\n\t\t\t\t// Place other children (intentionally starting at i = 1)\n\t\t\t\tfor (i = 1; i < children.length; i++) {\n\t\t\t\t\tposition = nextOpen[x + 1];\n\t\t\t\t\tchildPath = recursiveTreeBuild(children[i], x + 1, position, nextOpen) +\n\t\t\t\t\t\textendPath(x, y, nextOpen, position - 1);\n\t\t\t\t\t// End path at beginning of branch\n\t\t\t\t\tpathGroup.appendChild(finishPath(childPath, 'black'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvg.appendChild(makeNodeIcon(node, x, y));\n\t\t\taddSelectionMarker(node, x, y);\n\n\t\t\tnextOpen[x] = y + 1; // Claims (x, y)\n\t\t\treturn path;\n\t\t} // END function recursiveTreeBuild\n\n\t\tfunction makeNodeIcon(node, x, y) { // Makes a node icon for the tree\n\t\t\tvar element,\n\t\t\t\tcolor;\n\n\t\t\tswitch (node.getType()) {\n\t\t\t\tcase 'move': // Move node\n\t\t\t\t\tcolor = node.move.color;\n\t\t\t\t\telement = besogo.svgEl(\"g\");\n\t\t\t\t\telement.appendChild(besogo.svgStone(svgPos(x), svgPos(y), color));\n\t\t\t\t\tcolor = (color === -1) ? \"white\" : \"black\";\n\t\t\t\t\telement.appendChild(besogo.svgLabel(svgPos(x), svgPos(y), color,\n\t\t\t\t\t\t'' + node.moveNumber));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'setup': // Setup node\n\t\t\t\t\telement = besogo.svgEl(\"g\");\n\t\t\t\t\telement.appendChild(besogo.svgStone(svgPos(x), svgPos(y))); // Grey stone\n\t\t\t\t\telement.appendChild(besogo.svgPlus(svgPos(x), svgPos(y), besogo.RED));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: // Empty node\n\t\t\t\t\telement = besogo.svgStone(svgPos(x), svgPos(y)); // Grey stone\n\t\t\t}\n\t\t\tnode.navTreeIcon = element; // Save icon reference in game state tree\n\t\t\tnode.navTreeX = x; // Save position of the icon\n\t\t\tnode.navTreeY = y;\n\n\t\t\treturn element;\n\t\t} // END function makeNodeIcon\n\n\t\tfunction updateCurrentNodeIcon() { // Updates the current node icon\n\t\t\tvar current = editor.getCurrent(), // Current location in game state tree\n\t\t\t\toldIcon = current.navTreeIcon,\n\t\t\t\tnewIcon = makeNodeIcon(current, current.navTreeX, current.navTreeY);\n\t\t\tsvg.replaceChild(newIcon, oldIcon);\n\t\t}\n\n\t\tfunction addSelectionMarker(node, x, y) {\n\t\t\tvar element = besogo.svgEl(\"rect\", { // Create selection marker\n\t\t\t\tx: svgPos(x) - 55,\n\t\t\t\ty: svgPos(y) - 55,\n\t\t\t\twidth: 110,\n\t\t\t\theight: 110,\n\t\t\t\tfill: besogo.TURQ\n\t\t\t});\n\t\t\telement.onclick = function() {\n\t\t\t\teditor.setCurrent(node);\n\t\t\t};\n\n\t\t\tnode.navTreeMarker = element; // Save selection marker in node\n\t\t\tsetSelectionMarker(element); // Add as and set selection marker properties\n\t\t}\n\n\t\tfunction extendPath(x, y, nextOpen, prevChildPos) { // Extends path from child to current\n\t\t\tvar childPos = nextOpen[x + 1] - 1; // Position of child\n\t\t\tif (childPos === y) { // Child is horizontally level with current\n\t\t\t\treturn 'h-120'; // Horizontal line back to current\n\t\t\t} else if (childPos === y + 1) { // Child is one drop from current\n\t\t\t\treturn 'l-120,-120'; // Diagonal drop line back to current\n\t\t\t} else if (prevChildPos && prevChildPos !== y) {\n\t\t\t\t// Previous is already dropped, extend back to previous child drop line\n\t\t\t\treturn 'l-60,-60v-' + (120 * (childPos - prevChildPos));\n\t\t\t} else { // Extend double-bend drop line back to parent\n\t\t\t\treturn 'l-60,-60v-' + (120 * (childPos - y - 1)) + 'l-60,-60';\n\t\t\t}\n\t\t}\n\n\t\tfunction finishPath(path, color) { // Finishes path element\n\t\t\tvar element = besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction svgPos(x) { // Converts (x, y) coordinates to SVG position\n\t\t\treturn (x * 120) + 60;\n\t\t}\n\t};\n\tbesogo.autoInit();\n\tsetTimeout(function() {\n\t\tdocument.querySelector('[title=\"Next node\"]').click();\n\t}, 400);\n</script>\n<style>\n\t.besogo-container {\n\t\tborder: 4px solid indianred;\n\t\tborder-radius: 6px;\n\t\tpadding: 7px;\n\t}\n\n\t.besogo-control {\n\t\tmax-width: 400px;\n\t\tmargin: auto;\n\t\tmargin-top: 20px;\n\t}\n\n\t[title=\"Variants: child/[sibling]\"],\n\t[title=\"Variants: [child]/sibling\"],\n\t[title=\"Variants: show/[hide]\"],\n\t[title=\"Toggle coordinates\"],\n\t.besogo-gameInfo {\n\t\tdisplay: none !important;\n\t}\n\n\t.besogo-comment>div {\n\t\tvisibility: visible;\n\t\tmargin-top: 10px;\n\t\tborder-bottom-left-radius: 10px;\n\t\tborder-bottom-right-radius: 10px;\n\t\tpadding: 25px;\n\t\tcolor: #D7DEE9;\n\t\t/* FONT COLOR */\n\t\tbackground-color: #333B45;\n\t\t/* BACKGROUND COLOR */\n\n\t}\n\n\t.card {\n\n\t\theight: 85%;\n\n\t}\n</style>"
                }
            ],
            "type": 0,
            "vers": []
        },
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "2c89c052-4e0f-11ec-899d-d45d6450590b",
            "css": "::-webkit-scrollbar {\n  display: none;\n}\n\n.night_mode {\n  background-color: black;\n}\n\n/*  a simple way to stop inverted colours on ankidroid*/\n.card {\n  color: black !important;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: -webkit-box;\n  -webkit-box-align: stretch;\n  -webkit-box-pack: center;\n  -webkit-box-orient: vertical;\n  font-size: 22px;\n  text-align: center;\n  /* ALIGN TEXT */\n}\n\n.mobile .card {\n  width: 97%\n}\n\nbody {\n  margin: 0\n}\n\n.besogo-comment>input {\n  display: none;\n}\n\n.besogo-container {\n  margin: auto;\n  outline: none;\n  display: flex;\n  background: #d0fefe;\n}\n\n.besogo-container * {\n  box-sizing: border-box;\n}\n\n.besogo-container button {\n  height: 30px;\n  width: 30px;\n  padding: 0px;\n  background: #d8dcd6;\n}\n\n.besogo-container input {\n  font-size: 12pt;\n}\n\n.besogo-container input[type='button'] {\n  background: #d8dcd6;\n}\n\n.besogo-container input[type='text'] {\n  width: 30px;\n}\n\n.besogo-container svg {\n  /* Prevent text selection within SVG */\n  -webkit-touch-callout: none;\n  /* iOS Safari */\n  -webkit-user-select: none;\n  /* Chrome/Safari/Opera */\n  -moz-user-select: none;\n  /* Firefox */\n  -ms-user-select: none;\n  /* Internet Explorer/Edge */\n  user-select: none;\n}\n\n.besogo-panels {\n  flex-direction: column;\n  align-items: center;\n  padding: 0px 5px;\n}\n\n.besogo-panels>* {\n  margin: 3px 0px;\n}\n\n.besogo-control {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  justify-content: space-around;\n  width: 100%;\n  flex: 0 0 auto;\n}\n\n.besogo-names {\n  flex: 0 0 auto;\n  width: 100%;\n}\n\n.besogo-playerInfo {\n  display: flex;\n  font-family: Tahoma, Geneva, sans-serif;\n  white-space: pre-wrap;\n}\n\n.besogo-blackInfo {\n  flex: 50%;\n  color: white;\n  background: black;\n  text-align: right;\n  padding: 5px;\n}\n\n.besogo-whiteInfo {\n  flex: 50%;\n  color: black;\n  background: white;\n  text-align: left;\n  padding: 5px;\n}\n\n.besogo-blackCaps {\n  float: left;\n}\n\n.besogo-whiteCaps {\n  float: right;\n}\n\n.besogo-comment {\n  font-family: Georgia, serif;\n  font-size: 12pt;\n  white-space: pre-wrap;\n  overflow: auto;\n  flex: 1 1 60%;\n  width: 100%;\n}\n\n.besogo-comment input[type='button'] {\n  float: right;\n}\n\n.besogo-comment textarea {\n  height: 100%;\n  width: 100%;\n}\n\n.besogo-gameInfo {\n  padding: 5px;\n  border-collapse: collapse;\n}\n\n.besogo-gameInfo td, tr {\n  border: 1px solid black;\n  padding: 3px;\n}\n\n.besogo-tool {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  justify-content: space-around;\n  width: 100%;\n  flex: 0 0 auto;\n}\n\n.besogo-tree {\n  overflow: auto;\n  flex: 1 1 40%;\n  width: 100%;\n}\n\n.besogo-file {\n  display: none;\n  flex: 0 0 auto;\n}\n\n/* Kaya board theme */\n.besogo-svg-board {\n  fill: none;\n}\n\n.besogo-svg-backer {\n  fill: #fcbc5b;\n}\n\n.besogo-board {\n  background: url(\"_shinkaya4.jpg\");\n  background-size: cover;\n}\n\n.besogo-svg-lines {\n  stroke: #151515;\n  stroke-width: 2.5;\n  fill: none;\n}\n\n.besogo-svg-hoshi {\n  stroke: #151515;\n  stroke-width: 12;\n}\n\n.besogo-svg-blackStone {\n  fill: #252525;\n  stroke: #252525;\n  stroke-width: 4;\n}\n\n.besogo-svg-whiteStone {\n  fill: #f5f5f5;\n  stroke: #f5f5f5;\n  stroke-width: 4;\n}\n\n.besogo-svg-greyStone {\n  fill: #929591;\n  stroke: #929591;\n  stroke-width: 4;\n}",
            "flds": [
                {
                    "font": "MS Shell Dlg 2",
                    "media": [],
                    "meta": null,
                    "name": "SGF",
                    "ord": 0,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Go your move",
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [
                "Go::test"
            ],
            "tmpls": [
                {
                    "afmt": "<script>\n// v1.0.0 - https://github.com/SimonLammer/anki-persistence/blob/cd2ca88e019dc3b8f32dad623932c1eabdba7e21/script.js\nif(void 0===window.Persistence){var _persistenceKey=\"github.com/SimonLammer/anki-persistence/\",_defaultKey=\"_default\";if(window.Persistence_sessionStorage=function(){var e=!1;try{\"object\"==typeof window.sessionStorage&&(e=!0,this.clear=function(){for(var e=0;e<sessionStorage.length;e++){var t=sessionStorage.key(e);0==t.indexOf(_persistenceKey)&&(sessionStorage.removeItem(t),e--)}},this.setItem=function(e,t){null==t&&(t=e,e=_defaultKey),sessionStorage.setItem(_persistenceKey+e,JSON.stringify(t))},this.getItem=function(e){return null==e&&(e=_defaultKey),JSON.parse(sessionStorage.getItem(_persistenceKey+e))},this.removeItem=function(e){null==e&&(e=_defaultKey),sessionStorage.removeItem(_persistenceKey+e)})}catch(e){}this.isAvailable=function(){return e}},window.Persistence_windowKey=function(e){var t=window[e],n=!1;\"object\"==typeof t&&(n=!0,this.clear=function(){t[_persistenceKey]={}},this.setItem=function(e,n){null==n&&(n=e,e=_defaultKey),t[_persistenceKey][e]=n},this.getItem=function(e){return null==e&&(e=_defaultKey),null==t[_persistenceKey][e]?null:t[_persistenceKey][e]},this.removeItem=function(e){null==e&&(e=_defaultKey),delete t[_persistenceKey][e]},null==t[_persistenceKey]&&this.clear()),this.isAvailable=function(){return n}},window.Persistence=new Persistence_sessionStorage,Persistence.isAvailable()||(window.Persistence=new Persistence_windowKey(\"py\")),!Persistence.isAvailable()){var titleStartIndex=window.location.toString().indexOf(\"title\"),titleContentIndex=window.location.toString().indexOf(\"main\",titleStartIndex);titleStartIndex>0&&titleContentIndex>0&&titleContentIndex-titleStartIndex<10&&(window.Persistence=new Persistence_windowKey(\"qt\"))}}\n</script>\n<div class=\"besogo-editor\" maxwidth=1200 transwidth=700>{{SGF}}</div>\n\n<script>\n\t(function() {\n\t\t'use strict';\n\t\tvar besogo = window.besogo = window.besogo || {}; // Establish our namespace\n\t\tbesogo.VERSION = '0.0.2-alpha';\n\n\t\tbesogo.create = function(container, options) {\n\t\t\tvar editor, // Core editor object\n\t\t\t\tresizer, // Auto-resizing function\n\t\t\t\tboardDiv, // Board display container\n\t\t\t\tpanelsDiv, // Parent container of panel divs\n\t\t\t\tmakers = { // Map to panel creators\n\t\t\t\t\tcontrol: besogo.makeControlPanel,\n\t\t\t\t\tnames: besogo.makeNamesPanel,\n\t\t\t\t\tcomment: besogo.makeCommentPanel,\n\t\t\t\t\ttool: besogo.makeToolPanel,\n\t\t\t\t\ttree: besogo.makeTreePanel,\n\t\t\t\t\tfile: besogo.makeFilePanel\n\t\t\t\t},\n\t\t\t\tinsideText = container.textContent || container.innerText || '',\n\t\t\t\ti, panelName; // Scratch iteration variables\n\n\t\t\tcontainer.className += ' besogo-container'; // Marks this div as initialized\n\n\t\t\t// Process options and set defaults\n\t\t\toptions = options || {}; // Makes option checking simpler\n\t\t\toptions.size = besogo.parseSize(options.size || 19);\n\t\t\toptions.coord = options.coord || 'none';\n\t\t\toptions.tool = options.tool || 'auto';\n\t\t\tif (options.panels === '') {\n\t\t\t\toptions.panels = [];\n\t\t\t}\n\t\t\toptions.panels = options.panels || 'control+names+comment+tool+tree+file';\n\t\t\tif (typeof options.panels === 'string') {\n\t\t\t\toptions.panels = options.panels.split('+');\n\t\t\t}\n\t\t\toptions.path = options.path || '';\n\t\t\tif (options.shadows === undefined) {\n\t\t\t\toptions.shadows = 'auto';\n\t\t\t} else if (options.shadows === 'off') {\n\t\t\t\toptions.shadows = false;\n\t\t\t}\n\n\t\t\t// Make the core editor object\n\t\t\teditor = besogo.makeEditor(options.size.x, options.size.y);\n\t\t\teditor.setTool(options.tool);\n\t\t\teditor.setCoordStyle(options.coord);\n\t\t\tif (options.realstones) { // Using realistic stones\n\t\t\t\teditor.REAL_STONES = true;\n\t\t\t\teditor.SHADOWS = options.shadows;\n\t\t\t} else { // SVG stones\n\t\t\t\teditor.SHADOWS = (options.shadows && options.shadows !== 'auto');\n\t\t\t}\n\n\t\t\tif (!options.nokeys) { // Add keypress handler unless nokeys option is truthy\n\t\t\t\taddKeypressHandler(container, editor);\n\t\t\t}\n\n\t\t\tif (options.sgf) { // Load SGF file from URL\n\t\t\t\ttry {\n\t\t\t\t\tfetchParseLoad(options.sgf, editor, options.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Silently fail on network error\n\t\t\t\t}\n\t\t\t} else if (insideText.match(/\\s*\\(\\s*;/)) { // Text content looks like an SGF file\n\t\t\t\tparseAndLoad(insideText, editor);\n\t\t\t\tnavigatePath(editor, options.path); // Navigate editor along path\n\t\t\t}\n\n\t\t\tif (typeof options.variants === 'number' || typeof options.variants === 'string') {\n\t\t\t\teditor.setVariantStyle(+options.variants); // Converts to number\n\t\t\t}\n\n\t\t\twhile (container.firstChild) { // Remove all children of container\n\t\t\t\tcontainer.removeChild(container.firstChild);\n\t\t\t}\n\n\t\t\tboardDiv = makeDiv('besogo-board'); // Create div for board display\n\t\t\tbesogo.makeBoardDisplay(boardDiv, editor); // Create board display\n\n\t\t\tif (!options.nowheel) { // Add mousewheel handler unless nowheel option is truthy\n\t\t\t\taddWheelHandler(boardDiv, editor);\n\t\t\t}\n\n\t\t\tif (options.panels.length > 0) { // Only create if there are panels to add\n\t\t\t\tpanelsDiv = makeDiv('besogo-panels');\n\t\t\t\tfor (i = 0; i < options.panels.length; i++) {\n\t\t\t\t\tpanelName = options.panels[i];\n\t\t\t\t\tif (makers[panelName]) { // Only add if creator function exists\n\t\t\t\t\t\tmakers[panelName](makeDiv('besogo-' + panelName, panelsDiv), editor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!panelsDiv.firstChild) { // If no panels were added\n\t\t\t\t\tcontainer.removeChild(panelsDiv); // Remove the panels div\n\t\t\t\t\tpanelsDiv = false; // Flags panels div as removed\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.resize = options.resize || 'auto';\n\t\t\tif (options.resize === 'auto') { // Add auto-resizing unless resize option is truthy\n\t\t\t\tresizer = function() {\n\t\t\t\t\tvar windowHeight = window.innerHeight, // Viewport height\n\t\t\t\t\t\t// Calculated width of parent element\n\t\t\t\t\t\tparentWidth = parseFloat(getComputedStyle(container).width),\n\t\t\t\t\t\tmaxWidth = +(options.maxwidth || -1),\n\t\t\t\t\t\torientation = options.orient || 'auto',\n\n\t\t\t\t\t\tportraitRatio = +(options.portratio || 200) / 100,\n\t\t\t\t\t\tlandscapeRatio = +(options.landratio || 200) / 100,\n\t\t\t\t\t\tminPanelsWidth = +(options.minpanelswidth || 350),\n\t\t\t\t\t\tminPanelsHeight = +(options.minpanelsheight || 400),\n\t\t\t\t\t\tminLandscapeWidth = +(options.transwidth || 600),\n\n\t\t\t\t\t\t// Initial width parent\n\t\t\t\t\t\twidth = (maxWidth > 0 && maxWidth < parentWidth) ? maxWidth : parentWidth,\n\t\t\t\t\t\theight; // Initial height is undefined\n\n\t\t\t\t\t// Determine orientation if 'auto' or 'view'\n\t\t\t\t\tif (orientation !== 'portrait' && orientation !== 'landscape') {\n\t\t\t\t\t\tif (width < minLandscapeWidth || (orientation === 'view' && width < windowHeight)) {\n\t\t\t\t\t\t\torientation = 'portrait';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\torientation = 'landscape';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (orientation === 'portrait') { // Portrait mode\n\t\t\t\t\t\tif (!isNaN(portraitRatio)) {\n\t\t\t\t\t\t\theight = portraitRatio * width;\n\t\t\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\t\t\theight = (height - width < minPanelsHeight) ? width + minPanelsHeight : height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // Otherwise, leave height undefined\n\t\t\t\t\t} else if (orientation === 'landscape') { // Landscape mode\n\t\t\t\t\t\tif (!panelsDiv) { // No panels div\n\t\t\t\t\t\t\theight = width; // Square overall\n\t\t\t\t\t\t} else if (isNaN(landscapeRatio)) {\n\t\t\t\t\t\t\theight = windowHeight;\n\t\t\t\t\t\t} else { // Otherwise use ratio\n\t\t\t\t\t\t\theight = width / landscapeRatio;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\t\t// Reduce height to ensure minimum width of panels div\n\t\t\t\t\t\t\theight = (width < height + minPanelsWidth) ? (width - minPanelsWidth) : height;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsetDimensions(width, height);\n\t\t\t\t\tcontainer.style.width = width + 'px';\n\t\t\t\t};\n\t\t\t\twindow.addEventListener(\"resize\", resizer);\n\t\t\t\tresizer(); // Initial div sizing\n\t\t\t} else if (options.resize === 'fixed') {\n\t\t\t\tsetDimensions(container.clientWidth, container.clientHeight);\n\t\t\t}\n\n\t\t\t// Sets dimensions with optional height param\n\t\t\tfunction setDimensions(width, height) {\n\t\t\t\tif (height && width > height) { // Landscape mode\n\t\t\t\t\tcontainer.style['flex-direction'] = 'row';\n\t\t\t\t\tboardDiv.style.height = height + 'px';\n\t\t\t\t\tboardDiv.style.width = height + 'px';\n\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\tpanelsDiv.style.height = height + 'px';\n\t\t\t\t\t\tpanelsDiv.style.width = (width - height) + 'px';\n\t\t\t\t\t}\n\t\t\t\t} else { // Portrait mode (implied if height is missing)\n\t\t\t\t\tcontainer.style['flex-direction'] = 'column';\n\t\t\t\t\tboardDiv.style.height = width + 'px';\n\t\t\t\t\tboardDiv.style.width = width + 'px';\n\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\tif (height) { // Only set height if param present\n\t\t\t\t\t\t\tpanelsDiv.style.height = (height - width) + 'px';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpanelsDiv.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Creates and adds divs to specified parent or container\n\t\t\tfunction makeDiv(className, parent) {\n\t\t\t\tvar div = document.createElement(\"div\");\n\t\t\t\tif (className) {\n\t\t\t\t\tdiv.className = className;\n\t\t\t\t}\n\t\t\t\tparent = parent || container;\n\t\t\t\tparent.appendChild(div);\n\t\t\t\treturn div;\n\t\t\t}\n\t\t}; // END function besogo.create\n\n\t\t// Parses size parameter from SGF format\n\t\tbesogo.parseSize = function(input) {\n\t\t\tvar matches,\n\t\t\t\tsizeX,\n\t\t\t\tsizeY;\n\n\t\t\tinput = (input + '').replace(/\\s/g, ''); // Convert to string and remove whitespace\n\n\t\t\tmatches = input.match(/^(\\d+):(\\d+)$/); // Check for #:# pattern\n\t\t\tif (matches) { // Composed value pattern found\n\t\t\t\tsizeX = +matches[1]; // Convert to numbers\n\t\t\t\tsizeY = +matches[2];\n\t\t\t} else if (input.match(/^\\d+$/)) { // Check for # pattern\n\t\t\t\tsizeX = +input; // Convert to numbers\n\t\t\t\tsizeY = +input; // Implied square\n\t\t\t} else { // Invalid input format\n\t\t\t\tsizeX = sizeY = 19; // Default size value\n\t\t\t}\n\t\t\tif (sizeX > 52 || sizeX < 1 || sizeY > 52 || sizeY < 1) {\n\t\t\t\tsizeX = sizeY = 19; // Out of range, set to default\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: sizeX,\n\t\t\t\ty: sizeY\n\t\t\t};\n\t\t};\n\n\t\t// Automatically converts document elements into besogo instances\n\t\tbesogo.autoInit = function() {\n\t\t\tvar allDivs = document.getElementsByTagName('div'), // Live collection of divs\n\t\t\t\ttargetDivs = [], // List of divs to auto-initialize\n\t\t\t\toptions, // Structure to hold options\n\t\t\t\ti, j, attrs; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < allDivs.length; i++) { // Iterate over all divs\n\t\t\t\tif ((hasClass(allDivs[i], 'besogo-editor') || // Has an auto-init class\n\t\t\t\t\t\thasClass(allDivs[i], 'besogo-viewer') ||\n\t\t\t\t\t\thasClass(allDivs[i], 'besogo-diagram')) &&\n\t\t\t\t\t!hasClass(allDivs[i], 'besogo-container')) { // Not already initialized\n\t\t\t\t\ttargetDivs.push(allDivs[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targetDivs.length; i++) { // Iterate over target divs\n\t\t\t\toptions = {}; // Clear the options struct\n\t\t\t\tif (hasClass(targetDivs[i], 'besogo-editor')) {\n\t\t\t\t\toptions.panels = ['control', 'names', 'comment', 'tool', 'tree', 'file'];\n\t\t\t\t\toptions.tool = 'auto';\n\t\t\t\t} else if (hasClass(targetDivs[i], 'besogo-viewer')) {\n\t\t\t\t\toptions.panels = ['control', 'names', 'comment'];\n\t\t\t\t\toptions.tool = 'navOnly';\n\t\t\t\t} else if (hasClass(targetDivs[i], 'besogo-diagram')) {\n\t\t\t\t\toptions.panels = [];\n\t\t\t\t\toptions.tool = 'navOnly';\n\t\t\t\t}\n\n\t\t\t\tattrs = targetDivs[i].attributes;\n\t\t\t\tfor (j = 0; j < attrs.length; j++) { // Load attributes as options\n\t\t\t\t\toptions[attrs[j].name] = attrs[j].value;\n\t\t\t\t}\n\t\t\t\tbesogo.create(targetDivs[i], options);\n\t\t\t}\n\n\t\t\tfunction hasClass(element, str) {\n\t\t\t\treturn (element.className.split(' ').indexOf(str) !== -1);\n\t\t\t}\n\t\t};\n\n\t\t// Sets up keypress handling\n\t\tfunction addKeypressHandler(container, editor) {\n\t\t\tif (!container.getAttribute('tabindex')) {\n\t\t\t\tcontainer.setAttribute('tabindex', '0'); // Set tabindex to allow div focusing\n\t\t\t}\n\n\t\t\tcontainer.addEventListener('keydown', function(evt) {\n\t\t\t\tevt = evt || window.event;\n\t\t\t\tswitch (evt.keyCode) {\n\t\t\t\t\tcase 33: // page up\n\t\t\t\t\t\teditor.prevNode(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 34: // page down\n\t\t\t\t\t\teditor.nextNode(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 35: // end\n\t\t\t\t\t\teditor.nextNode(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 36: // home\n\t\t\t\t\t\teditor.prevNode(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 37: // left\n\t\t\t\t\t\teditor.prevNode(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 38: // up\n\t\t\t\t\t\teditor.nextSibling(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 39: // right\n\t\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 40: // down\n\t\t\t\t\t\teditor.nextSibling(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 46: // delete\n\t\t\t\t\t\teditor.cutCurrent();\n\t\t\t\t\t\tbreak;\n\t\t\t\t} // END switch (evt.keyCode)\n\t\t\t\tif (evt.keyCode >= 33 && evt.keyCode <= 40) {\n\t\t\t\t\tevt.preventDefault(); // Suppress page nav controls\n\t\t\t\t}\n\t\t\t}); // END func() and addEventListener\n\t\t} // END function addKeypressHandler\n\n\t\t// Sets up mousewheel handling\n\t\tfunction addWheelHandler(boardDiv, editor) {\n\t\t\tboardDiv.addEventListener('wheel', function(evt) {\n\t\t\t\tevt = evt || window.event;\n\t\t\t\tif (evt.deltaY > 0) {\n\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t} else if (evt.deltaY < 0) {\n\t\t\t\t\teditor.prevNode(1);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Parses SGF string and loads into editor\n\t\tfunction parseAndLoad(text, editor) {\n\t\t\tvar sgf;\n\t\t\ttry {\n\t\t\t\tsgf = besogo.parseSgf(text);\n\t\t\t} catch (error) {\n\t\t\t\treturn; // Silently fail on parse error\n\t\t\t}\n\t\t\tbesogo.loadSgf(sgf, editor);\n\t\t}\n\n\t\t// Fetches text file at url from same domain\n\t\tfunction fetchParseLoad(url, editor, path) {\n\t\t\tvar http = new XMLHttpRequest();\n\n\t\t\thttp.onreadystatechange = function() {\n\t\t\t\tif (http.readyState === 4 && http.status === 200) { // Successful fetch\n\t\t\t\t\tparseAndLoad(http.responseText, editor);\n\t\t\t\t\tnavigatePath(editor, path);\n\t\t\t\t}\n\t\t\t};\n\t\t\thttp.overrideMimeType('text/plain'); // Prevents XML parsing and warnings\n\t\t\thttp.open(\"GET\", url, true); // Asynchronous load\n\t\t\thttp.send();\n\t\t}\n\n\t\tfunction navigatePath(editor, path) {\n\t\t\tvar subPaths,\n\t\t\t\ti, j; // Scratch iteration variables\n\n\t\t\tpath = path.split(/[Nn]+/); // Split into parts that start in next mode\n\t\t\tfor (i = 0; i < path.length; i++) {\n\t\t\t\tsubPaths = path[i].split(/[Bb]+/); // Split on switches into branch mode\n\t\t\t\texecuteMoves(subPaths[0], false); // Next mode moves\n\t\t\t\tfor (j = 1; j < subPaths.length; j++) { // Intentionally starting at 1\n\t\t\t\t\texecuteMoves(subPaths[j], true); // Branch mode moves\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction executeMoves(part, branch) {\n\t\t\t\tvar i;\n\t\t\t\tpart = part.split(/\\D+/); // Split on non-digits\n\t\t\t\tfor (i = 0; i < part.length; i++) {\n\t\t\t\t\tif (part[i]) { // Skip empty strings\n\t\t\t\t\t\tif (branch) { // Branch mode\n\t\t\t\t\t\t\tif (editor.getCurrent().children.length) {\n\t\t\t\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\t\t\t\teditor.nextSibling(part[i] - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // Next mode\n\t\t\t\t\t\t\teditor.nextNode(+part[i]); // Converts to number\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t})(); // END closure\n\tbesogo.makeBoardDisplay = function(container, editor) {\n\t\t'use strict';\n\t\tvar CELL_SIZE = 88, // Including line width\n\t\t\tCOORD_MARGIN = 75, // Margin for coordinate labels\n\t\t\tEXTRA_MARGIN = 6, // Extra margin on the edge of board\n\t\t\tBOARD_MARGIN, // Total board margin\n\n\t\t\t// Board size parameters\n\t\t\tsizeX = editor.getCurrent().getSize().x,\n\t\t\tsizeY = editor.getCurrent().getSize().y,\n\n\t\t\tsvg, // Holds the overall board display SVG element\n\t\t\tstoneGroup, // Group for stones\n\t\t\tmarkupGroup, // Group for markup\n\t\t\thoverGroup, // Group for hover layer\n\t\t\tmarkupLayer, // Array of markup layer elements\n\t\t\thoverLayer, // Array of hover layer elements\n\n\t\t\trandIndex, // Random index for stone images\n\n\t\t\tTOUCH_FLAG = false; // Flag for touch interfaces\n\n\t\tinitializeBoard(editor.getCoordStyle()); // Initialize SVG element and draw the board\n\t\tcontainer.appendChild(svg); // Add the SVG element to the document\n\t\teditor.addListener(update); // Register listener to handle editor/game state updates\n\t\tredrawAll(editor.getCurrent()); // Draw stones, markup and hover layer\n\n\t\t// Set listener to detect touch interfaces\n\t\tcontainer.addEventListener('touchstart', setTouchFlag);\n\n\t\t// Function for setting the flag for touch interfaces\n\t\tfunction setTouchFlag() {\n\t\t\tTOUCH_FLAG = true; // Set flag to prevent needless function calls\n\t\t\thoverLayer = []; // Drop hover layer references, kills events\n\t\t\tsvg.removeChild(hoverGroup); // Remove hover group from SVG\n\t\t\t// Remove self when done\n\t\t\tcontainer.removeEventListener('touchstart', setTouchFlag);\n\t\t}\n\n\t\t// Initializes the SVG and draws the board\n\t\tfunction initializeBoard(coord) {\n\t\t\tdrawBoard(coord); // Initialize the SVG element and draw the board\n\n\t\t\tstoneGroup = besogo.svgEl(\"g\");\n\t\t\tmarkupGroup = besogo.svgEl(\"g\");\n\n\t\t\tsvg.appendChild(stoneGroup); // Add placeholder group for stone layer\n\t\t\tsvg.appendChild(markupGroup); // Add placeholder group for markup layer\n\n\t\t\tif (!TOUCH_FLAG) {\n\t\t\t\thoverGroup = besogo.svgEl(\"g\");\n\t\t\t\tsvg.appendChild(hoverGroup);\n\t\t\t}\n\n\t\t\taddEventTargets(); // Add mouse event listener layer\n\n\t\t\tif (editor.REAL_STONES) { // Generate index for realistic stone images\n\t\t\t\trandomizeIndex();\n\t\t\t}\n\t\t}\n\n\t\t// Callback for board display redraws\n\t\tfunction update(msg) {\n\t\t\tvar current = editor.getCurrent(),\n\t\t\t\tcurrentSize = current.getSize(),\n\t\t\t\treinit = false, // Board redraw flag\n\t\t\t\toldSvg = svg;\n\n\t\t\t// Check if board size has changed\n\t\t\tif (currentSize.x !== sizeX || currentSize.y !== sizeY || msg.coord) {\n\t\t\t\tsizeX = currentSize.x;\n\t\t\t\tsizeY = currentSize.y;\n\t\t\t\tinitializeBoard(msg.coord || editor.getCoordStyle()); // Reinitialize board\n\t\t\t\tcontainer.replaceChild(svg, oldSvg);\n\t\t\t\treinit = true; // Flag board redrawn\n\t\t\t}\n\n\t\t\t// Redraw stones only if needed\n\t\t\tif (reinit || msg.navChange || msg.stoneChange) {\n\t\t\t\tredrawStones(current);\n\t\t\t\tredrawMarkup(current);\n\t\t\t\tredrawHover(current);\n\t\t\t} else if (msg.markupChange) {\n\t\t\t\tredrawMarkup(current);\n\t\t\t\tredrawHover(current);\n\t\t\t} else if (msg.tool || msg.label) {\n\t\t\t\tredrawHover(current);\n\t\t\t}\n\t\t}\n\n\t\tfunction redrawAll(current) {\n\t\t\tredrawStones(current);\n\t\t\tredrawMarkup(current);\n\t\t\tredrawHover(current);\n\t\t}\n\n\t\t// Initializes the SVG element and draws the board\n\t\tfunction drawBoard(coord) {\n\t\t\tvar boardWidth,\n\t\t\t\tboardHeight,\n\t\t\t\tstring = \"\", // Path string for inner board lines\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tBOARD_MARGIN = (coord === 'none' ? 0 : COORD_MARGIN) + EXTRA_MARGIN;\n\t\t\tboardWidth = 2 * BOARD_MARGIN + sizeX * CELL_SIZE;\n\t\t\tboardHeight = 2 * BOARD_MARGIN + sizeY * CELL_SIZE;\n\n\t\t\tsvg = besogo.svgEl(\"svg\", { // Initialize the SVG element\n\t\t\t\twidth: \"100%\",\n\t\t\t\theight: \"100%\",\n\t\t\t\tviewBox: \"0 0 \" + boardWidth + \" \" + boardHeight\n\t\t\t});\n\n\t\t\tsvg.appendChild(besogo.svgEl(\"rect\", { // Fill background color\n\t\t\t\twidth: boardWidth,\n\t\t\t\theight: boardHeight,\n\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t}));\n\n\t\t\tsvg.appendChild(besogo.svgEl(\"rect\", { // Draw outer square of board\n\t\t\t\twidth: CELL_SIZE * (sizeX - 1),\n\t\t\t\theight: CELL_SIZE * (sizeY - 1),\n\t\t\t\tx: svgPos(1),\n\t\t\t\ty: svgPos(1),\n\t\t\t\t'class': 'besogo-svg-lines'\n\t\t\t}));\n\n\t\t\tfor (i = 2; i <= (sizeY - 1); i++) { // Horizontal inner lines\n\t\t\t\tstring += \"M\" + svgPos(1) + \",\" + svgPos(i) + \"h\" + CELL_SIZE * (sizeX - 1);\n\t\t\t}\n\t\t\tfor (i = 2; i <= (sizeX - 1); i++) { // Vertical inner lines\n\t\t\t\tstring += \"M\" + svgPos(i) + \",\" + svgPos(1) + \"v\" + CELL_SIZE * (sizeY - 1);\n\t\t\t}\n\t\t\tsvg.appendChild(besogo.svgEl(\"path\", { // Draw inner lines of board\n\t\t\t\td: string,\n\t\t\t\t'class': 'besogo-svg-lines'\n\t\t\t}));\n\n\t\t\tdrawHoshi(); // Draw the hoshi points\n\t\t\tif (coord !== 'none') {\n\t\t\t\tdrawCoords(coord); // Draw the coordinate labels\n\t\t\t}\n\t\t}\n\n\t\t// Draws coordinate labels on the board\n\t\tfunction drawCoords(coord) {\n\t\t\tvar labels = besogo.coord[coord](sizeX, sizeY),\n\t\t\t\tshift = COORD_MARGIN + 10,\n\t\t\t\ti, x, y; // Scratch iteration variable\n\n\t\t\tfor (i = 1; i <= sizeX; i++) { // Draw column coordinate labels\n\t\t\t\tx = svgPos(i);\n\t\t\t\tdrawCoordLabel(x, svgPos(1) - shift, labels.x[i]);\n\t\t\t\tdrawCoordLabel(x, svgPos(sizeY) + shift, labels.x[i]);\n\t\t\t}\n\n\t\t\tfor (i = 1; i <= sizeY; i++) { // Draw row coordinate labels\n\t\t\t\ty = svgPos(i);\n\t\t\t\tdrawCoordLabel(svgPos(1) - shift, y, labels.y[i]);\n\t\t\t\tdrawCoordLabel(svgPos(sizeX) + shift, y, labels.y[i]);\n\t\t\t}\n\n\t\t\tfunction drawCoordLabel(x, y, label) {\n\t\t\t\tvar element = besogo.svgEl(\"text\", {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\tdy: \".65ex\", // Seems to work for vertically centering these fonts\n\t\t\t\t\t\"font-size\": 32,\n\t\t\t\t\t\"text-anchor\": \"middle\", // Horizontal centering\n\t\t\t\t\t\"font-family\": \"Helvetica, Arial, sans-serif\",\n\t\t\t\t\tfill: 'black'\n\t\t\t\t});\n\t\t\t\telement.appendChild(document.createTextNode(label));\n\t\t\t\tsvg.appendChild(element);\n\t\t\t}\n\t\t}\n\n\t\t// Draws hoshi onto the board at procedurally generated locations\n\t\tfunction drawHoshi() {\n\t\t\tvar cx, cy, // Center point calculation\n\t\t\t\tpathStr = \"\"; // Path string for drawing star points\n\n\t\t\tif (sizeX % 2 && sizeY % 2) { // Draw center hoshi if both dimensions are odd\n\t\t\t\tcx = (sizeX - 1) / 2 + 1; // Calculate the center of the board\n\t\t\t\tcy = (sizeY - 1) / 2 + 1;\n\t\t\t\tdrawStar(cx, cy);\n\n\t\t\t\tif (sizeX >= 17 && sizeY >= 17) { // Draw side hoshi if at least 17x17 and odd\n\t\t\t\t\tdrawStar(4, cy);\n\t\t\t\t\tdrawStar(sizeX - 3, cy);\n\t\t\t\t\tdrawStar(cx, 4);\n\t\t\t\t\tdrawStar(cx, sizeY - 3);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sizeX >= 11 && sizeY >= 11) { // Corner hoshi at (4, 4) for larger sizes\n\t\t\t\tdrawStar(4, 4);\n\t\t\t\tdrawStar(4, sizeY - 3);\n\t\t\t\tdrawStar(sizeX - 3, 4);\n\t\t\t\tdrawStar(sizeX - 3, sizeY - 3);\n\t\t\t} else if (sizeX >= 8 && sizeY >= 8) { // Corner hoshi at (3, 3) for medium sizes\n\t\t\t\tdrawStar(3, 3);\n\t\t\t\tdrawStar(3, sizeY - 2);\n\t\t\t\tdrawStar(sizeX - 2, 3);\n\t\t\t\tdrawStar(sizeX - 2, sizeY - 2);\n\t\t\t} // No corner hoshi for smaller sizes\n\n\t\t\tif (pathStr) { // Only need to add if hoshi drawn\n\t\t\t\tsvg.appendChild(besogo.svgEl('path', { // Drawing circles via path points\n\t\t\t\t\td: pathStr, // Hack to allow radius adjustment via stroke-width\n\t\t\t\t\t'stroke-linecap': 'round', // Makes the points round\n\t\t\t\t\t'class': 'besogo-svg-hoshi'\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tfunction drawStar(i, j) { // Extend path string to draw star point\n\t\t\t\tpathStr += \"M\" + svgPos(i) + ',' + svgPos(j) + 'l0,0'; // Draws a point\n\t\t\t}\n\t\t}\n\n\t\t// Remakes the randomized index for stone images\n\t\tfunction randomizeIndex() {\n\t\t\tvar maxIndex = besogo.BLACK_STONES * besogo.WHITE_STONES,\n\t\t\t\ti, j;\n\n\t\t\trandIndex = [];\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\trandIndex[fromXY(i, j)] = Math.floor(Math.random() * maxIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adds a grid of squares to register mouse events\n\t\tfunction addEventTargets() {\n\t\t\tvar element,\n\t\t\t\ti, j;\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\telement = besogo.svgEl(\"rect\", { // Make a transparent event target\n\t\t\t\t\t\tx: svgPos(i) - CELL_SIZE / 2,\n\t\t\t\t\t\ty: svgPos(j) - CELL_SIZE / 2,\n\t\t\t\t\t\twidth: CELL_SIZE,\n\t\t\t\t\t\theight: CELL_SIZE,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t});\n\n\t\t\t\t\t// Add event listeners, using closures to decouple (i, j)\n\t\t\t\t\telement.addEventListener(\"click\", handleClick(i, j));\n\n\t\t\t\t\tif (!TOUCH_FLAG) { // Skip hover listeners for touch interfaces\n\t\t\t\t\t\telement.addEventListener(\"mouseover\", handleOver(i, j));\n\t\t\t\t\t\telement.addEventListener(\"mouseout\", handleOut(i, j));\n\t\t\t\t\t}\n\n\t\t\t\t\tsvg.appendChild(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction handleClick(i, j) { // Returns function for click handling\n\t\t\treturn function(event) {\n\t\t\t\t// Call click handler in editor\n\t\t\t\teditor.click(i, j, event.ctrlKey, event.shiftKey);\n\t\t\t\tif (!TOUCH_FLAG) {\n\t\t\t\t\t(handleOver(i, j))(); // Ensures that any updated tool is visible\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction handleOver(i, j) { // Returns function for mouse over\n\t\t\treturn function() {\n\t\t\t\tvar element = hoverLayer[fromXY(i, j)];\n\t\t\t\tif (element) { // Make tool action visible on hover over\n\t\t\t\t\telement.setAttribute('visibility', 'visible');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction handleOut(i, j) { // Returns function for mouse off\n\t\t\treturn function() {\n\t\t\t\tvar element = hoverLayer[fromXY(i, j)];\n\t\t\t\tif (element) { // Make tool action invisible on hover off\n\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Redraws the stones\n\t\tfunction redrawStones(current) {\n\t\t\tvar group = besogo.svgEl(\"g\"), // New stone layer group\n\t\t\t\tshadowGroup, // Group for shadow layer\n\t\t\t\ti, j, x, y, color; // Scratch iteration variables\n\n\t\t\tif (editor.SHADOWS) { // Add group for shawdows\n\t\t\t\tshadowGroup = besogo.svgShadowGroup();\n\t\t\t\tgroup.appendChild(shadowGroup);\n\t\t\t}\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\tcolor = current.getStone(i, j);\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\n\t\t\t\t\t\tif (editor.REAL_STONES) { // Realistic stone\n\t\t\t\t\t\t\tgroup.appendChild(besogo.realStone(x, y, color, randIndex[fromXY(i, j)]));\n\t\t\t\t\t\t} else { // SVG stone\n\t\t\t\t\t\t\tgroup.appendChild(besogo.svgStone(x, y, color));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (editor.SHADOWS) { // Draw shadows\n\t\t\t\t\t\t\tshadowGroup.appendChild(besogo.svgShadow(x - 2, y - 4));\n\t\t\t\t\t\t\tshadowGroup.appendChild(besogo.svgShadow(x + 2, y + 4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsvg.replaceChild(group, stoneGroup); // Replace the stone group\n\t\t\tstoneGroup = group;\n\t\t}\n\n\t\t// Redraws the markup\n\t\tfunction redrawMarkup(current) {\n\t\t\tvar element, i, j, x, y, // Scratch iteration variables\n\t\t\t\tgroup = besogo.svgEl(\"g\"), // Group holding markup layer elements\n\t\t\t\tlastMove = current.move,\n\t\t\t\tvariants = editor.getVariants(),\n\t\t\t\tmark, // Scratch mark state {0, 1, 2, 3, 4, 5}\n\t\t\t\tstone, // Scratch stone state {0, -1, 1}\n\t\t\t\tcolor; // Scratch color string\n\n\t\t\tmarkupLayer = []; // Clear the references to the old layer\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\tmark = current.getMarkup(i, j);\n\t\t\t\t\tif (mark) {\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\t\t\t\t\t\tstone = current.getStone(i, j);\n\t\t\t\t\t\tcolor = (stone === -1) ? \"white\" : \"black\"; // White on black\n\t\t\t\t\t\tif (lastMove && lastMove.x === i && lastMove.y === j) {\n\t\t\t\t\t\t\t// Mark last move blue or violet if also a variant\n\t\t\t\t\t\t\tcolor = checkVariants(variants, current, i, j) ?\n\t\t\t\t\t\t\t\tbesogo.PURP : besogo.BLUE;\n\t\t\t\t\t\t} else if (checkVariants(variants, current, i, j)) {\n\t\t\t\t\t\t\tcolor = besogo.RED; // Natural variant marks are red\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof mark === 'number') { // Markup is a basic shape\n\t\t\t\t\t\t\tswitch (mark) {\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\telement = besogo.svgCircle(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\telement = besogo.svgSquare(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\telement = besogo.svgTriangle(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\telement = besogo.svgBlock(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // Markup is a label\n\t\t\t\t\t\t\tif (!stone) { // If placing label on empty spot\n\t\t\t\t\t\t\t\telement = makeBacker(x, y);\n\t\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telement = besogo.svgLabel(x, y, color, mark);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\tmarkupLayer[fromXY(i, j)] = element;\n\t\t\t\t\t} // END if (mark)\n\t\t\t\t} // END for j\n\t\t\t} // END for i\n\n\t\t\t// Mark last move with plus if not already marked\n\t\t\tif (lastMove && lastMove.x !== 0 && lastMove.y !== 0) {\n\t\t\t\ti = lastMove.x;\n\t\t\t\tj = lastMove.y;\n\t\t\t\tif (!markupLayer[fromXY(i, j)]) { // Last move not marked\n\t\t\t\t\tcolor = checkVariants(variants, current, i, j) ? besogo.PURP : besogo.BLUE;\n\t\t\t\t\telement = besogo.svgPlus(svgPos(i), svgPos(j), color);\n\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\tmarkupLayer[fromXY(i, j)] = element;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mark variants that have not already been marked above\n\t\t\tmarkRemainingVariants(variants, current, group);\n\n\t\t\tsvg.replaceChild(group, markupGroup); // Replace the markup group\n\t\t\tmarkupGroup = group;\n\t\t} // END function redrawMarkup\n\n\t\tfunction makeBacker(x, y) { // Makes a label markup backer at (x, y)\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: x - CELL_SIZE / 2,\n\t\t\t\ty: y - CELL_SIZE / 2,\n\t\t\t\theight: CELL_SIZE,\n\t\t\t\twidth: CELL_SIZE,\n\t\t\t\topacity: 0.85,\n\t\t\t\tstroke: \"none\",\n\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t});\n\t\t}\n\n\t\t// Checks if (x, y) is in variants\n\t\tfunction checkVariants(variants, current, x, y) {\n\t\t\tvar i, move;\n\t\t\tfor (i = 0; i < variants.length; i++) {\n\t\t\t\tif (variants[i] !== current) { // Skip current (within siblings)\n\t\t\t\t\tmove = variants[i].move;\n\t\t\t\t\tif (move && move.x === x && move.y === y) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Marks variants that have not already been marked\n\t\tfunction markRemainingVariants(variants, current, group) {\n\t\t\tvar element,\n\t\t\t\tmove, // Variant move\n\t\t\t\tlabel, // Variant label\n\t\t\t\tstone, // Stone state\n\t\t\t\ti, x, y; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < variants.length; i++) {\n\t\t\t\tif (variants[i] !== current) { // Skip current (within siblings)\n\t\t\t\t\tmove = variants[i].move;\n\t\t\t\t\t// Check if move, not a pass, and no mark yet\n\t\t\t\t\tif (move && move.x !== 0 && !markupLayer[fromXY(move.x, move.y)]) {\n\t\t\t\t\t\tstone = current.getStone(move.x, move.y);\n\t\t\t\t\t\tx = svgPos(move.x); // Get SVG positions\n\t\t\t\t\t\ty = svgPos(move.y);\n\t\t\t\t\t\tif (!stone) { // If placing label on empty spot\n\t\t\t\t\t\t\telement = makeBacker(x, y);\n\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Label variants with letters A-Z cyclically\n\t\t\t\t\t\tlabel = String.fromCharCode('A'.charCodeAt(0) + (i % 26));\n\t\t\t\t\t\telement = besogo.svgLabel(x, y, besogo.LRED, label);\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\tmarkupLayer[fromXY(move.x, move.y)] = element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function markRemainingVariants\n\n\t\t// Redraws the hover layer\n\t\tfunction redrawHover(current) {\n\t\t\tif (TOUCH_FLAG) {\n\t\t\t\treturn; // Do nothing for touch interfaces\n\t\t\t}\n\n\t\t\tvar element, i, j, x, y, // Scratch iteration variables\n\t\t\t\tgroup = besogo.svgEl(\"g\"), // Group holding hover layer elements\n\t\t\t\ttool = editor.getTool(),\n\t\t\t\tchildren,\n\t\t\t\tstone, // Scratch stone state {0, -1, 1} or move\n\t\t\t\tcolor; // Scratch color string\n\n\t\t\thoverLayer = []; // Clear the references to the old layer\n\t\t\tgroup.setAttribute('opacity', '0.35');\n\n\t\t\tif (tool === 'navOnly') { // Render navOnly hover by iterating over children\n\t\t\t\tchildren = current.children;\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tstone = children[i].move;\n\t\t\t\t\tif (stone && stone.x !== 0) { // Child node is move and not a pass\n\t\t\t\t\t\tx = svgPos(stone.x);\n\t\t\t\t\t\ty = svgPos(stone.y);\n\t\t\t\t\t\telement = besogo.svgStone(x, y, stone.color);\n\t\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\thoverLayer[fromXY(stone.x, stone.y)] = element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { // Render hover for other tools by iterating over grid\n\t\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\t\telement = null;\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\t\t\t\t\t\tstone = current.getStone(i, j);\n\t\t\t\t\t\tcolor = (stone === -1) ? \"white\" : \"black\"; // White on black\n\t\t\t\t\t\tswitch (tool) {\n\t\t\t\t\t\t\tcase 'auto':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, current.nextToMove);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'playB':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, -1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'playW':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addB':\n\t\t\t\t\t\t\t\tif (stone === -1) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = besogo.svgEl('g');\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgStone(x, y, -1));\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgPlus(x, y, besogo.RED));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addW':\n\t\t\t\t\t\t\t\tif (stone === 1) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = besogo.svgEl('g');\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgStone(x, y, 1));\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgPlus(x, y, besogo.RED));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addE':\n\t\t\t\t\t\t\t\tif (stone) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'clrMark':\n\t\t\t\t\t\t\t\tbreak; // Nothing\n\t\t\t\t\t\t\tcase 'circle':\n\t\t\t\t\t\t\t\telement = besogo.svgCircle(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'square':\n\t\t\t\t\t\t\t\telement = besogo.svgSquare(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'triangle':\n\t\t\t\t\t\t\t\telement = besogo.svgTriangle(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'cross':\n\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'block':\n\t\t\t\t\t\t\t\telement = besogo.svgBlock(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'label':\n\t\t\t\t\t\t\t\telement = besogo.svgLabel(x, y, color, editor.getLabel());\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // END switch (tool)\n\t\t\t\t\t\tif (element) {\n\t\t\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t\thoverLayer[fromXY(i, j)] = element;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // END for j\n\t\t\t\t} // END for i\n\t\t\t} // END else\n\n\t\t\tsvg.replaceChild(group, hoverGroup); // Replace the hover layer group\n\t\t\thoverGroup = group;\n\t\t} // END function redrawHover\n\n\t\tfunction svgPos(x) { // Converts (x, y) coordinates to SVG position\n\t\t\treturn BOARD_MARGIN + CELL_SIZE / 2 + (x - 1) * CELL_SIZE;\n\t\t}\n\n\t\tfunction fromXY(x, y) { // Converts (x, y) coordinates to linear index\n\t\t\treturn (x - 1) * sizeY + (y - 1);\n\t\t}\n\t};\n\tbesogo.makeCommentPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar infoTexts = {}, // Holds text nodes for game info properties\n\t\t\tgameInfoTable = document.createElement('table'),\n\t\t\tgameInfoEdit = document.createElement('table'),\n\t\t\tcommentBox = document.createElement('div'),\n\t\t\tcommentEdit = document.createElement('textarea'),\n\t\t\tplayerInfoOrder = 'PW WR WT PB BR BT'.split(' '),\n\t\t\tinfoOrder = 'HA KM RU TM OT GN EV PC RO DT RE ON GC AN US SO CP'.split(' '),\n\t\t\tinfoIds = {\n\t\t\t\tPW: 'White Player',\n\t\t\t\tWR: 'White Rank',\n\t\t\t\tWT: 'White Team',\n\t\t\t\tPB: 'Black Player',\n\t\t\t\tBR: 'Black Rank',\n\t\t\t\tBT: 'Black Team',\n\n\t\t\t\tHA: 'Handicap',\n\t\t\t\tKM: 'Komi',\n\t\t\t\tRU: 'Rules',\n\t\t\t\tTM: 'Timing',\n\t\t\t\tOT: 'Overtime',\n\n\t\t\t\tGN: 'Game Name',\n\t\t\t\tEV: 'Event',\n\t\t\t\tPC: 'Place',\n\t\t\t\tRO: 'Round',\n\t\t\t\tDT: 'Date',\n\n\t\t\t\tRE: 'Result',\n\t\t\t\tON: 'Opening',\n\t\t\t\tGC: 'Comments',\n\n\t\t\t\tAN: 'Annotator',\n\t\t\t\tUS: 'Recorder',\n\t\t\t\tSO: 'Source',\n\t\t\t\tCP: 'Copyright'\n\t\t\t};\n\n\t\tcontainer.appendChild(makeInfoButton());\n\t\tcontainer.appendChild(makeInfoEditButton());\n\t\tcontainer.appendChild(makeCommentButton());\n\t\tcontainer.appendChild(gameInfoTable);\n\t\tcontainer.appendChild(gameInfoEdit);\n\t\tinfoTexts.C = document.createTextNode('');\n\t\tcontainer.appendChild(commentBox);\n\t\tcommentBox.appendChild(infoTexts.C);\n\t\tcontainer.appendChild(commentEdit);\n\n\t\tcommentEdit.onblur = function() {\n\t\t\teditor.setComment(commentEdit.value);\n\t\t};\n\t\tcommentEdit.addEventListener('keydown', function(evt) {\n\t\t\tevt = evt || window.event;\n\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t});\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tgameInfo: editor.getGameInfo()\n\t\t});\n\t\tgameInfoEdit.style.display = 'none'; // Hide game info editting table initially\n\n\t\tfunction update(msg) {\n\t\t\tvar temp; // Scratch for strings\n\n\t\t\tif (msg.navChange) {\n\t\t\t\ttemp = editor.getCurrent().comment || '';\n\t\t\t\tupdateText(commentBox, temp, 'C');\n\t\t\t\tif (editor.getCurrent() === editor.getRoot() &&\n\t\t\t\t\tgameInfoTable.firstChild &&\n\t\t\t\t\tgameInfoEdit.style.display === 'none') {\n\t\t\t\t\tgameInfoTable.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tcommentEdit.style.display = 'none';\n\t\t\t\tcommentBox.style.display = 'block';\n\t\t\t} else if (msg.comment !== undefined) {\n\t\t\t\tupdateText(commentBox, msg.comment, 'C');\n\t\t\t\tcommentEdit.value = msg.comment;\n\t\t\t}\n\n\t\t\tif (msg.gameInfo) { // Update game info\n\t\t\t\tupdateGameInfoTable(msg.gameInfo);\n\t\t\t\tupdateGameInfoEdit(msg.gameInfo);\n\t\t\t}\n\t\t} // END function update\n\n\t\tfunction updateGameInfoTable(gameInfo) {\n\t\t\tvar table = document.createElement('table'),\n\t\t\t\ti, id, row, cell, text; // Scratch iteration variable\n\n\t\t\ttable.className = 'besogo-gameInfo';\n\t\t\tfor (i = 0; i < infoOrder.length; i++) { // Iterate in specified order\n\t\t\t\tid = infoOrder[i];\n\n\t\t\t\tif (gameInfo[id]) { // Only add row if property exists\n\t\t\t\t\trow = document.createElement('tr');\n\t\t\t\t\ttable.appendChild(row);\n\n\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\tcell.appendChild(document.createTextNode(infoIds[id]));\n\t\t\t\t\trow.appendChild(cell);\n\n\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\ttext = document.createTextNode(gameInfo[id]);\n\t\t\t\t\tcell.appendChild(text);\n\t\t\t\t\trow.appendChild(cell);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!table.firstChild || gameInfoTable.style.display === 'none') {\n\t\t\t\ttable.style.display = 'none'; // Do not display empty table or if already hidden\n\t\t\t}\n\t\t\tcontainer.replaceChild(table, gameInfoTable);\n\t\t\tgameInfoTable = table;\n\t\t}\n\n\t\tfunction updateGameInfoEdit(gameInfo) {\n\t\t\tvar table = document.createElement('table'),\n\t\t\t\tinfoTableOrder = playerInfoOrder.concat(infoOrder),\n\t\t\t\ti, id, row, cell, text;\n\n\t\t\ttable.className = 'besogo-gameInfo';\n\t\t\tfor (i = 0; i < infoTableOrder.length; i++) { // Iterate in specified order\n\t\t\t\tid = infoTableOrder[i];\n\t\t\t\trow = document.createElement('tr');\n\t\t\t\ttable.appendChild(row);\n\n\t\t\t\tcell = document.createElement('td');\n\t\t\t\tcell.appendChild(document.createTextNode(infoIds[id]));\n\t\t\t\trow.appendChild(cell);\n\n\t\t\t\tcell = document.createElement('td');\n\t\t\t\ttext = document.createElement('input');\n\t\t\t\tif (gameInfo[id]) {\n\t\t\t\t\ttext.value = gameInfo[id];\n\t\t\t\t}\n\t\t\t\ttext.onblur = function(t, id) {\n\t\t\t\t\treturn function() { // Commit change on blur\n\t\t\t\t\t\teditor.setGameInfo(t.value, id);\n\t\t\t\t\t};\n\t\t\t\t}(text, id);\n\t\t\t\ttext.addEventListener('keydown', function(evt) {\n\t\t\t\t\tevt = evt || window.event;\n\t\t\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t\t\t});\n\t\t\t\tcell.appendChild(text);\n\t\t\t\trow.appendChild(cell);\n\t\t\t}\n\t\t\tif (gameInfoEdit.style.display === 'none') {\n\t\t\t\ttable.style.display = 'none'; // Hide if already hidden\n\t\t\t}\n\t\t\tcontainer.replaceChild(table, gameInfoEdit);\n\t\t\tgameInfoEdit = table;\n\t\t}\n\n\t\tfunction updateText(parent, text, id) {\n\t\t\tvar textNode = document.createTextNode(text);\n\t\t\tparent.replaceChild(textNode, infoTexts[id]);\n\t\t\tinfoTexts[id] = textNode;\n\t\t}\n\n\t\tfunction makeInfoButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Info';\n\t\t\tbutton.title = 'Show/hide game info';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (gameInfoTable.style.display === 'none' && gameInfoTable.firstChild) {\n\t\t\t\t\tgameInfoTable.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tgameInfoEdit.style.display = 'none';\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t\tfunction makeInfoEditButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Edit Info';\n\t\t\tbutton.title = 'Edit game info';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (gameInfoEdit.style.display === 'none') {\n\t\t\t\t\tgameInfoEdit.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoEdit.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t\tfunction makeCommentButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Comment';\n\t\t\tbutton.title = 'Edit comment';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (commentEdit.style.display === 'none') { // Comment edit box hidden\n\t\t\t\t\tcommentBox.style.display = 'none'; // Hide static comment display\n\t\t\t\t\tgameInfoTable.style.display = 'none'; // Hide game info table\n\t\t\t\t\tcommentEdit.value = editor.getCurrent().comment;\n\t\t\t\t\tcommentEdit.style.display = 'block'; // Show comment edit box\n\t\t\t\t} else { // Comment edit box open\n\t\t\t\t\tcommentEdit.style.display = 'none'; // Hide comment edit box\n\t\t\t\t\tcommentBox.style.display = 'block'; // Show static comment display\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t};\n\tbesogo.makeControlPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar leftElements = [], // SVG elements for previous node buttons\n\t\t\trightElements = [], // SVG elements for next node buttons\n\t\t\tsiblingElements = [], // SVG elements for sibling buttons\n\t\t\tvariantStyleButton, // Button for changing variant style\n\t\t\thideVariantButton, // Button for toggling show/hide variants\n\t\t\tchildVariantElement, // SVG element for child style variants\n\t\t\tsiblingVariantElement, // SVG element for sibling style variants\n\t\t\thideVariantElement; // SVG element for hiding variants\n\n\t\tdrawNavButtons();\n\t\tdrawStyleButtons();\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tvariantStyle: editor.getVariantStyle()\n\t\t}); // Initialize\n\n\t\t// Callback for variant style and nav state changes\n\t\tfunction update(msg) {\n\t\t\tvar current;\n\n\t\t\tif (msg.variantStyle !== undefined) {\n\t\t\t\tupdateStyleButtons(msg.variantStyle);\n\t\t\t}\n\n\t\t\tif (msg.navChange || msg.treeChange) { // Update the navigation buttons\n\t\t\t\tcurrent = editor.getCurrent();\n\t\t\t\tif (current.parent) { // Has parent\n\t\t\t\t\tarraySetColor(leftElements, 'black');\n\t\t\t\t\tif (current.parent.children.length > 1) { // Has siblings\n\t\t\t\t\t\tarraySetColor(siblingElements, 'black');\n\t\t\t\t\t} else { // No siblings\n\t\t\t\t\t\tarraySetColor(siblingElements, besogo.GREY);\n\t\t\t\t\t}\n\t\t\t\t} else { // No parent\n\t\t\t\t\tarraySetColor(leftElements, besogo.GREY);\n\t\t\t\t\tarraySetColor(siblingElements, besogo.GREY);\n\t\t\t\t}\n\t\t\t\tif (current.children.length) { // Has children\n\t\t\t\t\tarraySetColor(rightElements, 'black');\n\t\t\t\t} else { // No children\n\t\t\t\t\tarraySetColor(rightElements, besogo.GREY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction updateStyleButtons(style) { // Updates the variant style buttons\n\t\t\t\tif (style % 2) { // Sibling style variants\n\t\t\t\t\tchildVariantElement.setAttribute('fill', 'black');\n\t\t\t\t\tsiblingVariantElement.setAttribute('fill', besogo.BLUE);\n\t\t\t\t\tvariantStyleButton.title = 'Variants: child/[sibling]';\n\t\t\t\t} else { // Child style variants\n\t\t\t\t\tchildVariantElement.setAttribute('fill', besogo.BLUE);\n\t\t\t\t\tsiblingVariantElement.setAttribute('fill', besogo.RED);\n\t\t\t\t\tvariantStyleButton.title = 'Variants: [child]/sibling';\n\t\t\t\t}\n\t\t\t\tif (style >= 2) { // Hide auto-markup for variants\n\t\t\t\t\thideVariantElement.setAttribute('visibility', 'visible');\n\t\t\t\t\thideVariantButton.title = 'Variants: show/[hide]';\n\t\t\t\t} else { // Show auto-markup for variants\n\t\t\t\t\thideVariantElement.setAttribute('visibility', 'hidden');\n\t\t\t\t\thideVariantButton.title = 'Variants: [show]/hide';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction arraySetColor(list, color) { // Changes fill color of list of svg elements\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < list.length; i++) {\n\t\t\t\t\tlist[i].setAttribute('fill', color);\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function update\n\n\t\t// Draws the navigation buttons\n\t\tfunction drawNavButtons() {\n\t\t\tleftElements.push(makeNavButton('First node',\n\t\t\t\t'5,10 5,90 25,90 25,50 95,90 95,10 25,50 25,10',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.prevNode(-1);\n\t\t\t\t}));\n\t\t\tleftElements.push(makeNavButton('Jump back',\n\t\t\t\t'95,10 50,50 50,10 5,50 50,90 50,50 95,90',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.prevNode(10);\n\t\t\t\t}));\n\t\t\tleftElements.push(makeNavButton('Previous node', '85,10 85,90 15,50', function() {\n\t\t\t\teditor.prevNode(1);\n\t\t\t}));\n\n\t\t\trightElements.push(makeNavButton('Next node', '15,10 15,90 85,50', function() {\n\t\t\t\teditor.nextNode(1);\n\t\t\t}));\n\t\t\trightElements.push(makeNavButton('Jump forward',\n\t\t\t\t'5,10 50,50 50,10 95,50 50,90 50,50 5,90',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.nextNode(10);\n\t\t\t\t}));\n\t\t\trightElements.push(makeNavButton('Last node',\n\t\t\t\t'95,10 95,90 75,90 75,50 5,90 5,10 75,50 75,10',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.nextNode(-1);\n\t\t\t\t}));\n\n\t\t\tsiblingElements.push(makeNavButton('Previous sibling', '10,85 90,85 50,15', function() {\n\t\t\t\teditor.nextSibling(-1);\n\t\t\t}));\n\t\t\tsiblingElements.push(makeNavButton('Next sibling', '10,15 90,15 50,85', function() {\n\t\t\t\teditor.nextSibling(1);\n\t\t\t}));\n\n\t\t\tfunction makeNavButton(tooltip, pointString, action) { // Creates a navigation button\n\t\t\t\tvar button = document.createElement('button'),\n\t\t\t\t\tsvg = makeButtonContainer(),\n\t\t\t\t\telement = besogo.svgEl(\"polygon\", {\n\t\t\t\t\t\tpoints: pointString,\n\t\t\t\t\t\tstroke: 'none',\n\t\t\t\t\t\tfill: 'black'\n\t\t\t\t\t});\n\n\t\t\t\tbutton.title = tooltip;\n\t\t\t\tbutton.onclick = action;\n\t\t\t\tbutton.appendChild(svg);\n\t\t\t\tsvg.appendChild(element);\n\t\t\t\tcontainer.appendChild(button);\n\n\t\t\t\treturn element;\n\t\t\t} // END function makeNavButton\n\t\t} // END function drawNavButtons\n\n\t\t// Draws the variant style buttons\n\t\tfunction drawStyleButtons() {\n\t\t\tvar svg, element, coordStyleButton;\n\n\t\t\tvariantStyleButton = document.createElement('button');\n\t\t\tvariantStyleButton.onclick = function() {\n\t\t\t\teditor.toggleVariantStyle(false); // Toggles child/sibling variants\n\t\t\t};\n\t\t\tcontainer.appendChild(variantStyleButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\tvariantStyleButton.appendChild(svg);\n\t\t\telement = besogo.svgEl(\"path\", {\n\t\t\t\td: 'm75,25h-50l50,50',\n\t\t\t\tstroke: 'black',\n\t\t\t\t\"stroke-width\": 5,\n\t\t\t\tfill: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(element);\n\t\t\tchildVariantElement = besogo.svgEl('circle', {\n\t\t\t\tcx: 25,\n\t\t\t\tcy: 25,\n\t\t\t\tr: 20,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(childVariantElement);\n\t\t\tsiblingVariantElement = besogo.svgEl('circle', {\n\t\t\t\tcx: 75,\n\t\t\t\tcy: 25,\n\t\t\t\tr: 20,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(siblingVariantElement);\n\t\t\telement = besogo.svgEl('circle', {\n\t\t\t\tcx: 75,\n\t\t\t\tcy: 75,\n\t\t\t\tr: 20,\n\t\t\t\tfill: besogo.RED,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(element);\n\n\t\t\thideVariantButton = document.createElement('button');\n\t\t\thideVariantButton.onclick = function() {\n\t\t\t\teditor.toggleVariantStyle(true); // Toggles show/hide variants\n\t\t\t};\n\t\t\tcontainer.appendChild(hideVariantButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\thideVariantButton.appendChild(svg);\n\t\t\tsvg.appendChild(besogo.svgLabel(50, 50, besogo.RED, 'A'));\n\t\t\thideVariantElement = besogo.svgCross(50, 50, 'black');\n\t\t\tsvg.appendChild(hideVariantElement);\n\n\t\t\tcoordStyleButton = document.createElement('button');\n\t\t\tcoordStyleButton.onclick = function() {\n\t\t\t\teditor.toggleCoordStyle(); // Toggles coordinate style\n\t\t\t};\n\t\t\tcoordStyleButton.title = 'Toggle coordinates';\n\t\t\tcontainer.appendChild(coordStyleButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\tcoordStyleButton.appendChild(svg);\n\t\t\tsvg.appendChild(besogo.svgLabel(50, 50, 'black', '4'));\n\t\t} // END function drawStyleButtons\n\n\t\t// Makes an SVG container for the button graphics\n\t\tfunction makeButtonContainer() {\n\t\t\treturn besogo.svgEl('svg', {\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%',\n\t\t\t\tviewBox: \"0 0 100 100\"\n\t\t\t});\n\t\t}\n\t};\n\t(function() {\n\t\t'use strict';\n\n\t\t// Parent object to hold coordinate system helper functions\n\t\tbesogo.coord = {};\n\n\t\t// Null function for no coordinate system\n\t\tbesogo.coord.none = function(sizeX, sizeY) {\n\t\t\treturn false;\n\t\t};\n\n\t\t// Western, chess-like, \"A1\" coordinate system\n\t\tbesogo.coord.western = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = numberToLetter(i);\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Simple purely numeric coordinate system\n\t\tbesogo.coord.numeric = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = i + '';\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = i + '';\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Corner-relative, alpha-numeric, coordinate system\n\t\tbesogo.coord.corner = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tif (i < (sizeX / 2) + 1) {\n\t\t\t\t\tlabels.x[i] = numberToLetter(i);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.x[i] = (sizeX - i + 1) + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t\tif (i > (sizeY / 2)) {\n\t\t\t\t\tlabels.y[i] = numberToLetter(sizeY - i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.y[i] = i + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Corner-relative, numeric and CJK, coordinate system\n\t\tbesogo.coord.eastcor = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tif (i < (sizeX / 2) + 1) {\n\t\t\t\t\tlabels.x[i] = numberToCJK(i);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.x[i] = (sizeX - i + 1) + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t\tif (i > (sizeY / 2)) {\n\t\t\t\t\tlabels.y[i] = numberToCJK(sizeY - i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.y[i] = i + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Eastern, numeric and CJK, coordinate system\n\t\tbesogo.coord.eastern = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = i + ''; // Columns are numeric\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = numberToCJK(i);\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Helper for converting numeric coord to letter (skipping I)\n\t\tfunction numberToLetter(number) {\n\t\t\treturn 'ABCDEFGHJKLMNOPQRSTUVWXYZ'.charAt((number - 1) % 25);\n\t\t}\n\n\t\t// Helper for converting numeric coord to CJK symbol\n\t\tfunction numberToCJK(number) {\n\t\t\tvar label = '',\n\t\t\t\tcjk = '';\n\n\t\t\tif (number >= 20) { // 20 and larger\n\t\t\t\tlabel = cjk.charAt(number / 10 - 1) + '';\n\t\t\t} else if (number >= 10) { // 10 through 19\n\t\t\t\tlabel = '';\n\t\t\t}\n\t\t\tif (number % 10) { // Ones digit if non-zero\n\t\t\t\tlabel = label + cjk.charAt((number - 1) % 10);\n\t\t\t}\n\t\t\treturn label;\n\t\t}\n\n\t})(); // END closure\n\tbesogo.makeEditor = function(sizeX, sizeY) {\n\t\t'use strict';\n\t\t// Creates an associated game state tree\n\t\tvar root = besogo.makeGameRoot(sizeX, sizeY),\n\t\t\tcurrent = root, // Navigation cursor\n\n\t\t\tlisteners = [], // Listeners of general game/editor state changes\n\n\t\t\t// Enumeration of editor tools/modes\n\t\t\tTOOLS = ['navOnly', // read-only navigate mode\n\t\t\t\t'auto', // auto-mode: navigate or auto-play color\n\t\t\t\t'playB', // play black stone\n\t\t\t\t'playW', // play white stone\n\t\t\t\t'addB', // setup black stone\n\t\t\t\t'addW', // setup white stone\n\t\t\t\t'addE', // setup empty stone\n\t\t\t\t'clrMark', // remove markup\n\t\t\t\t'circle', // circle markup\n\t\t\t\t'square', // square markup\n\t\t\t\t'triangle', // triangle markup\n\t\t\t\t'cross', // \"X\" cross markup\n\t\t\t\t'block', // filled square markup\n\t\t\t\t'label'\n\t\t\t], // label markup\n\t\t\ttool = 'auto', // Currently active tool (default: auto-mode)\n\t\t\tlabel = \"1\", // Next label that will be applied\n\n\t\t\tnavHistory = [], // Navigation history\n\n\t\t\tgameInfo = {}, // Game info properties\n\n\t\t\t// Order of coordinate systems\n\t\t\tCOORDS = 'none numeric western eastern corner eastcor'.split(' '),\n\t\t\tcoord = 'none', // Selected coordinate system\n\n\t\t\t// Variant style: even/odd - children/siblings, <2 - show auto markup for variants\n\t\t\tvariantStyle = 0; // 0-3, 0 is default\n\n\t\treturn {\n\t\t\taddListener: addListener,\n\t\t\tclick: click,\n\t\t\tnextNode: nextNode,\n\t\t\tprevNode: prevNode,\n\t\t\tnextSibling: nextSibling,\n\t\t\ttoggleCoordStyle: toggleCoordStyle,\n\t\t\tgetCoordStyle: getCoordStyle,\n\t\t\tsetCoordStyle: setCoordStyle,\n\t\t\ttoggleVariantStyle: toggleVariantStyle,\n\t\t\tgetVariantStyle: getVariantStyle,\n\t\t\tsetVariantStyle: setVariantStyle,\n\t\t\tgetGameInfo: getGameInfo,\n\t\t\tsetGameInfo: setGameInfo,\n\t\t\tsetComment: setComment,\n\t\t\tgetTool: getTool,\n\t\t\tsetTool: setTool,\n\t\t\tgetLabel: getLabel,\n\t\t\tsetLabel: setLabel,\n\t\t\tgetVariants: getVariants, // Returns variants of current node\n\t\t\tgetCurrent: getCurrent,\n\t\t\tsetCurrent: setCurrent,\n\t\t\tcutCurrent: cutCurrent,\n\t\t\tgetRoot: getRoot,\n\t\t\tloadRoot: loadRoot // Loads new game state\n\t\t};\n\n\t\t// Returns the active tool\n\t\tfunction getTool() {\n\t\t\treturn tool;\n\t\t}\n\n\t\t// Sets the active tool, returns false if failed\n\t\tfunction setTool(set) {\n\t\t\t// Toggle label mode if already label tool already selected\n\t\t\tif (set === 'label' && set === tool) {\n\t\t\t\tif (/^-?\\d+$/.test(label)) { // If current label is integer\n\t\t\t\t\tsetLabel('A'); // Toggle to characters\n\t\t\t\t} else {\n\t\t\t\t\tsetLabel('1'); // Toggle back to numbers\n\t\t\t\t}\n\t\t\t\treturn true; // Notification already handled by setLabel\n\t\t\t}\n\t\t\t// Set the tool only if in list and actually changed\n\t\t\tif (TOOLS.indexOf(set) !== -1 && tool !== set) {\n\t\t\t\ttool = set;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\ttool: tool,\n\t\t\t\t\tlabel: label\n\t\t\t\t}); // Notify tool change\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Gets the next label to apply\n\t\tfunction getLabel() {\n\t\t\treturn label;\n\t\t}\n\n\t\t// Sets the next label to apply and sets active tool to label\n\t\tfunction setLabel(set) {\n\t\t\tif (typeof set === 'string') {\n\t\t\t\tset = set.replace(/\\s/g, ' ').trim(); // Convert all whitespace to space and trim\n\t\t\t\tlabel = set || \"1\"; // Default to \"1\" if empty string\n\t\t\t\ttool = 'label'; // Also change current tool to label\n\t\t\t\tnotifyListeners({\n\t\t\t\t\ttool: tool,\n\t\t\t\t\tlabel: label\n\t\t\t\t}); // Notify tool/label change\n\t\t\t}\n\t\t}\n\n\t\t// Toggle the coordinate style\n\t\tfunction toggleCoordStyle() {\n\t\t\tcoord = COORDS[(COORDS.indexOf(coord) + 1) % COORDS.length];\n\t\t\tnotifyListeners({\n\t\t\t\tcoord: coord\n\t\t\t});\n\t\t}\n\n\t\t// Gets the current coordinate style\n\t\tfunction getCoordStyle() {\n\t\t\treturn coord;\n\t\t}\n\n\t\t// Sets the coordinate system style\n\t\tfunction setCoordStyle(setCoord) {\n\t\t\tif (besogo.coord[setCoord]) {\n\t\t\t\tcoord = setCoord;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tcoord: setCoord\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Toggles the style for showing variants\n\t\tfunction toggleVariantStyle(toggleShow) {\n\t\t\tvar childStyle = variantStyle % 2, // 0: children, 1: siblings\n\t\t\t\tshowStyle = variantStyle - childStyle; // 0: show auto-markup, 2: hide\n\t\t\tif (toggleShow) { // Truthy input toggles showing of auto-markup\n\t\t\t\tshowStyle = (showStyle + 2) % 4; // 0 => 2 or 2 => 0\n\t\t\t} else { // Falsy input toggles child vs sibling style\n\t\t\t\tchildStyle = (childStyle + 1) % 2; // 0 => 1 or 1 => 0\n\t\t\t}\n\t\t\tvariantStyle = childStyle + showStyle;\n\t\t\tnotifyListeners({\n\t\t\t\tvariantStyle: variantStyle,\n\t\t\t\tmarkupChange: true\n\t\t\t});\n\t\t}\n\n\t\t// Returns the variant style\n\t\tfunction getVariantStyle() {\n\t\t\treturn variantStyle;\n\t\t}\n\n\t\t// Directly sets the variant style\n\t\tfunction setVariantStyle(style) {\n\t\t\tif (style === 0 || style === 1 || style === 2 || style === 3) {\n\t\t\t\tvariantStyle = style;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tvariantStyle: variantStyle,\n\t\t\t\t\tmarkupChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction getGameInfo() {\n\t\t\treturn gameInfo;\n\t\t}\n\n\t\tfunction setGameInfo(info, id) {\n\t\t\tif (id) {\n\t\t\t\tgameInfo[id] = info;\n\t\t\t} else {\n\t\t\t\tgameInfo = info;\n\t\t\t}\n\t\t\tnotifyListeners({\n\t\t\t\tgameInfo: gameInfo\n\t\t\t});\n\t\t}\n\n\t\tfunction setComment(text) {\n\t\t\ttext = text.trim(); // Trim whitespace and standardize line breaks\n\t\t\ttext = text.replace(/\\r\\n/g, '\\n').replace(/\\n\\r/g, '\\n').replace(/\\r/g, '\\n');\n\t\t\ttext.replace(/\\f\\t\\v\\u0085\\u00a0/g, ' '); // Convert other whitespace to space\n\t\t\tcurrent.comment = text;\n\t\t\tnotifyListeners({\n\t\t\t\tcomment: text\n\t\t\t});\n\t\t}\n\n\t\t// Returns variants of the current node according to the set style\n\t\tfunction getVariants() {\n\t\t\tif (variantStyle >= 2) { // Do not show variants if style >= 2\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tif (variantStyle === 1) { // Display sibling variants\n\t\t\t\t// Root node does not have parent nor siblings\n\t\t\t\treturn current.parent ? current.parent.children : [];\n\t\t\t}\n\t\t\treturn current.children; // Otherwise, style must be 0, display child variants\n\t\t}\n\n\t\t// Returns the currently active node in the game state tree\n\t\tfunction getCurrent() {\n\t\t\treturn current;\n\t\t}\n\n\t\t// Returns the root of the game state tree\n\t\tfunction getRoot() {\n\t\t\treturn root;\n\t\t}\n\n\t\tfunction loadRoot(load) {\n\t\t\troot = load;\n\t\t\tcurrent = load;\n\t\t\tnotifyListeners({\n\t\t\t\ttreeChange: true,\n\t\t\t\tnavChange: true,\n\t\t\t\tstoneChange: true\n\t\t\t});\n\t\t}\n\n\t\t// Navigates forward num nodes (to the end if num === -1)\n\t\tfunction nextNode(num) {\n\t\t\tif (current.children.length === 0) { // Check if no children\n\t\t\t\treturn false; // Do nothing if no children (avoid notification)\n\t\t\t}\n\t\t\twhile (current.children.length > 0 && num !== 0) {\n\t\t\t\tif (navHistory.length) { // Non-empty navigation history\n\t\t\t\t\tcurrent = navHistory.pop();\n\t\t\t\t} else { // Empty navigation history\n\t\t\t\t\tcurrent = current.children[0]; // Go to first child\n\t\t\t\t}\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\tnotifyListeners({\n\t\t\t\tnavChange: true\n\t\t\t}, true); // Preserve history\n\t\t}\n\n\t\t// Navigates backward num nodes (to the root if num === -1)\n\t\tfunction prevNode(num) {\n\t\t\tif (current.parent === null) { // Check if root\n\t\t\t\treturn false; // Do nothing if already at root (avoid notification)\n\t\t\t}\n\t\t\twhile (current.parent && num !== 0) {\n\t\t\t\tnavHistory.push(current); // Save current into navigation history\n\t\t\t\tcurrent = current.parent;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\tnotifyListeners({\n\t\t\t\tnavChange: true\n\t\t\t}, true); // Preserve history\n\t\t}\n\n\t\t// Cyclically switches through siblings\n\t\tfunction nextSibling(change) {\n\t\t\tvar siblings,\n\t\t\t\ti = 0;\n\n\t\t\tif (current.parent) {\n\t\t\t\tsiblings = current.parent.children;\n\n\t\t\t\t// Exit early if only child\n\t\t\t\tif (siblings.length === 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Find index of current amongst siblings\n\t\t\t\ti = siblings.indexOf(current);\n\n\t\t\t\t// Apply change cyclically\n\t\t\t\ti = (i + change) % siblings.length;\n\t\t\t\tif (i < 0) {\n\t\t\t\t\ti += siblings.length;\n\t\t\t\t}\n\n\t\t\t\tcurrent = siblings[i];\n\t\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tnavChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Sets the current node\n\t\tfunction setCurrent(node) {\n\t\t\tif (current !== node) {\n\t\t\t\tcurrent = node;\n\t\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tnavChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Removes current branch from the tree\n\t\tfunction cutCurrent() {\n\t\t\tvar parent = current.parent;\n\t\t\tif (tool === 'navOnly') {\n\t\t\t\treturn; // Tree editing disabled in navOnly mode\n\t\t\t}\n\t\t\tif (parent) {\n\t\t\t\tif (confirm(\"Delete this branch?\") === true) {\n\t\t\t\t\tparent.removeChild(current);\n\t\t\t\t\tcurrent = parent;\n\t\t\t\t\t// Notify navigation and tree edited\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle click with application of selected tool\n\t\tfunction click(i, j, ctrlKey, shiftKey) {\n\t\t\tswitch (tool) {\n\t\t\t\tcase 'navOnly':\n\t\t\t\t\tnavigate(i, j, shiftKey);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'auto':\n\t\t\t\t\tif (!navigate(i, j, shiftKey) && !shiftKey) { // Try to navigate to (i, j)\n\t\t\t\t\t\tplayMove(i, j, 0, ctrlKey); // Play auto-color move if navigate fails\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'playB':\n\t\t\t\t\tplayMove(i, j, -1, ctrlKey); // Black move\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'playW':\n\t\t\t\t\tplayMove(i, j, 1, ctrlKey); // White move\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addB':\n\t\t\t\t\tplaceSetup(i, j, -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addW':\n\t\t\t\t\tplaceSetup(i, j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addE':\n\t\t\t\t\tplaceSetup(i, j, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'clrMark':\n\t\t\t\t\tsetMarkup(i, j, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'circle':\n\t\t\t\t\tsetMarkup(i, j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'square':\n\t\t\t\t\tsetMarkup(i, j, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'triangle':\n\t\t\t\t\tsetMarkup(i, j, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cross':\n\t\t\t\t\tsetMarkup(i, j, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'block':\n\t\t\t\t\tsetMarkup(i, j, 5);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'label':\n\t\t\t\t\tsetMarkup(i, j, label);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Navigates to child with move at (x, y), searching tree if shiftKey pressed\n\t\t// Returns true is successful, false if not\n\t\tfunction navigate(x, y, shiftKey) {\n\t\t\tvar i, move,\n\t\t\t\tchildren = current.children;\n\n\t\t\t// Look for move at same location in children\n\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\tmove = children[i].move;\n\t\t\t\tif (move && move.x === x && move.y === y) {\n\t\t\t\t\tcurrent = children[i]; // Navigate to child if found\n\t\t\t\t\t// Notify navigation (with no tree edits)\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\tnavChange: true\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Plays a move at the given color and location\n\t\t// Set allowAll to truthy to allow illegal moves\n\t\tfunction playMove(i, j, color, allowAll) {\n\t\t\tvar next;\n\t\t\t// Check if current node is immutable or root\n\t\t\tif (!current.isMutable('move') || !current.parent) {\n\t\t\t\tnext = current.makeChild(); // Create a new child node\n\t\t\t\tif (next.playMove(i, j, color, allowAll)) { // Play in new node\n\t\t\t\t\t// Keep (add to game state tree) only if move succeeds\n\t\t\t\t\tcurrent.addChild(next);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t\t// Notify tree change, navigation, and stone change\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true,\n\t\t\t\t\t\tstoneChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// Current node is mutable and not root\n\t\t\t} else if (current.playMove(i, j, color, allowAll)) { // Play in current\n\t\t\t\t// Only need to update if move succeeds\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tstoneChange: true\n\t\t\t\t}); // Stones changed\n\t\t\t}\n\t\t}\n\n\t\t// Places a setup stone at the given color and location\n\t\tfunction placeSetup(i, j, color) {\n\t\t\tvar next;\n\t\t\tif (color === current.getStone(i, j)) { // Compare setup to current\n\t\t\t\tif (color !== 0) {\n\t\t\t\t\tcolor = 0; // Same as current indicates removal desired\n\t\t\t\t} else { // Color and current are both empty\n\t\t\t\t\treturn; // No change if attempting to set empty to empty\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if current node can accept setup stones\n\t\t\tif (!current.isMutable('setup')) {\n\t\t\t\tnext = current.makeChild(); // Create a new child node\n\t\t\t\tif (next.placeSetup(i, j, color)) { // Place setup stone in new node\n\t\t\t\t\t// Keep (add to game state tree) only if change occurs\n\t\t\t\t\tcurrent.addChild(next);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t\t// Notify tree change, navigation, and stone change\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true,\n\t\t\t\t\t\tstoneChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (current.placeSetup(i, j, color)) { // Try setup in current\n\t\t\t\t// Only need to update if change occurs\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tstoneChange: true\n\t\t\t\t}); // Stones changed\n\t\t\t}\n\t\t}\n\n\t\t// Sets the markup at the given location and place\n\t\tfunction setMarkup(i, j, mark) {\n\t\t\tvar temp; // For label incrementing\n\t\t\tif (mark === current.getMarkup(i, j)) { // Compare mark to current\n\t\t\t\tif (mark !== 0) {\n\t\t\t\t\tmark = 0; // Same as current indicates removal desired\n\t\t\t\t} else { // Mark and current are both empty\n\t\t\t\t\treturn; // No change if attempting to set empty to empty\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (current.addMarkup(i, j, mark)) { // Try to add the markup\n\t\t\t\tif (typeof mark === 'string') { // If markup is a label, increment the label\n\t\t\t\t\tif (/^-?\\d+$/.test(mark)) { // Integer number label\n\t\t\t\t\t\ttemp = +mark; // Convert to number\n\t\t\t\t\t\t// Increment and convert back to string\n\t\t\t\t\t\tsetLabel(\"\" + (temp + 1));\n\t\t\t\t\t} else if (/[A-Za-z]$/.test(mark)) { // Ends with [A-Za-z]\n\t\t\t\t\t\t// Get the last character in the label\n\t\t\t\t\t\ttemp = mark.charAt(mark.length - 1);\n\t\t\t\t\t\tif (temp === 'z') { // Cyclical increment\n\t\t\t\t\t\t\ttemp = 'A'; // Move onto uppercase letters\n\t\t\t\t\t\t} else if (temp === 'Z') {\n\t\t\t\t\t\t\ttemp = 'a'; // Move onto lowercase letters\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp = String.fromCharCode(temp.charCodeAt() + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Replace last character of label with incremented char\n\t\t\t\t\t\tsetLabel(mark.slice(0, mark.length - 1) + temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tmarkupChange: true\n\t\t\t\t}); // Notify markup change\n\t\t\t}\n\t\t}\n\n\t\t// Adds a listener (by call back func) that will be notified on game/editor state changes\n\t\tfunction addListener(listener) {\n\t\t\tlisteners.push(listener);\n\t\t}\n\n\t\t// Notify listeners with the given message object\n\t\t//  Data sent to listeners:\n\t\t//    tool: changed tool selection\n\t\t//    label: changed next label\n\t\t//    coord: changed coordinate system \n\t\t//    variantStyle: changed variant style\n\t\t//    gameInfo: changed game info\n\t\t//    comment: changed comment in current node\n\t\t//  Flags sent to listeners:\n\t\t//    treeChange: nodes added or removed from tree\n\t\t//    navChange: current switched to different node\n\t\t//    stoneChange: stones modified in current node\n\t\t//    markupChange: markup modified in current node\n\t\tfunction notifyListeners(msg, keepHistory) {\n\t\t\tvar i;\n\t\t\tif (!keepHistory && msg.navChange) {\n\t\t\t\tnavHistory = []; // Clear navigation history\n\t\t\t}\n\t\t\tfor (i = 0; i < listeners.length; i++) {\n\t\t\t\tlisteners[i](msg);\n\t\t\t}\n\t\t}\n\t};\n\tbesogo.makeFilePanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar fileChooser, // Reference to the file chooser element\n\t\t\telement, // Scratch variable for creating elements\n\t\t\tWARNING = \"Everything not saved will be lost\";\n\n\t\tmakeNewBoardButton(9); // New 9x9 board button\n\t\tmakeNewBoardButton(13); // New 13x13 board button\n\t\tmakeNewBoardButton(19); // New 19x19 board button\n\t\tmakeNewBoardButton('?'); // New custom board button\n\n\t\t// Hidden file chooser element\n\t\tfileChooser = makeFileChooser();\n\t\tcontainer.appendChild(fileChooser);\n\n\t\t// Load file button\n\t\telement = document.createElement('input');\n\t\telement.type = 'button';\n\t\telement.value = 'Open';\n\t\telement.title = 'Import SGF';\n\t\telement.onclick = function() { // Bind click to the hidden file chooser\n\t\t\tfileChooser.click();\n\t\t};\n\t\tcontainer.appendChild(element);\n\n\t\t// Save file button\n\t\telement = document.createElement('input');\n\t\telement.type = 'button';\n\t\telement.value = 'Save';\n\t\telement.title = 'Export SGF';\n\t\telement.onclick = function() {\n\t\t\tvar fileName = prompt('Save file as', 'export.sgf');\n\t\t\tif (fileName) { // Canceled or empty string does nothing\n\t\t\t\tsaveFile(fileName, besogo.composeSgf(editor));\n\t\t\t}\n\t\t};\n\t\tcontainer.appendChild(element);\n\n\n\t\t// Makes a new board button\n\t\tfunction makeNewBoardButton(size) {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = size + \"x\" + size;\n\t\t\tif (size === '?') { // Make button for custom sized board\n\t\t\t\tbutton.title = \"New custom size board\";\n\t\t\t\tbutton.onclick = function() {\n\t\t\t\t\tvar input = prompt(\"Enter custom size for new board\" + \"\\n\" + WARNING, \"19:19\"),\n\t\t\t\t\t\tsize;\n\t\t\t\t\tif (input) { // Canceled or empty string does nothing\n\t\t\t\t\t\tsize = besogo.parseSize(input);\n\t\t\t\t\t\teditor.loadRoot(besogo.makeGameRoot(size.x, size.y));\n\t\t\t\t\t\teditor.setGameInfo({});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else { // Make button for fixed size board\n\t\t\t\tbutton.title = \"New \" + size + \"x\" + size + \" board\";\n\t\t\t\tbutton.onclick = function() {\n\t\t\t\t\tif (confirm(button.title + \"?\\n\" + WARNING)) {\n\t\t\t\t\t\teditor.loadRoot(besogo.makeGameRoot(size, size));\n\t\t\t\t\t\teditor.setGameInfo({});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tcontainer.appendChild(button);\n\t\t}\n\n\t\t// Creates the file selector\n\t\tfunction makeFileChooser() {\n\t\t\tvar chooser = document.createElement('input');\n\t\t\tchooser.type = 'file';\n\t\t\tchooser.style.display = 'none'; // Keep hidden\n\t\t\tchooser.onchange = readFile; // Read, parse and load on file select\n\t\t\treturn chooser;\n\t\t}\n\n\t\t// Reads, parses and loads an SGF file\n\t\tfunction readFile(evt) {\n\t\t\tvar file = evt.target.files[0], // Selected file\n\t\t\t\treader = new FileReader(),\n\t\t\t\tnewChooser = makeFileChooser(); // Create new file input to reset selection\n\n\t\t\tcontainer.replaceChild(newChooser, fileChooser); // Replace with the reset selector\n\t\t\tfileChooser = newChooser;\n\n\t\t\treader.onload = function(e) { // Parse and load game tree\n\t\t\t\tvar sgf;\n\t\t\t\ttry {\n\t\t\t\t\tsgf = besogo.parseSgf(e.target.result);\n\t\t\t\t} catch (error) {\n\t\t\t\t\talert('SGF parse error at ' + error.at + ':\\n' + error.message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbesogo.loadSgf(sgf, editor);\n\t\t\t};\n\t\t\tif (confirm(\"Load '\" + file.name + \"'?\\n\" + WARNING)) {\n\t\t\t\treader.readAsText(file); // Initiate file read\n\t\t\t}\n\t\t}\n\n\t\t// Composes SGF file and initializes download\n\t\tfunction saveFile(fileName, text) {\n\t\t\tvar link = document.createElement('a'),\n\t\t\t\tblob = new Blob([text], {\n\t\t\t\t\tencoding: \"UTF-8\",\n\t\t\t\t\ttype: \"text/plain;charset=UTF-8\"\n\t\t\t\t});\n\n\t\t\tlink.download = fileName; // Set download file name\n\t\t\tlink.href = URL.createObjectURL(blob);\n\t\t\tlink.style.display = 'none'; // Make link hidden\n\t\t\tcontainer.appendChild(link); // Add link to ensure that clicking works\n\t\t\tlink.click(); // Click on link to initiate download\n\t\t\tcontainer.removeChild(link); // Immediately remove the link\n\t\t}\n\t};\n\tbesogo.makeGameRoot = function(sizeX, sizeY) {\n\t\t'use strict';\n\t\tvar BLACK = -1, // Stone state constants\n\t\t\tWHITE = 1, // Equal to -BLACK\n\t\t\tEMPTY = 0, // Any falsy (e.g., undefined) value is also empty\n\n\t\t\troot = { // Inherited attributes of root node\n\t\t\t\tnextToMove: BLACK,\n\t\t\t\tblackCaps: 0,\n\t\t\t\twhiteCaps: 0,\n\t\t\t\tmoveNumber: 0\n\t\t\t};\n\n\t\t// Initializes non-inherited attributes\n\t\tfunction initNode(node, parent) {\n\t\t\tnode.parent = parent;\n\t\t\tnode.children = [];\n\n\t\t\tnode.move = null;\n\t\t\tnode.setupStones = [];\n\t\t\tnode.markup = [];\n\t\t\tnode.comment = ''; // Comment on this node\n\t\t}\n\t\tinitNode(root, null); // Initialize root node with null parent\n\n\n\t\t// Plays a move, returns true if successful\n\t\t// Set allow to truthy to allow overwrite, suicide and ko\n\t\troot.playMove = function(x, y, color, allow) {\n\t\t\tvar captures = 0, // Number of captures made by this move\n\t\t\t\toverwrite = false, // Flags whether move overwrites a stone\n\t\t\t\tprevMove, // Previous move for ko check\n\t\t\t\ttestBoard, // Copy of board state to test captures, ko, and suicide\n\t\t\t\tpending, // Pending capture locations\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!this.isMutable('move')) {\n\t\t\t\treturn false; // Move fails if node is immutable\n\t\t\t}\n\n\t\t\tif (!color) { // Falsy color indicates auto-color\n\t\t\t\tcolor = this.nextToMove;\n\t\t\t}\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\tthis.move = { // Register as pass move if out of bounds\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0, // Log pass as position (0, 0)\n\t\t\t\t\tcolor: color,\n\t\t\t\t\tcaptures: 0, // Pass never captures\n\t\t\t\t\toverwrite: false // Pass is never an overwrite\n\t\t\t\t};\n\t\t\t\tthis.nextToMove = -color; // Update next to move\n\t\t\t\tthis.moveNumber++; // Increment move number\n\t\t\t\treturn true; // Pass move successful\n\t\t\t}\n\n\t\t\tif (this.getStone(x, y)) { // Check for overwrite\n\t\t\t\tif (!allow) {\n\t\t\t\t\treturn false; // Reject overwrite move if not allowed\n\t\t\t\t}\n\t\t\t\toverwrite = true; // Otherwise, flag overwrite and proceed\n\t\t\t}\n\n\t\t\ttestBoard = Object.create(this); // Copy board state (no need to initialize)\n\t\t\tpending = []; // Initialize pending capture array\n\n\t\t\tsetStone(testBoard, x, y, color); // Place the move stone\n\n\t\t\t// Check for captures of surrounding chains\n\t\t\tcaptureStones(testBoard, x - 1, y, color, pending);\n\t\t\tcaptureStones(testBoard, x + 1, y, color, pending);\n\t\t\tcaptureStones(testBoard, x, y - 1, color, pending);\n\t\t\tcaptureStones(testBoard, x, y + 1, color, pending);\n\n\t\t\tcaptures = pending.length; // Capture count\n\n\t\t\tprevMove = this.parent ? this.parent.move : null; // Previous move played\n\t\t\tif (!allow && prevMove && // If previous move exists, ...\n\t\t\t\tprevMove.color === -color && // was of the opposite color, ...\n\t\t\t\tprevMove.overwrite === false && // not an overwrite, ...\n\t\t\t\tprevMove.captures === 1 && // captured exactly one stone, and if ...\n\t\t\t\tcaptures === 1 && // this move captured exactly one stone at the location ...\n\t\t\t\t!testBoard.getStone(prevMove.x, prevMove.y)) { // of the previous move\n\t\t\t\treturn false; // Reject ko move if not allowed\n\t\t\t}\n\n\t\t\tif (captures === 0) { // Check for suicide if nothing was captured\n\t\t\t\tcaptureStones(testBoard, x, y, -color, pending); // Invert color for suicide check\n\t\t\t\tcaptures = -pending.length; // Count suicide as negative captures\n\t\t\t\tif (captures < 0 && !allow) {\n\t\t\t\t\treturn false; // Reject suicidal move if not allowed\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (color * captures < 0) { // Capture by black or suicide by white\n\t\t\t\tthis.blackCaps += Math.abs(captures); // Tally captures for black\n\t\t\t} else { // Capture by white or suicide by black\n\t\t\t\tthis.whiteCaps += Math.abs(captures); // Tally captures for white\n\t\t\t}\n\n\t\t\tsetStone(this, x, y, color); // Place the stone\n\t\t\tfor (i = 0; i < pending.length; i++) { // Remove the captures\n\t\t\t\tsetStone(this, pending[i].x, pending[i].y, EMPTY);\n\t\t\t}\n\n\t\t\tthis.move = { // Log the move\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tcolor: color,\n\t\t\t\tcaptures: captures,\n\t\t\t\toverwrite: overwrite\n\t\t\t};\n\t\t\tthis.nextToMove = -color; // Update next to move\n\t\t\tthis.moveNumber++; // Increment move number\n\t\t\treturn true;\n\t\t}; // END func root.playMove\n\n\t\t// Check for and perform capture of opposite color chain at (x, y)\n\t\tfunction captureStones(board, x, y, color, captures) {\n\t\t\tvar pending = [],\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!recursiveCapture(board, x, y, color, pending)) { // Captured chain found\n\t\t\t\tfor (i = 0; i < pending.length; i++) { // Remove captured stones\n\t\t\t\t\tsetStone(board, pending[i].x, pending[i].y, EMPTY);\n\t\t\t\t\tcaptures.push(pending[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Recursively builds a chain of pending captures starting from (x, y)\n\t\t// Stops and returns true if chain has liberties\n\t\tfunction recursiveCapture(board, x, y, color, pending) {\n\t\t\tvar i; // Scratch iteration variable\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Stop if out of bounds\n\t\t\t}\n\t\t\tif (board.getStone(x, y) === color) {\n\t\t\t\treturn false; // Stop if other color found\n\t\t\t}\n\t\t\tif (!board.getStone(x, y)) {\n\t\t\t\treturn true; // Stop and signal that liberty was found\n\t\t\t}\n\t\t\tfor (i = 0; i < pending.length; i++) {\n\t\t\t\tif (pending[i].x === x && pending[i].y === y) {\n\t\t\t\t\treturn false; // Stop if already in pending captures\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpending.push({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t}); // Add new stone into chain of pending captures\n\n\t\t\t// Recursively check for liberties and expand chain\n\t\t\tif (recursiveCapture(board, x - 1, y, color, pending) ||\n\t\t\t\trecursiveCapture(board, x + 1, y, color, pending) ||\n\t\t\t\trecursiveCapture(board, x, y - 1, color, pending) ||\n\t\t\t\trecursiveCapture(board, x, y + 1, color, pending)) {\n\t\t\t\treturn true; // Stop and signal liberty found in subchain\n\t\t\t}\n\t\t\treturn false; // Otherwise, no liberties found\n\t\t}\n\n\t\t// Places a setup stone, returns true if successful\n\t\troot.placeSetup = function(x, y, color) {\n\t\t\tvar prevColor = (this.parent && this.parent.getStone(x, y)) || EMPTY;\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Do not allow out of bounds setup\n\t\t\t}\n\t\t\tif (!this.isMutable('setup') || this.getStone(x, y) === color) {\n\t\t\t\t// Prevent setup changes in immutable node or quit early if no change\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsetStone(this, x, y, color); // Place the setup stone\n\t\t\tthis.setupStones[fromXY(x, y)] = color - prevColor; // Record the necessary change\n\t\t\treturn true;\n\t\t};\n\n\t\t// Adds markup, returns true if successful\n\t\troot.addMarkup = function(x, y, mark) {\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Do not allow out of bounds markup\n\t\t\t}\n\t\t\tif (this.getMarkup(x, y) === mark) { // Quit early if no change to make\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.markup[fromXY(x, y)] = mark;\n\t\t\treturn true;\n\t\t};\n\n\t\t// Returns the stone status of the given position\n\t\troot.getStone = function(x, y) {\n\t\t\treturn this['board' + x + '-' + y] || EMPTY;\n\t\t};\n\n\t\t// Directly sets the stone state for the given game node\n\t\tfunction setStone(node, x, y, color) {\n\t\t\tnode['board' + x + '-' + y] = color;\n\t\t}\n\n\t\t// Gets the setup stone placed at (x, y), returns false if none\n\t\troot.getSetup = function(x, y) {\n\t\t\tif (!this.setupStones[fromXY(x, y)]) { // No setup stone placed\n\t\t\t\treturn false;\n\t\t\t} else { // Determine net effect of setup stone\n\t\t\t\tswitch (this.getStone(x, y)) {\n\t\t\t\t\tcase EMPTY:\n\t\t\t\t\t\treturn 'AE';\n\t\t\t\t\tcase BLACK:\n\t\t\t\t\t\treturn 'AB';\n\t\t\t\t\tcase WHITE:\n\t\t\t\t\t\treturn 'AW';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Gets the markup at (x, y)\n\t\troot.getMarkup = function(x, y) {\n\t\t\treturn this.markup[fromXY(x, y)] || EMPTY;\n\t\t};\n\n\t\t// Determines the type of this node\n\t\troot.getType = function() {\n\t\t\tvar i;\n\n\t\t\tif (this.move) { // Logged move implies move node\n\t\t\t\treturn 'move';\n\t\t\t}\n\n\t\t\tfor (i = 0; i < this.setupStones.length; i++) {\n\t\t\t\tif (this.setupStones[i]) { // Any setup stones implies setup node\n\t\t\t\t\treturn 'setup';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'empty'; // Otherwise, \"empty\" (neither move nor setup)\n\t\t};\n\n\t\t// Checks if this node can be modified by a 'type' action\n\t\troot.isMutable = function(type) {\n\t\t\t// Can only add a move to an empty node with no children\n\t\t\tif (type === 'move' && this.getType() === 'empty' && this.children.length === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Can only add setup stones to a non-move node with no children\n\t\t\tif (type === 'setup' && this.getType() !== 'move' && this.children.length === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// Gets siblings of this node\n\t\troot.getSiblings = function() {\n\t\t\treturn (this.parent && this.parent.children) || [];\n\t\t};\n\n\t\t// Makes a child node of this node, but does NOT add it to children\n\t\troot.makeChild = function() {\n\t\t\tvar child = Object.create(this); // Child inherits properties\n\t\t\tinitNode(child, this); // Initialize other properties\n\n\t\t\treturn child;\n\t\t};\n\n\t\t// Adds a child to this node\n\t\troot.addChild = function(child) {\n\t\t\tthis.children.push(child);\n\t\t};\n\n\t\t// Remove child node from this node, returning false if failed\n\t\troot.removeChild = function(child) {\n\t\t\tvar i = this.children.indexOf(child);\n\t\t\tif (i !== -1) {\n\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// Gets board size\n\t\troot.getSize = function() {\n\t\t\treturn {\n\t\t\t\tx: sizeX,\n\t\t\t\ty: sizeY\n\t\t\t};\n\t\t};\n\n\t\treturn root;\n\n\t\t// Convert (x, y) coordinates to linear index\n\t\tfunction fromXY(x, y) {\n\t\t\treturn (x - 1) * sizeY + (y - 1);\n\t\t}\n\t};\n\t// Load a parsed SGF object into a game state tree\n\tbesogo.loadSgf = function(sgf, editor) {\n\t\t'use strict';\n\t\tvar size = {\n\t\t\t\tx: 19,\n\t\t\t\ty: 19\n\t\t\t}, // Default size (may be changed by load)\n\t\t\troot;\n\n\t\tloadRootProps(sgf); // Load size, variants style and game info\n\t\troot = besogo.makeGameRoot(size.x, size.y);\n\n\t\tloadNodeTree(sgf, root); // Load the rest of game tree\n\t\teditor.loadRoot(root); // Load root into the editor\n\n\n\t\t// Loads the game tree\n\t\tfunction loadNodeTree(sgfNode, gameNode) {\n\t\t\tvar i, nextGameNode;\n\n\t\t\t// Load properties from the SGF node into the game state node\n\t\t\tfor (i = 0; i < sgfNode.props.length; i++) {\n\t\t\t\tloadProp(gameNode, sgfNode.props[i]);\n\t\t\t}\n\n\t\t\t// Recursively load the rest of the tree\n\t\t\tfor (i = 0; i < sgfNode.children.length; i++) {\n\t\t\t\tnextGameNode = gameNode.makeChild();\n\t\t\t\tgameNode.addChild(nextGameNode);\n\t\t\t\tloadNodeTree(sgfNode.children[i], nextGameNode);\n\t\t\t}\n\t\t}\n\n\t\t// Loads property into node\n\t\tfunction loadProp(node, prop) {\n\t\t\tvar setupFunc = 'placeSetup',\n\t\t\t\tmarkupFunc = 'addMarkup',\n\t\t\t\tmove;\n\n\t\t\tswitch (prop.id) {\n\t\t\t\tcase 'B': // Play a black move\n\t\t\t\t\tmove = lettersToCoords(prop.values[0]);\n\t\t\t\t\tnode.playMove(move.x, move.y, -1, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W': // Play a white move\n\t\t\t\t\tmove = lettersToCoords(prop.values[0]);\n\t\t\t\t\tnode.playMove(move.x, move.y, 1, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AB': // Setup black stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AW': // Setup white stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AE': // Setup empty stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'CR': // Add circle markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SQ': // Add square markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'TR': // Add triangle markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M': // Intentional fallthrough treats 'M' as 'MA'\n\t\t\t\tcase 'MA': // Add 'X' cross markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SL': // Add 'selected' (small filled square) markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 5);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L': // Intentional fallthrough treats 'L' as 'LB'\n\t\t\t\tcase 'LB': // Add label markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 'label');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C': // Comment placed on node\n\t\t\t\t\tif (node.comment) {\n\t\t\t\t\t\tnode.comment += '\\n' + prop.values.join().trim();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.comment = prop.values.join().trim();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} // END function loadProp\n\n\t\t// Extracts point list and calls func on each\n\t\t// Set param to 'label' to signal handling of label markup property\n\t\tfunction applyPointList(values, node, func, param) {\n\t\t\tvar i, x, y, // Scratch iteration variables\n\t\t\t\tpoint, // Current point in iteration\n\t\t\t\totherPoint, // Bottom-right point of compressed point lists\n\t\t\t\tlabel; // Label extracted from value\n\t\t\tfor (i = 0; i < values.length; i++) {\n\t\t\t\tpoint = lettersToCoords(values[i].slice(0, 2));\n\t\t\t\tif (param === 'label') { // Label markup property\n\t\t\t\t\tlabel = values[i].slice(3).replace(/\\n/g, ' ');\n\t\t\t\t\tnode[func](point.x, point.y, label); // Apply with extracted label\n\t\t\t\t} else { // Not a label markup property\n\t\t\t\t\tif (values[i].charAt(2) === ':') { // Expand compressed point list\n\t\t\t\t\t\totherPoint = lettersToCoords(values[i].slice(3));\n\t\t\t\t\t\tif (otherPoint.x === point.x && otherPoint.y === point.y) {\n\t\t\t\t\t\t\t// Redundant compressed pointlist\n\t\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t\t} else if (otherPoint.x < point.x || otherPoint.y < point.y) {\n\t\t\t\t\t\t\t// Only apply to corners if not arranged properly\n\t\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t\t\tnode[func](otherPoint.x, otherPoint.y, param);\n\t\t\t\t\t\t} else { // Iterate over the compressed points\n\t\t\t\t\t\t\tfor (x = point.x; x <= otherPoint.x; x++) {\n\t\t\t\t\t\t\t\tfor (y = point.y; y <= otherPoint.y; y++) {\n\t\t\t\t\t\t\t\t\tnode[func](x, y, param);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // Apply on single point\n\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function applyPointList\n\n\t\t// Loads root properties (size, variant style and game info)\n\t\tfunction loadRootProps(node) {\n\t\t\tvar gameInfoIds = ['PB', 'BR', 'BT', 'PW', 'WR', 'WT', // Player info\n\t\t\t\t\t'HA', 'KM', 'RU', 'TM', 'OT', // Game parameters\n\t\t\t\t\t'DT', 'EV', 'GN', 'PC', 'RO', // Event info\n\t\t\t\t\t'GC', 'ON', 'RE', // General comments\n\t\t\t\t\t'AN', 'CP', 'SO', 'US'\n\t\t\t\t], // IP credits\n\t\t\t\tgameInfo = {}, // Structure for game info properties\n\t\t\t\ti, id, value; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < node.props.length; i++) {\n\t\t\t\tid = node.props[i].id; // Property ID\n\t\t\t\tvalue = node.props[i].values.join().trim(); // Join the values array\n\t\t\t\tif (id === 'SZ') { // Size property\n\t\t\t\t\tsize = besogo.parseSize(value);\n\t\t\t\t} else if (id === 'ST') { // Style property\n\t\t\t\t\teditor.setVariantStyle(+value); // Converts value to number\n\t\t\t\t} else if (gameInfoIds.indexOf(id) !== -1) { // Game info property\n\t\t\t\t\tif (id !== 'GC') { // Treat all but GC as simpletext\n\t\t\t\t\t\tvalue = value.replace(/\\n/g, ' '); // Convert line breaks to spaces\n\t\t\t\t\t}\n\t\t\t\t\tif (value) { // Skip load of empty game info strings\n\t\t\t\t\t\tgameInfo[id] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teditor.setGameInfo(gameInfo);\n\t\t}\n\n\t\t// Converts letters to numerical coordinates\n\t\tfunction lettersToCoords(letters) {\n\t\t\tif (letters.match(/^[A-Za-z]{2}$/)) { // Verify input is two letters\n\t\t\t\treturn {\n\t\t\t\t\tx: charToNum(letters.charAt(0)),\n\t\t\t\t\ty: charToNum(letters.charAt(1))\n\t\t\t\t};\n\t\t\t} else { // Anything but two letters\n\t\t\t\treturn {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t}; // Return (0, 0) coordinates\n\t\t\t}\n\t\t}\n\n\t\tfunction charToNum(c) { // Helper for lettersToCoords\n\t\t\tif (c.match(/[A-Z]/)) { // Letters A-Z to 27-52\n\t\t\t\treturn c.charCodeAt(0) - 'A'.charCodeAt(0) + 27;\n\t\t\t} else { // Letters a-z to 1-26\n\t\t\t\treturn c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n\t\t\t}\n\t\t}\n\t};\n\tbesogo.makeNamesPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar playerBox = document.createElement('div'),\n\t\t\twhiteBox = document.createElement('div'),\n\t\t\tblackBox = document.createElement('div'),\n\t\t\twhiteInfo = document.createTextNode(''),\n\t\t\tblackInfo = document.createTextNode(''),\n\t\t\twhiteCaps = document.createElement('span'),\n\t\t\tblackCaps = document.createElement('span');\n\n\t\tplayerBox.className = 'besogo-playerInfo';\n\t\twhiteBox.className = 'besogo-whiteInfo';\n\t\tblackBox.className = 'besogo-blackInfo';\n\t\twhiteCaps.className = 'besogo-whiteCaps';\n\t\twhiteCaps.title = 'White captures';\n\t\tblackCaps.className = 'besogo-blackCaps';\n\t\tblackCaps.title = 'Black captures';\n\t\twhiteBox.appendChild(whiteInfo);\n\t\twhiteBox.appendChild(whiteCaps);\n\t\tblackBox.appendChild(blackInfo);\n\t\tblackBox.appendChild(blackCaps);\n\t\tplayerBox.appendChild(whiteBox);\n\t\tplayerBox.appendChild(blackBox);\n\t\tcontainer.appendChild(playerBox);\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tgameInfo: editor.getGameInfo()\n\t\t});\n\n\t\tfunction update(msg) {\n\t\t\tvar infoString, // Scratch string\n\t\t\t\ttextNode,\n\t\t\t\tcurrent,\n\t\t\t\tpassFlag = 0;\n\n\t\t\tif (msg.gameInfo) {\n\t\t\t\tinfoString = (msg.gameInfo.PW || 'White') + // White name\n\t\t\t\t\t' (' + (msg.gameInfo.WR || '?') + ')' + // White rank\n\t\t\t\t\t(msg.gameInfo.WT ? ' ' + msg.gameInfo.WT : ''); // White team\n\t\t\t\ttextNode = document.createTextNode(infoString);\n\t\t\t\twhiteBox.replaceChild(textNode, whiteInfo);\n\t\t\t\twhiteInfo = textNode;\n\n\t\t\t\tinfoString = (msg.gameInfo.PB || 'Black') + // Black name\n\t\t\t\t\t' (' + (msg.gameInfo.BR || '?') + ')' + // Black rank\n\t\t\t\t\t(msg.gameInfo.BT ? ' ' + msg.gameInfo.BT : ''); // Black team\n\t\t\t\ttextNode = document.createTextNode(infoString);\n\t\t\t\tblackBox.replaceChild(textNode, blackInfo);\n\t\t\t\tblackInfo = textNode;\n\t\t\t}\n\n\t\t\tif (msg.navChange || msg.stoneChange) {\n\t\t\t\tcurrent = editor.getCurrent();\n\t\t\t\tif (current.move && current.move.x === 0 && current.move.y === 0) {\n\t\t\t\t\tpassFlag = current.move.color;\n\t\t\t\t}\n\t\t\t\tupdateText(whiteCaps, (passFlag === 1 ? 'Passed  ' : '') + current.whiteCaps);\n\t\t\t\tupdateText(blackCaps, current.blackCaps + (passFlag === -1 ? '  Passed' : ''));\n\t\t\t}\n\t\t}\n\n\t\tfunction updateText(parent, text) {\n\t\t\tvar textNode = document.createTextNode(text);\n\t\t\twhile (parent.firstChild) {\n\t\t\t\tparent.removeChild(parent.firstChild);\n\t\t\t}\n\t\t\tparent.appendChild(textNode);\n\t\t}\n\t};\n\tbesogo.parseSgf = function(text) {\n\t\t'use strict';\n\t\tvar at = 0, // Current position\n\t\t\tch = text.charAt(at); // Current character at position\n\n\t\tfindOpenParens(); // Find beginning of game tree\n\t\treturn parseTree(); // Parse game tree\n\n\t\t// Builds and throws an error\n\t\tfunction error(msg) {\n\t\t\tthrow {\n\t\t\t\tname: \"Syntax Error\",\n\t\t\t\tmessage: msg,\n\t\t\t\tat: at,\n\t\t\t\ttext: text\n\t\t\t};\n\t\t}\n\n\t\t// Advances text position by one\n\t\tfunction next(check) {\n\t\t\tif (check && check !== ch) { // Verify current character if param given\n\t\t\t\terror(\"Expected '\" + check + \"' instead of '\" + ch + \"'\");\n\t\t\t}\n\t\t\tat++;\n\t\t\tch = text.charAt(at);\n\t\t\treturn ch;\n\t\t}\n\n\t\t// Skips over whitespace until non-whitespace found\n\t\tfunction white() {\n\t\t\twhile (ch && ch <= ' ') {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t\t// Skips all chars until '(' or end found\n\t\tfunction findOpenParens() {\n\t\t\twhile (ch && ch !== '(') {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t\t// Returns true if line break (CR, LF, CR+LF, LF+CR) found\n\t\t// Advances the cursor ONCE for double character (CR+LF, LF+CR) line breaks\n\t\tfunction lineBreak() {\n\t\t\tif (ch === '\\n') { // Line Feed (LF)\n\t\t\t\tif (text.charAt(at + 1) === '\\r') { // LF+CR, double character line break\n\t\t\t\t\tnext(); // Advance cursor only once (pointing at second character)\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (ch === '\\r') { // Carriage Return (CR)\n\t\t\t\tif (text.charAt(at + 1) === '\\n') { // CR+LF, double character line break\n\t\t\t\t\tnext(); // Advance cursor only once (pointing at second character)\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false; // Did not find a line break or advance\n\t\t}\n\n\t\t// Parses a sub-tree of the game record\n\t\tfunction parseTree() {\n\t\t\tvar rootNode, // Root of this sub-tree\n\t\t\t\tcurrentNode, // Pointer to parent of the next node\n\t\t\t\tnextNode; // Scratch for parsing the next node or sub-tree\n\n\t\t\tnext('('); // Double-check opening parens at start of sub-tree\n\t\t\twhite(); // Skip whitespace before root node\n\n\t\t\tif (ch !== \";\") { // Error on sub-tree missing root node\n\t\t\t\terror(\"Sub-tree missing root\");\n\t\t\t}\n\t\t\trootNode = parseNode(); // Get the first node of this sub-tree\n\t\t\twhite(); // Skip whitespace before parsing next node\n\n\t\t\tcurrentNode = rootNode; // Parent of the next node parsed\n\t\t\twhile (ch === ';') { // Get sequence of nodes within this sub-tree\n\t\t\t\tnextNode = parseNode(); // Parse the next node\n\t\t\t\t// Add next node as child of current\n\t\t\t\tcurrentNode.children.push(nextNode);\n\t\t\t\tcurrentNode = nextNode; // Advance current pointer to this child\n\t\t\t\twhite(); // Skip whitespace between/after sequence nodes\n\t\t\t}\n\n\t\t\t// Look for sub-trees of this sub-tree\n\t\t\twhile (ch === \"(\") {\n\t\t\t\tnextNode = parseTree(); // Parse the next sub-tree\n\t\t\t\t// Add sub-tree as child of last sequence node\n\t\t\t\tcurrentNode.children.push(nextNode); // Do NOT advance current\n\t\t\t\twhite(); // Skip whitespace between/after sub-trees\n\t\t\t}\n\t\t\tnext(')'); // Expect closing parenthesis at end of this sub-tree\n\n\t\t\treturn rootNode;\n\t\t}\n\n\t\t// Parses a node and its properties\n\t\tfunction parseNode() {\n\t\t\tvar property, // Scratch for parsing properties\n\t\t\t\tnode = {\n\t\t\t\t\tprops: [],\n\t\t\t\t\tchildren: []\n\t\t\t\t}; // Node to construct\n\n\t\t\tnext(';'); // Double-check semi-colon at start of node\n\t\t\twhite(); // Skip whitespace before properties\n\t\t\t// Parse properties until end of node detected\n\t\t\twhile (ch && ch !== ';' && ch !== '(' && ch !== ')') {\n\t\t\t\tproperty = parseProperty(); // Parse the property and values\n\t\t\t\tnode.props.push(property); // Add property to node\n\t\t\t\twhite(); // Skip whitespace between/after properties\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\n\t\t// Parses a property and its values\n\t\tfunction parseProperty() {\n\t\t\tvar property = {\n\t\t\t\tid: '',\n\t\t\t\tvalues: []\n\t\t\t}; // Property to construct\n\n\t\t\t// Look for property ID within letters\n\t\t\twhile (ch && /[A-Za-z]/.test(ch)) {\n\t\t\t\tif (/[A-Z]/.test(ch)) { // Ignores lower case letters\n\t\t\t\t\tproperty.id += ch; // Only adds upper case letters\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t}\n\t\t\tif (!property.id) { // Error if id empty\n\t\t\t\terror('Missing property ID');\n\t\t\t}\n\n\t\t\twhite(); // Skip whitespace before values\n\t\t\twhile (ch === '[') { // Look for values of this property\n\t\t\t\tproperty.values.push(parseValue());\n\t\t\t\twhite(); // Skip whitespace between/after values\n\t\t\t}\n\t\t\tif (property.values.length === 0) { // Error on empty list of values\n\t\t\t\terror('Missing property values');\n\t\t\t}\n\n\t\t\treturn property;\n\t\t}\n\n\t\t// Parses a value\n\t\tfunction parseValue() {\n\t\t\tvar value = '';\n\t\t\tnext('['); // Double-check opening bracket at start of value\n\n\t\t\t// Read until end of value (unescaped closing bracket)\n\t\t\twhile (ch && ch !== ']') {\n\t\t\t\tif (ch === '\\\\') { // Backslash escape handling\n\t\t\t\t\tnext('\\\\');\n\t\t\t\t\tif (lineBreak()) { // Soft (escaped) line break\n\t\t\t\t\t\t// Nothing, soft line breaks are removed\n\t\t\t\t\t} else if (ch <= ' ') { // Other whitespace\n\t\t\t\t\t\tvalue += ' '; // Convert to space\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += ch; // Pass other escaped characters verbatim\n\t\t\t\t\t}\n\t\t\t\t} else { // Non-escaped character\n\t\t\t\t\tif (lineBreak()) { // Hard (non-escaped) line break\n\t\t\t\t\t\tvalue += '\\n'; // Convert all new lines to just LF\n\t\t\t\t\t} else if (ch <= ' ') { // Other whitespace\n\t\t\t\t\t\tvalue += ' '; // Convert to space\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += ch; // Other characters\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t}\n\t\t\tnext(']'); // Expect closing bracket at end of value\n\n\t\t\treturn value;\n\t\t}\n\t};\n\t// Convert game state tree into SGF string\n\tbesogo.composeSgf = function(editor) {\n\t\t'use strict';\n\t\treturn '(' + composeNode(editor.getRoot()) + ')';\n\n\t\t// Recursively composes game node tree\n\t\tfunction composeNode(tree) {\n\t\t\tvar string = ';', // Node starts with semi-colon\n\t\t\t\tchildren = tree.children,\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!tree.parent) { // Null parent means node is root\n\t\t\t\t// Compose root-specific properties\n\t\t\t\tstring += composeRootProps(tree);\n\t\t\t}\n\t\t\tstring += composeNodeProps(tree); // Compose general properties\n\n\t\t\t// Recurse composition on child nodes\n\t\t\tif (children.length === 1) { // Continue sequence if only one child\n\t\t\t\tstring += '\\n' + composeNode(children[0]);\n\t\t\t} else if (children.length > 1) {\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tstring += '\\n(' + composeNode(children[i]) + ')';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn string;\n\t\t}\n\n\t\t// Composes root specific properties\n\t\tfunction composeRootProps(tree) {\n\t\t\tvar string = 'FF[4]GM[1]CA[UTF-8]AP[besogo:' + besogo.VERSION + ']',\n\t\t\t\tx = tree.getSize().x,\n\t\t\t\ty = tree.getSize().y,\n\t\t\t\tgameInfo = editor.getGameInfo(), // Game info structure\n\t\t\t\thasGameInfo = false, // Flag for existence of game info\n\t\t\t\tid; // Scratch iteration variable\n\n\t\t\tif (x === y) { // Square board size\n\t\t\t\tstring += 'SZ[' + x + ']';\n\t\t\t} else { // Non-square board size\n\t\t\t\tstring += 'SZ[' + x + ':' + y + ']';\n\t\t\t}\n\t\t\tstring += 'ST[' + editor.getVariantStyle() + ']\\n'; // Line break after header\n\n\t\t\tfor (id in gameInfo) { // Compose game info properties\n\t\t\t\tif (gameInfo.hasOwnProperty(id) && gameInfo[id]) { // Skip empty strings\n\t\t\t\t\tstring += id + '[' + escapeText(gameInfo[id]) + ']';\n\t\t\t\t\thasGameInfo = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += (hasGameInfo ? '\\n' : ''); // Line break if game info exists\n\n\t\t\treturn string;\n\t\t}\n\n\t\t// Composes other properties\n\t\tfunction composeNodeProps(node) {\n\t\t\tvar string = '',\n\t\t\t\tprops, // Scratch variable for property structures\n\t\t\t\tstone, i, j; // Scratch iteration variables\n\n\t\t\t// Compose either move or setup properties depending on type of node\n\t\t\tif (node.getType() === 'move') { // Compose move properties\n\t\t\t\tstone = node.move;\n\t\t\t\tstring += (stone.color === 1) ? 'W' : 'B';\n\t\t\t\tstring += '[' + coordsToLetters(stone.x, stone.y) + ']';\n\t\t\t} else if (node.getType() === 'setup') { // Compose setup properties\n\t\t\t\tprops = {\n\t\t\t\t\tAB: [],\n\t\t\t\t\tAW: [],\n\t\t\t\t\tAE: []\n\t\t\t\t};\n\t\t\t\tfor (i = 1; i <= node.getSize().x; i++) {\n\t\t\t\t\tfor (j = 1; j <= node.getSize().y; j++) {\n\t\t\t\t\t\tstone = node.getSetup(i, j);\n\t\t\t\t\t\tif (stone) { // If setup stone placed, add to structure\n\t\t\t\t\t\t\tprops[stone].push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstring += composePointLists(props);\n\t\t\t}\n\n\t\t\t// Compose markup properties\n\t\t\tprops = {\n\t\t\t\tCR: [],\n\t\t\t\tSQ: [],\n\t\t\t\tTR: [],\n\t\t\t\tMA: [],\n\t\t\t\tSL: [],\n\t\t\t\tLB: []\n\t\t\t};\n\t\t\tfor (i = 1; i <= node.getSize().x; i++) {\n\t\t\t\tfor (j = 1; j <= node.getSize().y; j++) {\n\t\t\t\t\tstone = node.getMarkup(i, j);\n\t\t\t\t\tif (stone) { // If markup placed\n\t\t\t\t\t\tif (typeof stone === 'string') { // String is label mark\n\t\t\t\t\t\t\tprops.LB.push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j,\n\t\t\t\t\t\t\t\tlabel: stone\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else { // Numerical code for markup\n\t\t\t\t\t\t\t// Convert numerical code to property ID\n\t\t\t\t\t\t\tstone = (['CR', 'SQ', 'TR', 'MA', 'SL'])[stone - 1];\n\t\t\t\t\t\t\tprops[stone].push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += composePointLists(props);\n\n\t\t\tif (node.comment) { // Compose comment property\n\t\t\t\tstring += (string ? '\\n' : ''); // Add line break if other properties exist\n\t\t\t\tstring += 'C[' + escapeText(node.comment) + ']';\n\t\t\t}\n\n\t\t\treturn string;\n\t\t} // END function composeNodeProps\n\n\t\t// Composes properties from structure of point lists\n\t\t// Each member should be an array of points for property ID = key\n\t\t// Each point should specify point with (x, y) and may have optional label\n\t\tfunction composePointLists(lists) {\n\t\t\tvar string = '',\n\t\t\t\tid, points, i; // Scratch iteration variables\n\n\t\t\tfor (id in lists) { // Object own keys specifies property IDs\n\t\t\t\tif (lists.hasOwnProperty(id)) {\n\t\t\t\t\tpoints = lists[id]; // Corresponding members are point lists\n\t\t\t\t\tif (points.length > 0) { // Only add property if list non-empty\n\t\t\t\t\t\tstring += id;\n\t\t\t\t\t\tfor (i = 0; i < points.length; i++) {\n\t\t\t\t\t\t\tstring += '[' + coordsToLetters(points[i].x, points[i].y);\n\t\t\t\t\t\t\tif (points[i].label) { // Add optional composed label\n\t\t\t\t\t\t\t\tstring += ':' + escapeText(points[i].label);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstring += ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\n\t\t// Escapes backslash and close bracket for text output\n\t\tfunction escapeText(input) {\n\t\t\tinput = input.replace(/\\\\/g, '\\\\\\\\'); // Escape backslash\n\t\t\treturn input.replace(/\\]/g, '\\\\]'); // Escape close bracket\n\t\t}\n\n\t\t// Converts numerical coordinates to letters\n\t\tfunction coordsToLetters(x, y) {\n\t\t\tif (x === 0 || y === 0) {\n\t\t\t\treturn '';\n\t\t\t} else {\n\t\t\t\treturn numToChar(x) + numToChar(y);\n\t\t\t}\n\t\t}\n\n\t\tfunction numToChar(num) { // Helper for coordsToLetters\n\t\t\tif (num > 26) { // Numbers 27-52 to A-Z\n\t\t\t\treturn String.fromCharCode('A'.charCodeAt(0) + num - 27);\n\t\t\t} else { // Numbers 1-26 to a-z\n\t\t\t\treturn String.fromCharCode('a'.charCodeAt(0) + num - 1);\n\t\t\t}\n\t\t}\n\t};\n\t(function() {\n\t\t'use strict';\n\n\t\t// Color palette\n\t\tbesogo.RED = '#be0119'; // Darker red (marked variant)\n\t\tbesogo.LRED = '#ff474c'; // Lighter red (auto-marked variant)\n\t\tbesogo.BLUE = '#0165fc'; // Bright blue (last move)\n\t\tbesogo.PURP = '#9a0eea'; // Red + blue (variant + last move)\n\t\tbesogo.GREY = '#929591'; // Between white and black\n\t\tbesogo.GOLD = '#dbb40c'; // Tool selection\n\t\tbesogo.TURQ = '#06c2ac'; // Turqoise (nav selection)\n\n\t\tbesogo.BLACK_STONES = 4; // Number of black stone images\n\t\tbesogo.WHITE_STONES = 11; // Number of white stone images\n\n\t\t// Makes an SVG element with given name and attributes\n\t\tbesogo.svgEl = function(name, attributes) {\n\t\t\tvar attr, // Scratch iteration variable\n\t\t\t\telement = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n\n\t\t\tfor (attr in (attributes || {})) { // Add attributes if supplied\n\t\t\t\tif (attributes.hasOwnProperty(attr)) {\n\t\t\t\t\telement.setAttribute(attr, attributes[attr]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn element;\n\t\t};\n\n\t\t// Makes an SVG group for containing the shadow layer\n\t\tbesogo.svgShadowGroup = function() {\n\t\t\tvar group = besogo.svgEl('g'),\n\t\t\t\tfilter = besogo.svgEl('filter', {\n\t\t\t\t\tid: 'blur'\n\t\t\t\t}),\n\t\t\t\tblur = besogo.svgEl('feGaussianBlur', {\n\t\t\t\t\tin: 'SourceGraphic',\n\t\t\t\t\tstdDeviation: '2'\n\t\t\t\t});\n\n\t\t\tfilter.appendChild(blur);\n\t\t\tgroup.appendChild(filter);\n\t\t\treturn group;\n\t\t};\n\n\t\t// Makes a stone shadow\n\t\tbesogo.svgShadow = function(x, y) {\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 43,\n\t\t\t\tstroke: 'none',\n\t\t\t\tfill: 'black',\n\t\t\t\topacity: 0.32,\n\t\t\t\tfilter: 'url(#blur)'\n\t\t\t});\n\t\t};\n\n\t\t// Makes a photo realistic stone element\n\t\tbesogo.realStone = function(x, y, color, index) {\n\t\t\tvar element;\n\n\t\t\tif (color < 0) {\n\t\t\t\tcolor = 'black' + (index % besogo.BLACK_STONES);\n\t\t\t} else {\n\t\t\t\tcolor = 'white' + (index % besogo.WHITE_STONES);\n\t\t\t}\n\t\t\tcolor = 'img/' + color + '.png';\n\n\t\t\telement = besogo.svgEl(\"image\", {\n\t\t\t\tx: (x - 44),\n\t\t\t\ty: (y - 44),\n\t\t\t\theight: 88,\n\t\t\t\twidth: 88\n\t\t\t});\n\t\t\telement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', color);\n\n\t\t\treturn element;\n\t\t};\n\n\t\t// Makes a stone element\n\t\tbesogo.svgStone = function(x, y, color) {\n\t\t\tvar className = \"besogo-svg-greyStone\"; // Grey stone by default\n\n\t\t\tif (color === -1) { // Black stone\n\t\t\t\tclassName = \"besogo-svg-blackStone\";\n\t\t\t} else if (color === 1) { // White stone\n\t\t\t\tclassName = \"besogo-svg-whiteStone\";\n\t\t\t}\n\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 42,\n\t\t\t\t'class': className\n\t\t\t});\n\t\t};\n\n\t\t// Makes a circle at (x, y)\n\t\tbesogo.svgCircle = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 27,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes a square at (x, y)\n\t\tbesogo.svgSquare = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: (x - 23),\n\t\t\t\ty: (y - 23),\n\t\t\t\twidth: 46,\n\t\t\t\theight: 46,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an equilateral triangle at (x, y)\n\t\tbesogo.svgTriangle = function(x, y, color) {\n\t\t\t// Approximates an equilateral triangle centered on (x, y)\n\t\t\tvar pointString = \"\" + x + \",\" + (y - 30) + \" \" +\n\t\t\t\t(x - 26) + \",\" + (y + 15) + \" \" +\n\t\t\t\t(x + 26) + \",\" + (y + 15);\n\n\t\t\treturn besogo.svgEl(\"polygon\", {\n\t\t\t\tpoints: pointString,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an \"X\" cross at (x, y)\n\t\tbesogo.svgCross = function(x, y, color) {\n\t\t\tvar path = \"m\" + (x - 24) + \",\" + (y - 24) + \"l48,48m0,-48l-48,48\";\n\n\t\t\treturn besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an \"+\" plus sign at (x, y)\n\t\tbesogo.svgPlus = function(x, y, color) {\n\t\t\tvar path = \"m\" + x + \",\" + (y - 28) + \"v56m-28,-28h56\";\n\n\t\t\treturn besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes a small filled square at (x, y)\n\t\tbesogo.svgBlock = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: x - 18,\n\t\t\t\ty: y - 18,\n\t\t\t\twidth: 36,\n\t\t\t\theight: 36,\n\t\t\t\tstroke: \"none\",\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: color\n\t\t\t});\n\t\t};\n\n\t\t// Makes a label at (x, y)\n\t\tbesogo.svgLabel = function(x, y, color, label) {\n\t\t\tvar element,\n\t\t\t\tsize;\n\n\t\t\t// Trims label to 3 characters\n\t\t\tif (label.length > 3) {\n\t\t\t\tlabel = label.slice(0, 2) + '';\n\t\t\t}\n\n\t\t\t// Set font size according to label length\n\t\t\tswitch (label.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsize = 72;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsize = 56;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsize = 36;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\telement = besogo.svgEl(\"text\", {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tdy: \".65ex\", // Seems to work for vertically centering these fonts\n\t\t\t\t\"font-size\": size,\n\t\t\t\t\"text-anchor\": \"middle\", // Horizontal centering\n\t\t\t\t\"font-family\": \"Helvetica, Arial, sans-serif\",\n\t\t\t\tfill: color\n\t\t\t});\n\t\t\telement.appendChild(document.createTextNode(label));\n\n\t\t\treturn element;\n\t\t};\n\n\t})(); // END closure\n\tbesogo.makeToolPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar element, // Scratch for building SVG images\n\t\t\tsvg, // Scratch for building SVG images\n\t\t\tlabelText, // Text area for next label input\n\t\t\tselectors = {}, // Holds selection rects\n\t\t\tpassButton = document.createElement('input'),\n\t\t\tcutButton = document.createElement('input');\n\n\t\tsvg = makeButtonSVG('auto', 'Auto-play/nav'); // Auto-play/nav tool button\n\t\tsvg.appendChild(makeYinYang(0, 0));\n\n\t\tsvg = makeButtonSVG('playB', 'Play black'); // Play black button\n\t\tsvg.appendChild(besogo.svgStone(0, 0, -1));\n\n\t\tsvg = makeButtonSVG('playW', 'Play white'); // Play white button\n\t\tsvg.appendChild(besogo.svgStone(0, 0, 1));\n\n\t\tsvg = makeButtonSVG('addB', 'Set black'); // Add black button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0, -1)); // Black stone\n\t\telement.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('addW', 'Set white'); // Add white button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0, 1)); // White stone\n\t\telement.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('addE', 'Set empty'); // Add empty button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0)); // Grey stone\n\t\telement.appendChild(besogo.svgCross(0, 0, besogo.RED)); // Red cross\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('circle', 'Circle'); // Circle markup button\n\t\tsvg.appendChild(besogo.svgCircle(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('square', 'Square'); // Square markup button\n\t\tsvg.appendChild(besogo.svgSquare(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('triangle', 'Triangle'); // Triangle markup button\n\t\tsvg.appendChild(besogo.svgTriangle(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('cross', 'Cross'); // Cross markup button\n\t\tsvg.appendChild(besogo.svgCross(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('block', 'Block'); // Block markup button\n\t\tsvg.appendChild(besogo.svgBlock(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('clrMark', 'Clear mark'); // Clear markup button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgTriangle(0, 0, besogo.GREY));\n\t\telement.appendChild(besogo.svgCross(0, 0, besogo.RED));\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('label', 'Label'); // Label markup button\n\t\tsvg.appendChild(besogo.svgLabel(0, 0, 'black', 'A1'));\n\n\t\tlabelText = document.createElement(\"input\"); // Label entry text field\n\t\tlabelText.type = \"text\";\n\t\tlabelText.title = 'Next label';\n\t\tlabelText.onblur = function() {\n\t\t\teditor.setLabel(labelText.value);\n\t\t};\n\t\tlabelText.addEventListener('keydown', function(evt) {\n\t\t\tevt = evt || window.event;\n\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t});\n\t\tcontainer.appendChild(labelText);\n\n\t\tpassButton.type = 'button';\n\t\tpassButton.value = 'Pass';\n\t\tpassButton.title = 'Pass move';\n\t\tpassButton.onclick = function() {\n\t\t\tvar tool = editor.getTool();\n\t\t\tif (tool !== 'navOnly' && tool !== 'auto' && tool !== 'playB' && tool !== 'playW') {\n\t\t\t\teditor.setTool('auto'); // Ensures that a move tool is selected\n\t\t\t}\n\t\t\teditor.click(0, 0, false); // Clicking off the board signals a pass\n\t\t};\n\t\tcontainer.appendChild(passButton);\n\n\t\tcutButton.type = 'button';\n\t\tcutButton.value = 'Cut';\n\t\tcutButton.title = 'Remove branch';\n\t\tcutButton.onclick = function() {\n\t\t\teditor.cutCurrent();\n\t\t};\n\t\tcontainer.appendChild(cutButton);\n\n\t\teditor.addListener(toolStateUpdate); // Set up listener for tool state updates\n\t\ttoolStateUpdate({\n\t\t\tlabel: editor.getLabel(),\n\t\t\ttool: editor.getTool()\n\t\t}); // Initialize\n\n\n\t\t// Creates a button holding an SVG image\n\t\tfunction makeButtonSVG(tool, tooltip) {\n\t\t\tvar button = document.createElement('button'),\n\t\t\t\tsvg = besogo.svgEl('svg', { // Icon container\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\theight: '100%',\n\t\t\t\t\tviewBox: '-55 -55 110 110'\n\t\t\t\t}), // Centered on (0, 0)\n\t\t\t\tselected = besogo.svgEl(\"rect\", { // Selection rectangle\n\t\t\t\t\tx: -50, // Center on (0, 0)\n\t\t\t\t\ty: -50,\n\t\t\t\t\twidth: 100,\n\t\t\t\t\theight: 100,\n\t\t\t\t\tfill: 'none',\n\t\t\t\t\t'stroke-width': 8,\n\t\t\t\t\tstroke: besogo.GOLD,\n\t\t\t\t\trx: 20, // Rounded rectangle\n\t\t\t\t\try: 20, // Thanks, Steve\n\t\t\t\t\tvisibility: 'hidden'\n\t\t\t\t});\n\n\t\t\tcontainer.appendChild(button);\n\t\t\tbutton.appendChild(svg);\n\t\t\tbutton.onclick = function() {\n\t\t\t\teditor.setTool(tool);\n\t\t\t};\n\t\t\tbutton.title = tooltip;\n\t\t\tselectors[tool] = selected;\n\t\t\tsvg.appendChild(selected);\n\t\t\treturn svg; // Returns reference to the icon container\n\t\t}\n\n\t\t// Callback for updating tool state and label\n\t\tfunction toolStateUpdate(msg) {\n\t\t\tvar tool;\n\t\t\tif (msg.label) {\n\t\t\t\tlabelText.value = msg.label;\n\t\t\t}\n\t\t\tif (msg.tool) {\n\t\t\t\tfor (tool in selectors) { // Update which tool is selected\n\t\t\t\t\tif (selectors.hasOwnProperty(tool)) {\n\t\t\t\t\t\tif (msg.tool === tool) {\n\t\t\t\t\t\t\tselectors[tool].setAttribute('visibility', 'visible');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselectors[tool].setAttribute('visibility', 'hidden');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draws a yin yang\n\t\tfunction makeYinYang(x, y) {\n\t\t\tvar element = besogo.svgEl('g');\n\n\t\t\t// Draw black half circle on right side\n\t\t\telement.appendChild(besogo.svgEl(\"path\", {\n\t\t\t\td: \"m\" + x + \",\" + (y - 44) + \" a44 44 0 0 1 0,88z\",\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"black\"\n\t\t\t}));\n\n\t\t\t// Draw white part of ying yang on left side\n\t\t\telement.appendChild(besogo.svgEl(\"path\", {\n\t\t\t\td: \"m\" + x + \",\" + (y + 44) + \"a44 44 0 0 1 0,-88a22 22 0 0 1 0,44z\",\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"white\"\n\t\t\t}));\n\n\t\t\t// Draw round part of black half of ying yang\n\t\t\telement.appendChild(besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y + 22,\n\t\t\t\tr: 22,\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"black\"\n\t\t\t}));\n\n\t\t\treturn element;\n\t\t}\n\t};\n\tbesogo.makeTreePanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar svg,\n\t\t\tpathGroup,\n\t\t\tbottomLayer,\n\t\t\tcurrentMarker,\n\t\t\tSCALE = 0.25; // Tree size scaling factor\n\n\t\trebuildNavTree();\n\t\teditor.addListener(treeUpdate);\n\n\n\t\t// Callback for handling tree changes\n\t\tfunction treeUpdate(msg) {\n\t\t\tif (msg.treeChange) { // Tree structure changed\n\t\t\t\trebuildNavTree(); // Rebuild entire tree\n\t\t\t} else if (msg.navChange) { // Only navigation changed\n\t\t\t\tupdateCurrentMarker(); // Update current location marker\n\t\t\t} else if (msg.stoneChange) { // Only stones in current changed\n\t\t\t\tupdateCurrentNodeIcon();\n\t\t\t}\n\t\t}\n\n\t\t// Updates the current marker in the tree\n\t\tfunction updateCurrentMarker() {\n\t\t\tvar current = editor.getCurrent();\n\n\t\t\tsetSelectionMarker(currentMarker);\n\t\t\tsetCurrentMarker(current.navTreeMarker);\n\t\t}\n\n\t\t// Sets marker element to indicate the current node\n\t\tfunction setCurrentMarker(marker) {\n\t\t\tvar width = container.clientWidth,\n\t\t\t\theight = container.clientHeight,\n\t\t\t\ttop = container.scrollTop,\n\t\t\t\tleft = container.scrollLeft,\n\t\t\t\tmarkX = (marker.getAttribute('x') - 5) * SCALE, // Computed position of marker\n\t\t\t\tmarkY = (marker.getAttribute('y') - 5) * SCALE,\n\t\t\t\tGRIDSIZE = 120 * SCALE; // Size of the square grid\n\n\t\t\tif (markX < left) { // Ensure horizontal visibility of current marker\n\t\t\t\tcontainer.scrollLeft = markX;\n\t\t\t} else if (markX + GRIDSIZE > left + width) {\n\t\t\t\tcontainer.scrollLeft = markX + GRIDSIZE - width;\n\t\t\t}\n\t\t\tif (markY < top) { // Ensure vertical visibility of current marker\n\t\t\t\tcontainer.scrollTop = markY;\n\t\t\t} else if (markY + GRIDSIZE > top + height) {\n\t\t\t\tcontainer.scrollTop = markY + GRIDSIZE - height;\n\t\t\t}\n\n\t\t\tmarker.setAttribute('opacity', 1); // Always visible\n\t\t\tmarker.onmouseover = null; // Clear hover over action\n\t\t\tmarker.onmouseout = null; // Clear hover off action\n\t\t\tbottomLayer.appendChild(marker); // Moves marker to the background\n\t\t\tcurrentMarker = marker;\n\t\t}\n\n\t\t// Sets marker\n\t\tfunction setSelectionMarker(marker) {\n\t\t\tmarker.setAttribute('opacity', 0); // Normally invisible\n\t\t\tmarker.onmouseover = function() { // Show on hover over\n\t\t\t\tmarker.setAttribute('opacity', 0.5);\n\t\t\t};\n\t\t\tmarker.onmouseout = function() { // Hide on hover off\n\t\t\t\tmarker.setAttribute('opacity', 0);\n\t\t\t};\n\t\t\tsvg.appendChild(marker); // Move marker to foreground\n\t\t}\n\n\t\t// Rebuilds the entire navigation tree\n\t\tfunction rebuildNavTree() {\n\t\t\tvar current = editor.getCurrent(), // Current location in game state tree\n\t\t\t\troot = editor.getRoot(), // Root node of game state\n\t\t\t\tnextOpen = [], // Tracks occupied grid positions\n\t\t\t\toldSvg = svg, // Store the old SVG root\n\t\t\t\tbackground = besogo.svgEl(\"rect\", { // Background color for tree\n\t\t\t\t\theight: '100%',\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t\t}),\n\t\t\t\tpath, // Root path\n\t\t\t\twidth, // Calculated dimensions of the SVG\n\t\t\t\theight;\n\n\t\t\tsvg = besogo.svgEl(\"svg\");\n\t\t\tbottomLayer = besogo.svgEl(\"g\"); // Holder for the current marker\n\t\t\tpathGroup = besogo.svgEl(\"g\"); // Holder for path elements\n\n\t\t\tsvg.appendChild(background); // Background color first\n\t\t\tsvg.appendChild(bottomLayer); // Bottom layer (for current marker) second\n\t\t\tsvg.appendChild(pathGroup); // Navigation path third\n\n\t\t\tpath = recursiveTreeBuild(root, 0, 0, nextOpen); // Build the tree\n\t\t\tpathGroup.appendChild(finishPath(path, 'black')); // Finish and add root path\n\n\t\t\twidth = 120 * nextOpen.length; // Compute height and width of nav tree\n\t\t\theight = 120 * Math.max.apply(Math, nextOpen);\n\t\t\tsvg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);\n\t\t\tsvg.setAttribute('height', height * SCALE); // Scale down the actual SVG size\n\t\t\tsvg.setAttribute('width', width * SCALE);\n\n\t\t\tif (oldSvg) { // Replace SVG in container\n\t\t\t\tcontainer.replaceChild(svg, oldSvg);\n\t\t\t} else { // SVG not yet added to container\n\t\t\t\tcontainer.appendChild(svg);\n\t\t\t}\n\n\t\t\tsetCurrentMarker(current.navTreeMarker); // Set current marker and ensure visible\n\t\t} // END function rebuildNavTree\n\n\t\t// Recursively builds the tree\n\t\tfunction recursiveTreeBuild(node, x, y, nextOpen) {\n\t\t\tvar children = node.children,\n\t\t\t\tposition,\n\t\t\t\tpath,\n\t\t\t\tchildPath,\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (children.length === 0) { // Reached end of branch\n\t\t\t\tpath = 'm' + svgPos(x) + ',' + svgPos(y); // Start path at end of branch\n\t\t\t} else { // Current node has children\n\t\t\t\tposition = (nextOpen[x + 1] || 0); // First open spot in next column\n\t\t\t\tposition = (position < y) ? y : position; // Bring level with current y\n\n\t\t\t\tif (y < position - 1) { // Check if first child natural drop > 1\n\t\t\t\t\ty = position - 1; // Bring current y within 1 of first child drop\n\t\t\t\t}\n\t\t\t\t// Place first child and extend path\n\t\t\t\tpath = recursiveTreeBuild(children[0], x + 1, position, nextOpen) +\n\t\t\t\t\textendPath(x, y, nextOpen);\n\n\t\t\t\t// Place other children (intentionally starting at i = 1)\n\t\t\t\tfor (i = 1; i < children.length; i++) {\n\t\t\t\t\tposition = nextOpen[x + 1];\n\t\t\t\t\tchildPath = recursiveTreeBuild(children[i], x + 1, position, nextOpen) +\n\t\t\t\t\t\textendPath(x, y, nextOpen, position - 1);\n\t\t\t\t\t// End path at beginning of branch\n\t\t\t\t\tpathGroup.appendChild(finishPath(childPath, 'black'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvg.appendChild(makeNodeIcon(node, x, y));\n\t\t\taddSelectionMarker(node, x, y);\n\n\t\t\tnextOpen[x] = y + 1; // Claims (x, y)\n\t\t\treturn path;\n\t\t} // END function recursiveTreeBuild\n\n\t\tfunction makeNodeIcon(node, x, y) { // Makes a node icon for the tree\n\t\t\tvar element,\n\t\t\t\tcolor;\n\n\t\t\tswitch (node.getType()) {\n\t\t\t\tcase 'move': // Move node\n\t\t\t\t\tcolor = node.move.color;\n\t\t\t\t\telement = besogo.svgEl(\"g\");\n\t\t\t\t\telement.appendChild(besogo.svgStone(svgPos(x), svgPos(y), color));\n\t\t\t\t\tcolor = (color === -1) ? \"white\" : \"black\";\n\t\t\t\t\telement.appendChild(besogo.svgLabel(svgPos(x), svgPos(y), color,\n\t\t\t\t\t\t'' + node.moveNumber));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'setup': // Setup node\n\t\t\t\t\telement = besogo.svgEl(\"g\");\n\t\t\t\t\telement.appendChild(besogo.svgStone(svgPos(x), svgPos(y))); // Grey stone\n\t\t\t\t\telement.appendChild(besogo.svgPlus(svgPos(x), svgPos(y), besogo.RED));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: // Empty node\n\t\t\t\t\telement = besogo.svgStone(svgPos(x), svgPos(y)); // Grey stone\n\t\t\t}\n\t\t\tnode.navTreeIcon = element; // Save icon reference in game state tree\n\t\t\tnode.navTreeX = x; // Save position of the icon\n\t\t\tnode.navTreeY = y;\n\n\t\t\treturn element;\n\t\t} // END function makeNodeIcon\n\n\t\tfunction updateCurrentNodeIcon() { // Updates the current node icon\n\t\t\tvar current = editor.getCurrent(), // Current location in game state tree\n\t\t\t\toldIcon = current.navTreeIcon,\n\t\t\t\tnewIcon = makeNodeIcon(current, current.navTreeX, current.navTreeY);\n\t\t\tsvg.replaceChild(newIcon, oldIcon);\n\t\t}\n\n\t\tfunction addSelectionMarker(node, x, y) {\n\t\t\tvar element = besogo.svgEl(\"rect\", { // Create selection marker\n\t\t\t\tx: svgPos(x) - 55,\n\t\t\t\ty: svgPos(y) - 55,\n\t\t\t\twidth: 110,\n\t\t\t\theight: 110,\n\t\t\t\tfill: besogo.TURQ\n\t\t\t});\n\t\t\telement.onclick = function() {\n\t\t\t\teditor.setCurrent(node);\n\t\t\t};\n\n\t\t\tnode.navTreeMarker = element; // Save selection marker in node\n\t\t\tsetSelectionMarker(element); // Add as and set selection marker properties\n\t\t}\n\n\t\tfunction extendPath(x, y, nextOpen, prevChildPos) { // Extends path from child to current\n\t\t\tvar childPos = nextOpen[x + 1] - 1; // Position of child\n\t\t\tif (childPos === y) { // Child is horizontally level with current\n\t\t\t\treturn 'h-120'; // Horizontal line back to current\n\t\t\t} else if (childPos === y + 1) { // Child is one drop from current\n\t\t\t\treturn 'l-120,-120'; // Diagonal drop line back to current\n\t\t\t} else if (prevChildPos && prevChildPos !== y) {\n\t\t\t\t// Previous is already dropped, extend back to previous child drop line\n\t\t\t\treturn 'l-60,-60v-' + (120 * (childPos - prevChildPos));\n\t\t\t} else { // Extend double-bend drop line back to parent\n\t\t\t\treturn 'l-60,-60v-' + (120 * (childPos - y - 1)) + 'l-60,-60';\n\t\t\t}\n\t\t}\n\n\t\tfunction finishPath(path, color) { // Finishes path element\n\t\t\tvar element = besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction svgPos(x) { // Converts (x, y) coordinates to SVG position\n\t\t\treturn (x * 120) + 60;\n\t\t}\n\t};\n\n\tbesogo.autoInit();\n\tif (Persistence.isAvailable()) {\n\terrorCheck = Persistence.getItem(\"errorCheck\");\n\tif (errorCheck == true) {\n\t\tdocument.getElementsByClassName(\"besogo-board\")[0].style.border = \"5px solid indianred\";\n\t} else {\n\t\tdocument.getElementsByClassName(\"besogo-board\")[0].style.border = \"5px solid limegreen\";\n\t}\n\tPersistence.clear();\n\t}\n</script>",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "<script>\n// v1.0.0 - https://github.com/SimonLammer/anki-persistence/blob/cd2ca88e019dc3b8f32dad623932c1eabdba7e21/script.js\nif(void 0===window.Persistence){var _persistenceKey=\"github.com/SimonLammer/anki-persistence/\",_defaultKey=\"_default\";if(window.Persistence_sessionStorage=function(){var e=!1;try{\"object\"==typeof window.sessionStorage&&(e=!0,this.clear=function(){for(var e=0;e<sessionStorage.length;e++){var t=sessionStorage.key(e);0==t.indexOf(_persistenceKey)&&(sessionStorage.removeItem(t),e--)}},this.setItem=function(e,t){null==t&&(t=e,e=_defaultKey),sessionStorage.setItem(_persistenceKey+e,JSON.stringify(t))},this.getItem=function(e){return null==e&&(e=_defaultKey),JSON.parse(sessionStorage.getItem(_persistenceKey+e))},this.removeItem=function(e){null==e&&(e=_defaultKey),sessionStorage.removeItem(_persistenceKey+e)})}catch(e){}this.isAvailable=function(){return e}},window.Persistence_windowKey=function(e){var t=window[e],n=!1;\"object\"==typeof t&&(n=!0,this.clear=function(){t[_persistenceKey]={}},this.setItem=function(e,n){null==n&&(n=e,e=_defaultKey),t[_persistenceKey][e]=n},this.getItem=function(e){return null==e&&(e=_defaultKey),null==t[_persistenceKey][e]?null:t[_persistenceKey][e]},this.removeItem=function(e){null==e&&(e=_defaultKey),delete t[_persistenceKey][e]},null==t[_persistenceKey]&&this.clear()),this.isAvailable=function(){return n}},window.Persistence=new Persistence_sessionStorage,Persistence.isAvailable()||(window.Persistence=new Persistence_windowKey(\"py\")),!Persistence.isAvailable()){var titleStartIndex=window.location.toString().indexOf(\"title\"),titleContentIndex=window.location.toString().indexOf(\"main\",titleStartIndex);titleStartIndex>0&&titleContentIndex>0&&titleContentIndex-titleStartIndex<10&&(window.Persistence=new Persistence_windowKey(\"qt\"))}}\n</script>\n\n<div id=frontGo class=\"besogo-diagram\" nokeys=1 nowheel=1 maxwidth=700 realstones=1 transwidth=0>{{text:SGF}}</div>\n\n<script>\n\tvar errorCheck;\n\tvar goScrollVariationHandler = function(event) {\n\t\tif (!document.body.contains(document.getElementById('frontGo'))) {} else if (event.originalEvent.wheelDelta >= 0) {\n\t\t\tdocument.querySelector('[title=\"Previous sibling\"]').click();\n\t\t} else {\n\t\t\tdocument.querySelector('[title=\"Next sibling\"]').click();\n\t\t}\n\t}\n\t$(\".besogo-diagram\").bind('mousewheel', goScrollVariationHandler);\n\n\n\n\n\tif (!document.body.contains(document.getElementById('frontGo'))) {} else {\n\t\tvar nextMoveHandler = function(e) {\n\t\t\tif (!document.body.contains(document.getElementById('frontGo'))) {} else {\n\t\t\t\te.preventDefault();\n\t\t\t\tdocument.querySelector('[title=\"Next node\"]').click();\n\t\t\t}\n\t\t}\n\t\t$(\"#frontGo\").bind('contextmenu', nextMoveHandler);\n\t}\n\n\tvar playerColor = \"white\";\n\n\tif (`{{text:SGF}}`.indexOf(';W[') < `{{text:SGF}}`.indexOf(';B[') && `{{text:SGF}}`.indexOf(';W[') !== -1) {\n\t\tplayerColor = \"black\";\n\t}\n\tdocument.getElementById(\"frontGo\").style.background = playerColor;\n\t(function() {\n\t\t'use strict';\n\t\tvar besogo = window.besogo = window.besogo || {}; // Establish our namespace\n\t\tbesogo.VERSION = '0.0.2-alpha';\n\n\t\tbesogo.create = function(container, options) {\n\t\t\tvar editor, // Core editor object\n\t\t\t\tresizer, // Auto-resizing function\n\t\t\t\tboardDiv, // Board display container\n\t\t\t\tpanelsDiv, // Parent container of panel divs\n\t\t\t\tmakers = { // Map to panel creators\n\t\t\t\t\tcontrol: besogo.makeControlPanel,\n\t\t\t\t\tnames: besogo.makeNamesPanel,\n\t\t\t\t\tcomment: besogo.makeCommentPanel,\n\t\t\t\t\ttool: besogo.makeToolPanel,\n\t\t\t\t\ttree: besogo.makeTreePanel,\n\t\t\t\t\tfile: besogo.makeFilePanel\n\t\t\t\t},\n\t\t\t\tinsideText = container.textContent || container.innerText || '',\n\t\t\t\ti, panelName; // Scratch iteration variables\n\n\t\t\tcontainer.className += ' besogo-container'; // Marks this div as initialized\n\n\t\t\t// Process options and set defaults\n\t\t\toptions = options || {}; // Makes option checking simpler\n\t\t\toptions.size = besogo.parseSize(options.size || 19);\n\t\t\toptions.coord = options.coord || 'none';\n\t\t\toptions.tool = options.tool || 'auto';\n\t\t\tif (options.panels === '') {\n\t\t\t\toptions.panels = [];\n\t\t\t}\n\t\t\toptions.panels = options.panels || 'control+names+comment+tool+tree+file';\n\t\t\tif (typeof options.panels === 'string') {\n\t\t\t\toptions.panels = options.panels.split('+');\n\t\t\t}\n\t\t\toptions.path = options.path || '';\n\t\t\tif (options.shadows === undefined) {\n\t\t\t\toptions.shadows = 'auto';\n\t\t\t} else if (options.shadows === 'off') {\n\t\t\t\toptions.shadows = false;\n\t\t\t}\n\n\t\t\t// Make the core editor object\n\t\t\teditor = besogo.makeEditor(options.size.x, options.size.y);\n\t\t\teditor.setTool(options.tool);\n\t\t\teditor.setCoordStyle(options.coord);\n\t\t\tif (options.realstones) { // Using realistic stones\n\t\t\t\teditor.REAL_STONES = true;\n\t\t\t\teditor.SHADOWS = options.shadows;\n\t\t\t} else { // SVG stones\n\t\t\t\teditor.SHADOWS = (options.shadows && options.shadows !== 'auto');\n\t\t\t}\n\n\t\t\tif (!options.nokeys) { // Add keypress handler unless nokeys option is truthy\n\t\t\t\taddKeypressHandler(container, editor);\n\t\t\t}\n\n\t\t\tif (options.sgf) { // Load SGF file from URL\n\t\t\t\ttry {\n\t\t\t\t\tfetchParseLoad(options.sgf, editor, options.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Silently fail on network error\n\t\t\t\t}\n\t\t\t} else if (insideText.match(/\\s*\\(\\s*;/)) { // Text content looks like an SGF file\n\t\t\t\tparseAndLoad(insideText, editor);\n\t\t\t\tnavigatePath(editor, options.path); // Navigate editor along path\n\t\t\t}\n\n\t\t\tif (typeof options.variants === 'number' || typeof options.variants === 'string') {\n\t\t\t\teditor.setVariantStyle(+options.variants); // Converts to number\n\t\t\t}\n\n\t\t\twhile (container.firstChild) { // Remove all children of container\n\t\t\t\tcontainer.removeChild(container.firstChild);\n\t\t\t}\n\n\t\t\tboardDiv = makeDiv('besogo-board'); // Create div for board display\n\t\t\tbesogo.makeBoardDisplay(boardDiv, editor); // Create board display\n\n\t\t\tif (!options.nowheel) { // Add mousewheel handler unless nowheel option is truthy\n\t\t\t\taddWheelHandler(boardDiv, editor);\n\t\t\t}\n\n\t\t\tif (options.panels.length > 0) { // Only create if there are panels to add\n\t\t\t\tpanelsDiv = makeDiv('besogo-panels');\n\t\t\t\tfor (i = 0; i < options.panels.length; i++) {\n\t\t\t\t\tpanelName = options.panels[i];\n\t\t\t\t\tif (makers[panelName]) { // Only add if creator function exists\n\t\t\t\t\t\tmakers[panelName](makeDiv('besogo-' + panelName, panelsDiv), editor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!panelsDiv.firstChild) { // If no panels were added\n\t\t\t\t\tcontainer.removeChild(panelsDiv); // Remove the panels div\n\t\t\t\t\tpanelsDiv = false; // Flags panels div as removed\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.resize = options.resize || 'auto';\n\t\t\tif (options.resize === 'auto') { // Add auto-resizing unless resize option is truthy\n\t\t\t\tresizer = function() {\n\t\t\t\t\tvar windowHeight = window.innerHeight, // Viewport height\n\t\t\t\t\t\t// Calculated width of parent element\n\t\t\t\t\t\tparentWidth = parseFloat(getComputedStyle(container).width),\n\t\t\t\t\t\tmaxWidth = +(options.maxwidth || -1),\n\t\t\t\t\t\torientation = options.orient || 'auto',\n\n\t\t\t\t\t\tportraitRatio = +(options.portratio || 200) / 100,\n\t\t\t\t\t\tlandscapeRatio = +(options.landratio || 200) / 100,\n\t\t\t\t\t\tminPanelsWidth = +(options.minpanelswidth || 350),\n\t\t\t\t\t\tminPanelsHeight = +(options.minpanelsheight || 400),\n\t\t\t\t\t\tminLandscapeWidth = +(options.transwidth || 600),\n\n\t\t\t\t\t\t// Initial width parent\n\t\t\t\t\t\twidth = (maxWidth > 0 && maxWidth < parentWidth) ? maxWidth : parentWidth,\n\t\t\t\t\t\theight; // Initial height is undefined\n\n\t\t\t\t\t// Determine orientation if 'auto' or 'view'\n\t\t\t\t\tif (orientation !== 'portrait' && orientation !== 'landscape') {\n\t\t\t\t\t\tif (width < minLandscapeWidth || (orientation === 'view' && width < windowHeight)) {\n\t\t\t\t\t\t\torientation = 'portrait';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\torientation = 'landscape';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (orientation === 'portrait') { // Portrait mode\n\t\t\t\t\t\tif (!isNaN(portraitRatio)) {\n\t\t\t\t\t\t\theight = portraitRatio * width;\n\t\t\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\t\t\theight = (height - width < minPanelsHeight) ? width + minPanelsHeight : height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // Otherwise, leave height undefined\n\t\t\t\t\t} else if (orientation === 'landscape') { // Landscape mode\n\t\t\t\t\t\tif (!panelsDiv) { // No panels div\n\t\t\t\t\t\t\theight = width; // Square overall\n\t\t\t\t\t\t} else if (isNaN(landscapeRatio)) {\n\t\t\t\t\t\t\theight = windowHeight;\n\t\t\t\t\t\t} else { // Otherwise use ratio\n\t\t\t\t\t\t\theight = width / landscapeRatio;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\t\t// Reduce height to ensure minimum width of panels div\n\t\t\t\t\t\t\theight = width;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsetDimensions(width, height);\n\t\t\t\t\tcontainer.style.width = width + 'px';\n\t\t\t\t};\n\t\t\t\twindow.addEventListener(\"resize\", resizer);\n\t\t\t\tresizer(); // Initial div sizing\n\t\t\t} else if (options.resize === 'fixed') {\n\t\t\t\tsetDimensions(container.clientWidth, container.clientHeight);\n\t\t\t}\n\n\t\t\t// Sets dimensions with optional height param\n\t\t\tfunction setDimensions(width, height) {\n\t\t\t\tif (height && width > height) { // Landscape mode\n\t\t\t\t\tcontainer.style['flex-direction'] = 'row';\n\t\t\t\t\tboardDiv.style.height = height + 'px';\n\t\t\t\t\tboardDiv.style.width = height + 'px';\n\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\tpanelsDiv.style.height = height + 'px';\n\t\t\t\t\t\tpanelsDiv.style.width = (width - height) + 'px';\n\t\t\t\t\t}\n\t\t\t\t} else { // Portrait mode (implied if height is missing)\n\t\t\t\t\tcontainer.style['flex-direction'] = 'column';\n\t\t\t\t\tboardDiv.style.height = width + 'px';\n\t\t\t\t\tboardDiv.style.width = width + 'px';\n\t\t\t\t\tif (panelsDiv) {\n\t\t\t\t\t\tif (height) { // Only set height if param present\n\t\t\t\t\t\t\tpanelsDiv.style.height = (height - width) + 'px';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpanelsDiv.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Creates and adds divs to specified parent or container\n\t\t\tfunction makeDiv(className, parent) {\n\t\t\t\tvar div = document.createElement(\"div\");\n\t\t\t\tif (className) {\n\t\t\t\t\tdiv.className = className;\n\t\t\t\t}\n\t\t\t\tparent = parent || container;\n\t\t\t\tparent.appendChild(div);\n\t\t\t\treturn div;\n\t\t\t}\n\t\t}; // END function besogo.create\n\n\t\t// Parses size parameter from SGF format\n\t\tbesogo.parseSize = function(input) {\n\t\t\tvar matches,\n\t\t\t\tsizeX,\n\t\t\t\tsizeY;\n\n\t\t\tinput = (input + '').replace(/\\s/g, ''); // Convert to string and remove whitespace\n\n\t\t\tmatches = input.match(/^(\\d+):(\\d+)$/); // Check for #:# pattern\n\t\t\tif (matches) { // Composed value pattern found\n\t\t\t\tsizeX = +matches[1]; // Convert to numbers\n\t\t\t\tsizeY = +matches[2];\n\t\t\t} else if (input.match(/^\\d+$/)) { // Check for # pattern\n\t\t\t\tsizeX = +input; // Convert to numbers\n\t\t\t\tsizeY = +input; // Implied square\n\t\t\t} else { // Invalid input format\n\t\t\t\tsizeX = sizeY = 19; // Default size value\n\t\t\t}\n\t\t\tif (sizeX > 52 || sizeX < 1 || sizeY > 52 || sizeY < 1) {\n\t\t\t\tsizeX = sizeY = 19; // Out of range, set to default\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: sizeX,\n\t\t\t\ty: sizeY\n\t\t\t};\n\t\t};\n\n\t\t// Automatically converts document elements into besogo instances\n\t\tbesogo.autoInit = function() {\n\t\t\tvar allDivs = document.getElementsByTagName('div'), // Live collection of divs\n\t\t\t\ttargetDivs = [], // List of divs to auto-initialize\n\t\t\t\toptions, // Structure to hold options\n\t\t\t\ti, j, attrs; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < allDivs.length; i++) { // Iterate over all divs\n\t\t\t\tif ((hasClass(allDivs[i], 'besogo-editor') || // Has an auto-init class\n\t\t\t\t\t\thasClass(allDivs[i], 'besogo-viewer') ||\n\t\t\t\t\t\thasClass(allDivs[i], 'besogo-diagram')) &&\n\t\t\t\t\t!hasClass(allDivs[i], 'besogo-container')) { // Not already initialized\n\t\t\t\t\ttargetDivs.push(allDivs[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targetDivs.length; i++) { // Iterate over target divs\n\t\t\t\toptions = {}; // Clear the options struct\n\t\t\t\tif (hasClass(targetDivs[i], 'besogo-editor')) {\n\t\t\t\t\toptions.panels = ['control', 'names', 'comment', 'tool', 'tree', 'file'];\n\t\t\t\t\toptions.tool = 'auto';\n\t\t\t\t} else if (hasClass(targetDivs[i], 'besogo-viewer')) {\n\t\t\t\t\toptions.panels = ['control', 'names', 'comment'];\n\t\t\t\t\toptions.tool = 'navOnly';\n\t\t\t\t} else if (hasClass(targetDivs[i], 'besogo-diagram')) {\n\t\t\t\t\toptions.panels = ['control'];\n\t\t\t\t\toptions.tool = 'navOnly';\n\t\t\t\t}\n\n\t\t\t\tattrs = targetDivs[i].attributes;\n\t\t\t\tfor (j = 0; j < attrs.length; j++) { // Load attributes as options\n\t\t\t\t\toptions[attrs[j].name] = attrs[j].value;\n\t\t\t\t}\n\t\t\t\tbesogo.create(targetDivs[i], options);\n\t\t\t}\n\n\t\t\tfunction hasClass(element, str) {\n\t\t\t\treturn (element.className.split(' ').indexOf(str) !== -1);\n\t\t\t}\n\t\t};\n\n\t\t// Sets up keypress handling\n\t\tfunction addKeypressHandler(container, editor) {\n\t\t\tif (!container.getAttribute('tabindex')) {\n\t\t\t\tcontainer.setAttribute('tabindex', '0'); // Set tabindex to allow div focusing\n\t\t\t}\n\n\t\t\tcontainer.addEventListener('keydown', function(evt) {\n\t\t\t\tevt = evt || window.event;\n\t\t\t\tswitch (evt.keyCode) {\n\t\t\t\t\tcase 33: // page up\n\t\t\t\t\t\teditor.prevNode(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 34: // page down\n\t\t\t\t\t\teditor.nextNode(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 35: // end\n\t\t\t\t\t\teditor.nextNode(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 36: // home\n\t\t\t\t\t\teditor.prevNode(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 37: // left\n\t\t\t\t\t\teditor.prevNode(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 38: // up\n\t\t\t\t\t\teditor.nextSibling(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 39: // right\n\t\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 40: // down\n\t\t\t\t\t\teditor.nextSibling(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 46: // delete\n\t\t\t\t\t\teditor.cutCurrent();\n\t\t\t\t\t\tbreak;\n\t\t\t\t} // END switch (evt.keyCode)\n\t\t\t\tif (evt.keyCode >= 33 && evt.keyCode <= 40) {\n\t\t\t\t\tevt.preventDefault(); // Suppress page nav controls\n\t\t\t\t}\n\t\t\t}); // END func() and addEventListener\n\t\t} // END function addKeypressHandler\n\n\t\t// Sets up mousewheel handling\n\t\tfunction addWheelHandler(boardDiv, editor) {\n\t\t\tboardDiv.addEventListener('wheel', function(evt) {\n\t\t\t\tevt = evt || window.event;\n\t\t\t\tif (evt.deltaY > 0) {\n\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t} else if (evt.deltaY < 0) {\n\t\t\t\t\teditor.prevNode(1);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Parses SGF string and loads into editor\n\t\tfunction parseAndLoad(text, editor) {\n\t\t\tvar sgf;\n\t\t\ttry {\n\t\t\t\tsgf = besogo.parseSgf(text);\n\t\t\t} catch (error) {\n\t\t\t\treturn; // Silently fail on parse error\n\t\t\t}\n\t\t\tbesogo.loadSgf(sgf, editor);\n\t\t}\n\n\t\t// Fetches text file at url from same domain\n\t\tfunction fetchParseLoad(url, editor, path) {\n\t\t\tvar http = new XMLHttpRequest();\n\n\t\t\thttp.onreadystatechange = function() {\n\t\t\t\tif (http.readyState === 4 && http.status === 200) { // Successful fetch\n\t\t\t\t\tparseAndLoad(http.responseText, editor);\n\t\t\t\t\tnavigatePath(editor, path);\n\t\t\t\t}\n\t\t\t};\n\t\t\thttp.overrideMimeType('text/plain'); // Prevents XML parsing and warnings\n\t\t\thttp.open(\"GET\", url, true); // Asynchronous load\n\t\t\thttp.send();\n\t\t}\n\n\t\tfunction navigatePath(editor, path) {\n\t\t\tvar subPaths,\n\t\t\t\ti, j; // Scratch iteration variables\n\n\t\t\tpath = path.split(/[Nn]+/); // Split into parts that start in next mode\n\t\t\tfor (i = 0; i < path.length; i++) {\n\t\t\t\tsubPaths = path[i].split(/[Bb]+/); // Split on switches into branch mode\n\t\t\t\texecuteMoves(subPaths[0], false); // Next mode moves\n\t\t\t\tfor (j = 1; j < subPaths.length; j++) { // Intentionally starting at 1\n\t\t\t\t\texecuteMoves(subPaths[j], true); // Branch mode moves\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction executeMoves(part, branch) {\n\t\t\t\tvar i;\n\t\t\t\tpart = part.split(/\\D+/); // Split on non-digits\n\t\t\t\tfor (i = 0; i < part.length; i++) {\n\t\t\t\t\tif (part[i]) { // Skip empty strings\n\t\t\t\t\t\tif (branch) { // Branch mode\n\t\t\t\t\t\t\tif (editor.getCurrent().children.length) {\n\t\t\t\t\t\t\t\teditor.nextNode(1);\n\t\t\t\t\t\t\t\teditor.nextSibling(part[i] - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // Next mode\n\t\t\t\t\t\t\teditor.nextNode(+part[i]); // Converts to number\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t})(); // END closure\n\tbesogo.makeBoardDisplay = function(container, editor) {\n\t\t'use strict';\n\t\tvar CELL_SIZE = 88, // Including line width\n\t\t\tCOORD_MARGIN = 75, // Margin for coordinate labels\n\t\t\tEXTRA_MARGIN = 6, // Extra margin on the edge of board\n\t\t\tBOARD_MARGIN, // Total board margin\n\n\t\t\t// Board size parameters\n\t\t\tsizeX = editor.getCurrent().getSize().x,\n\t\t\tsizeY = editor.getCurrent().getSize().y,\n\n\t\t\tsvg, // Holds the overall board display SVG element\n\t\t\tstoneGroup, // Group for stones\n\t\t\tmarkupGroup, // Group for markup\n\t\t\thoverGroup, // Group for hover layer\n\t\t\tmarkupLayer, // Array of markup layer elements\n\t\t\thoverLayer, // Array of hover layer elements\n\n\t\t\trandIndex, // Random index for stone images\n\n\t\t\tTOUCH_FLAG = false; // Flag for touch interfaces\n\n\t\tinitializeBoard(editor.getCoordStyle()); // Initialize SVG element and draw the board\n\t\tcontainer.appendChild(svg); // Add the SVG element to the document\n\t\teditor.addListener(update); // Register listener to handle editor/game state updates\n\t\tredrawAll(editor.getCurrent()); // Draw stones, markup and hover layer\n\n\t\t// Set listener to detect touch interfaces\n\t\tcontainer.addEventListener('touchstart', setTouchFlag);\n\n\t\t// Function for setting the flag for touch interfaces\n\t\tfunction setTouchFlag() {\n\t\t\tTOUCH_FLAG = true; // Set flag to prevent needless function calls\n\t\t\thoverLayer = []; // Drop hover layer references, kills events\n\t\t\tsvg.removeChild(hoverGroup); // Remove hover group from SVG\n\t\t\t// Remove self when done\n\t\t\tcontainer.removeEventListener('touchstart', setTouchFlag);\n\t\t}\n\n\t\t// Initializes the SVG and draws the board\n\t\tfunction initializeBoard(coord) {\n\t\t\tdrawBoard(coord); // Initialize the SVG element and draw the board\n\n\t\t\tstoneGroup = besogo.svgEl(\"g\");\n\t\t\tmarkupGroup = besogo.svgEl(\"g\");\n\n\t\t\tsvg.appendChild(stoneGroup); // Add placeholder group for stone layer\n\t\t\tsvg.appendChild(markupGroup); // Add placeholder group for markup layer\n\n\t\t\tif (!TOUCH_FLAG) {\n\t\t\t\thoverGroup = besogo.svgEl(\"g\");\n\t\t\t\tsvg.appendChild(hoverGroup);\n\t\t\t}\n\n\t\t\taddEventTargets(); // Add mouse event listener layer\n\n\t\t\tif (editor.REAL_STONES) { // Generate index for realistic stone images\n\t\t\t\trandomizeIndex();\n\t\t\t}\n\t\t}\n\n\t\t// Callback for board display redraws\n\t\tfunction update(msg) {\n\t\t\tvar current = editor.getCurrent(),\n\t\t\t\tcurrentSize = current.getSize(),\n\t\t\t\treinit = false, // Board redraw flag\n\t\t\t\toldSvg = svg;\n\n\t\t\t// Check if board size has changed\n\t\t\tif (currentSize.x !== sizeX || currentSize.y !== sizeY || msg.coord) {\n\t\t\t\tsizeX = currentSize.x;\n\t\t\t\tsizeY = currentSize.y;\n\t\t\t\tinitializeBoard(msg.coord || editor.getCoordStyle()); // Reinitialize board\n\t\t\t\tcontainer.replaceChild(svg, oldSvg);\n\t\t\t\treinit = true; // Flag board redrawn\n\t\t\t}\n\n\t\t\t// Redraw stones only if needed\n\t\t\tif (reinit || msg.navChange || msg.stoneChange) {\n\t\t\t\tredrawStones(current);\n\t\t\t\tredrawMarkup(current);\n\t\t\t\tredrawHover(current);\n\t\t\t} else if (msg.markupChange) {\n\t\t\t\tredrawMarkup(current);\n\t\t\t\tredrawHover(current);\n\t\t\t} else if (msg.tool || msg.label) {\n\t\t\t\tredrawHover(current);\n\t\t\t}\n\t\t}\n\n\t\tfunction redrawAll(current) {\n\t\t\tredrawStones(current);\n\t\t\tredrawMarkup(current);\n\t\t\tredrawHover(current);\n\t\t}\n\n\t\t// Initializes the SVG element and draws the board\n\t\tfunction drawBoard(coord) {\n\t\t\tvar boardWidth,\n\t\t\t\tboardHeight,\n\t\t\t\tstring = \"\", // Path string for inner board lines\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tBOARD_MARGIN = (coord === 'none' ? 0 : COORD_MARGIN) + EXTRA_MARGIN;\n\t\t\tboardWidth = 2 * BOARD_MARGIN + sizeX * CELL_SIZE;\n\t\t\tboardHeight = 2 * BOARD_MARGIN + sizeY * CELL_SIZE;\n\n\t\t\tsvg = besogo.svgEl(\"svg\", { // Initialize the SVG element\n\t\t\t\twidth: \"100%\",\n\t\t\t\theight: \"100%\",\n\t\t\t\tviewBox: \"0 0 \" + boardWidth + \" \" + boardHeight\n\t\t\t});\n\n\t\t\tsvg.appendChild(besogo.svgEl(\"rect\", { // Fill background color\n\t\t\t\twidth: boardWidth,\n\t\t\t\theight: boardHeight,\n\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t}));\n\n\t\t\tsvg.appendChild(besogo.svgEl(\"rect\", { // Draw outer square of board\n\t\t\t\twidth: CELL_SIZE * (sizeX - 1),\n\t\t\t\theight: CELL_SIZE * (sizeY - 1),\n\t\t\t\tx: svgPos(1),\n\t\t\t\ty: svgPos(1),\n\t\t\t\t'class': 'besogo-svg-lines'\n\t\t\t}));\n\n\t\t\tfor (i = 2; i <= (sizeY - 1); i++) { // Horizontal inner lines\n\t\t\t\tstring += \"M\" + svgPos(1) + \",\" + svgPos(i) + \"h\" + CELL_SIZE * (sizeX - 1);\n\t\t\t}\n\t\t\tfor (i = 2; i <= (sizeX - 1); i++) { // Vertical inner lines\n\t\t\t\tstring += \"M\" + svgPos(i) + \",\" + svgPos(1) + \"v\" + CELL_SIZE * (sizeY - 1);\n\t\t\t}\n\t\t\tsvg.appendChild(besogo.svgEl(\"path\", { // Draw inner lines of board\n\t\t\t\td: string,\n\t\t\t\t'class': 'besogo-svg-lines'\n\t\t\t}));\n\n\t\t\tdrawHoshi(); // Draw the hoshi points\n\t\t\tif (coord !== 'none') {\n\t\t\t\tdrawCoords(coord); // Draw the coordinate labels\n\t\t\t}\n\t\t}\n\n\t\t// Draws coordinate labels on the board\n\t\tfunction drawCoords(coord) {\n\t\t\tvar labels = besogo.coord[coord](sizeX, sizeY),\n\t\t\t\tshift = COORD_MARGIN + 10,\n\t\t\t\ti, x, y; // Scratch iteration variable\n\n\t\t\tfor (i = 1; i <= sizeX; i++) { // Draw column coordinate labels\n\t\t\t\tx = svgPos(i);\n\t\t\t\tdrawCoordLabel(x, svgPos(1) - shift, labels.x[i]);\n\t\t\t\tdrawCoordLabel(x, svgPos(sizeY) + shift, labels.x[i]);\n\t\t\t}\n\n\t\t\tfor (i = 1; i <= sizeY; i++) { // Draw row coordinate labels\n\t\t\t\ty = svgPos(i);\n\t\t\t\tdrawCoordLabel(svgPos(1) - shift, y, labels.y[i]);\n\t\t\t\tdrawCoordLabel(svgPos(sizeX) + shift, y, labels.y[i]);\n\t\t\t}\n\n\t\t\tfunction drawCoordLabel(x, y, label) {\n\t\t\t\tvar element = besogo.svgEl(\"text\", {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\tdy: \".65ex\", // Seems to work for vertically centering these fonts\n\t\t\t\t\t\"font-size\": 32,\n\t\t\t\t\t\"text-anchor\": \"middle\", // Horizontal centering\n\t\t\t\t\t\"font-family\": \"Helvetica, Arial, sans-serif\",\n\t\t\t\t\tfill: 'black'\n\t\t\t\t});\n\t\t\t\telement.appendChild(document.createTextNode(label));\n\t\t\t\tsvg.appendChild(element);\n\t\t\t}\n\t\t}\n\n\t\t// Draws hoshi onto the board at procedurally generated locations\n\t\tfunction drawHoshi() {\n\t\t\tvar cx, cy, // Center point calculation\n\t\t\t\tpathStr = \"\"; // Path string for drawing star points\n\n\t\t\tif (sizeX % 2 && sizeY % 2) { // Draw center hoshi if both dimensions are odd\n\t\t\t\tcx = (sizeX - 1) / 2 + 1; // Calculate the center of the board\n\t\t\t\tcy = (sizeY - 1) / 2 + 1;\n\t\t\t\tdrawStar(cx, cy);\n\n\t\t\t\tif (sizeX >= 17 && sizeY >= 17) { // Draw side hoshi if at least 17x17 and odd\n\t\t\t\t\tdrawStar(4, cy);\n\t\t\t\t\tdrawStar(sizeX - 3, cy);\n\t\t\t\t\tdrawStar(cx, 4);\n\t\t\t\t\tdrawStar(cx, sizeY - 3);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sizeX >= 11 && sizeY >= 11) { // Corner hoshi at (4, 4) for larger sizes\n\t\t\t\tdrawStar(4, 4);\n\t\t\t\tdrawStar(4, sizeY - 3);\n\t\t\t\tdrawStar(sizeX - 3, 4);\n\t\t\t\tdrawStar(sizeX - 3, sizeY - 3);\n\t\t\t} else if (sizeX >= 8 && sizeY >= 8) { // Corner hoshi at (3, 3) for medium sizes\n\t\t\t\tdrawStar(3, 3);\n\t\t\t\tdrawStar(3, sizeY - 2);\n\t\t\t\tdrawStar(sizeX - 2, 3);\n\t\t\t\tdrawStar(sizeX - 2, sizeY - 2);\n\t\t\t} // No corner hoshi for smaller sizes\n\n\t\t\tif (pathStr) { // Only need to add if hoshi drawn\n\t\t\t\tsvg.appendChild(besogo.svgEl('path', { // Drawing circles via path points\n\t\t\t\t\td: pathStr, // Hack to allow radius adjustment via stroke-width\n\t\t\t\t\t'stroke-linecap': 'round', // Makes the points round\n\t\t\t\t\t'class': 'besogo-svg-hoshi'\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tfunction drawStar(i, j) { // Extend path string to draw star point\n\t\t\t\tpathStr += \"M\" + svgPos(i) + ',' + svgPos(j) + 'l0,0'; // Draws a point\n\t\t\t}\n\t\t}\n\n\t\t// Remakes the randomized index for stone images\n\t\tfunction randomizeIndex() {\n\t\t\tvar maxIndex = besogo.BLACK_STONES * besogo.WHITE_STONES,\n\t\t\t\ti, j;\n\n\t\t\trandIndex = [];\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\trandIndex[fromXY(i, j)] = Math.floor(Math.random() * maxIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adds a grid of squares to register mouse events\n\t\tfunction addEventTargets() {\n\t\t\tvar element,\n\t\t\t\ti, j;\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\telement = besogo.svgEl(\"rect\", { // Make a transparent event target\n\t\t\t\t\t\tx: svgPos(i) - CELL_SIZE / 2,\n\t\t\t\t\t\ty: svgPos(j) - CELL_SIZE / 2,\n\t\t\t\t\t\twidth: CELL_SIZE,\n\t\t\t\t\t\theight: CELL_SIZE,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t});\n\n\t\t\t\t\t// Add event listeners, using closures to decouple (i, j)\n\t\t\t\t\telement.addEventListener(\"click\", handleClick(i, j));\n\n\t\t\t\t\tif (!TOUCH_FLAG) { // Skip hover listeners for touch interfaces\n\t\t\t\t\t\telement.addEventListener(\"mouseover\", handleOver(i, j));\n\t\t\t\t\t\telement.addEventListener(\"mouseout\", handleOut(i, j));\n\t\t\t\t\t}\n\n\t\t\t\t\tsvg.appendChild(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction handleClick(i, j) { // Returns function for click handling\n\t\t\treturn function(event) {\n\t\t\t\t// Call click handler in editor\n\t\t\t\teditor.click(i, j, event.ctrlKey, event.shiftKey);\n\t\t\t\tif (!TOUCH_FLAG) {\n\t\t\t\t\t(handleOver(i, j))(); // Ensures that any updated tool is visible\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction handleOver(i, j) { // Returns function for mouse over\n\t\t\treturn function() {\n\t\t\t\tvar element = hoverLayer[fromXY(i, j)];\n\t\t\t\tif (element) { // Make tool action visible on hover over\n\t\t\t\t\telement.setAttribute('visibility', 'visible');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction handleOut(i, j) { // Returns function for mouse off\n\t\t\treturn function() {\n\t\t\t\tvar element = hoverLayer[fromXY(i, j)];\n\t\t\t\tif (element) { // Make tool action invisible on hover off\n\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Redraws the stones\n\t\tfunction redrawStones(current) {\n\t\t\tvar group = besogo.svgEl(\"g\"), // New stone layer group\n\t\t\t\tshadowGroup, // Group for shadow layer\n\t\t\t\ti, j, x, y, color; // Scratch iteration variables\n\n\t\t\tif (editor.SHADOWS) { // Add group for shawdows\n\t\t\t\tshadowGroup = besogo.svgShadowGroup();\n\t\t\t\tgroup.appendChild(shadowGroup);\n\t\t\t}\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\tcolor = current.getStone(i, j);\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\n\t\t\t\t\t\tif (editor.REAL_STONES) { // Realistic stone\n\t\t\t\t\t\t\tgroup.appendChild(besogo.realStone(x, y, color, randIndex[fromXY(i, j)]));\n\t\t\t\t\t\t} else { // SVG stone\n\t\t\t\t\t\t\tgroup.appendChild(besogo.svgStone(x, y, color));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (editor.SHADOWS) { // Draw shadows\n\t\t\t\t\t\t\tshadowGroup.appendChild(besogo.svgShadow(x - 2, y - 4));\n\t\t\t\t\t\t\tshadowGroup.appendChild(besogo.svgShadow(x + 2, y + 4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsvg.replaceChild(group, stoneGroup); // Replace the stone group\n\t\t\tstoneGroup = group;\n\t\t}\n\n\t\t// Redraws the markup\n\t\tfunction redrawMarkup(current) {\n\t\t\tvar element, i, j, x, y, // Scratch iteration variables\n\t\t\t\tgroup = besogo.svgEl(\"g\"), // Group holding markup layer elements\n\t\t\t\tlastMove = current.move,\n\t\t\t\tvariants = editor.getVariants(),\n\t\t\t\tmark, // Scratch mark state {0, 1, 2, 3, 4, 5}\n\t\t\t\tstone, // Scratch stone state {0, -1, 1}\n\t\t\t\tcolor; // Scratch color string\n\n\t\t\tmarkupLayer = []; // Clear the references to the old layer\n\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\tmark = current.getMarkup(i, j);\n\t\t\t\t\tif (mark) {\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\t\t\t\t\t\tstone = current.getStone(i, j);\n\t\t\t\t\t\tcolor = (stone === -1) ? \"white\" : \"black\"; // White on black\n\t\t\t\t\t\tif (lastMove && lastMove.x === i && lastMove.y === j) {\n\t\t\t\t\t\t\t// Mark last move blue or violet if also a variant\n\t\t\t\t\t\t\tcolor = checkVariants(variants, current, i, j) ?\n\t\t\t\t\t\t\t\tbesogo.PURP : besogo.BLUE;\n\t\t\t\t\t\t} else if (checkVariants(variants, current, i, j)) {\n\t\t\t\t\t\t\tcolor = besogo.RED; // Natural variant marks are red\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof mark === 'number') { // Markup is a basic shape\n\t\t\t\t\t\t\tswitch (mark) {\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\telement = besogo.svgCircle(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\telement = besogo.svgSquare(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\telement = besogo.svgTriangle(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\telement = besogo.svgBlock(x, y, color);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // Markup is a label\n\t\t\t\t\t\t\tif (!stone) { // If placing label on empty spot\n\t\t\t\t\t\t\t\telement = makeBacker(x, y);\n\t\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telement = besogo.svgLabel(x, y, color, mark);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\tmarkupLayer[fromXY(i, j)] = element;\n\t\t\t\t\t} // END if (mark)\n\t\t\t\t} // END for j\n\t\t\t} // END for i\n\n\t\t\t// Mark last move with plus if not already marked\n\t\t\tif (lastMove && lastMove.x !== 0 && lastMove.y !== 0) {\n\t\t\t\ti = lastMove.x;\n\t\t\t\tj = lastMove.y;\n\t\t\t\tif (!markupLayer[fromXY(i, j)]) { // Last move not marked\n\t\t\t\t\tcolor = checkVariants(variants, current, i, j) ? besogo.PURP : besogo.BLUE;\n\t\t\t\t\telement = besogo.svgPlus(svgPos(i), svgPos(j), color);\n\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\tmarkupLayer[fromXY(i, j)] = element;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mark variants that have not already been marked above\n\t\t\tmarkRemainingVariants(variants, current, group);\n\n\t\t\tsvg.replaceChild(group, markupGroup); // Replace the markup group\n\t\t\tmarkupGroup = group;\n\t\t} // END function redrawMarkup\n\n\t\tfunction makeBacker(x, y) { // Makes a label markup backer at (x, y)\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: x - CELL_SIZE / 2,\n\t\t\t\ty: y - CELL_SIZE / 2,\n\t\t\t\theight: CELL_SIZE,\n\t\t\t\twidth: CELL_SIZE,\n\t\t\t\topacity: 0.85,\n\t\t\t\tstroke: \"none\",\n\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t});\n\t\t}\n\n\t\t// Checks if (x, y) is in variants\n\t\tfunction checkVariants(variants, current, x, y) {\n\t\t\tvar i, move;\n\t\t\tfor (i = 0; i < variants.length; i++) {\n\t\t\t\tif (variants[i] !== current) { // Skip current (within siblings)\n\t\t\t\t\tmove = variants[i].move;\n\t\t\t\t\tif (move && move.x === x && move.y === y) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Marks variants that have not already been marked\n\t\tfunction markRemainingVariants(variants, current, group) {\n\t\t\tvar element,\n\t\t\t\tmove, // Variant move\n\t\t\t\tlabel, // Variant label\n\t\t\t\tstone, // Stone state\n\t\t\t\ti, x, y; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < variants.length; i++) {\n\t\t\t\tif (variants[i] !== current) { // Skip current (within siblings)\n\t\t\t\t\tmove = variants[i].move;\n\t\t\t\t\t// Check if move, not a pass, and no mark yet\n\t\t\t\t\tif (move && move.x !== 0 && !markupLayer[fromXY(move.x, move.y)]) {\n\t\t\t\t\t\tstone = current.getStone(move.x, move.y);\n\t\t\t\t\t\tx = svgPos(move.x); // Get SVG positions\n\t\t\t\t\t\ty = svgPos(move.y);\n\t\t\t\t\t\tif (!stone) { // If placing label on empty spot\n\t\t\t\t\t\t\telement = makeBacker(x, y);\n\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Label variants with letters A-Z cyclically\n\t\t\t\t\t\tlabel = String.fromCharCode('A'.charCodeAt(0) + (i % 26));\n\t\t\t\t\t\telement = besogo.svgLabel(x, y, besogo.LRED, label);\n\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\tmarkupLayer[fromXY(move.x, move.y)] = element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function markRemainingVariants\n\n\t\t// Redraws the hover layer\n\t\tfunction redrawHover(current) {\n\t\t\tif (TOUCH_FLAG) {\n\t\t\t\treturn; // Do nothing for touch interfaces\n\t\t\t}\n\n\t\t\tvar element, i, j, x, y, // Scratch iteration variables\n\t\t\t\tgroup = besogo.svgEl(\"g\"), // Group holding hover layer elements\n\t\t\t\ttool = editor.getTool(),\n\t\t\t\tchildren,\n\t\t\t\tstone, // Scratch stone state {0, -1, 1} or move\n\t\t\t\tcolor; // Scratch color string\n\n\t\t\thoverLayer = []; // Clear the references to the old layer\n\t\t\tgroup.setAttribute('opacity', '0.35');\n\n\t\t\tif (tool === 'navOnly') { // Render navOnly hover by iterating over children\n\t\t\t\tchildren = current.children;\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tstone = children[i].move;\n\t\t\t\t\tif (stone && stone.x !== 0) { // Child node is move and not a pass\n\t\t\t\t\t\tx = svgPos(stone.x);\n\t\t\t\t\t\ty = svgPos(stone.y);\n\t\t\t\t\t\telement = besogo.svgStone(x, y, stone.color);\n\t\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t\t\tgroup.appendChild(element);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { // Render hover for other tools by iterating over grid\n\t\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\t\tfor (j = 1; j <= sizeY; j++) {\n\t\t\t\t\t\telement = null;\n\t\t\t\t\t\tx = svgPos(i);\n\t\t\t\t\t\ty = svgPos(j);\n\t\t\t\t\t\tstone = current.getStone(i, j);\n\t\t\t\t\t\tcolor = (stone === -1) ? \"white\" : \"black\"; // White on black\n\t\t\t\t\t\tswitch (tool) {\n\t\t\t\t\t\t\tcase 'auto':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, current.nextToMove);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'playB':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, -1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'playW':\n\t\t\t\t\t\t\t\telement = besogo.svgStone(x, y, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addB':\n\t\t\t\t\t\t\t\tif (stone === -1) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = besogo.svgEl('g');\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgStone(x, y, -1));\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgPlus(x, y, besogo.RED));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addW':\n\t\t\t\t\t\t\t\tif (stone === 1) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = besogo.svgEl('g');\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgStone(x, y, 1));\n\t\t\t\t\t\t\t\t\telement.appendChild(besogo.svgPlus(x, y, besogo.RED));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'addE':\n\t\t\t\t\t\t\t\tif (stone) {\n\t\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, besogo.RED);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'clrMark':\n\t\t\t\t\t\t\t\tbreak; // Nothing\n\t\t\t\t\t\t\tcase 'circle':\n\t\t\t\t\t\t\t\telement = besogo.svgCircle(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'square':\n\t\t\t\t\t\t\t\telement = besogo.svgSquare(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'triangle':\n\t\t\t\t\t\t\t\telement = besogo.svgTriangle(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'cross':\n\t\t\t\t\t\t\t\telement = besogo.svgCross(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'block':\n\t\t\t\t\t\t\t\telement = besogo.svgBlock(x, y, color);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'label':\n\t\t\t\t\t\t\t\telement = besogo.svgLabel(x, y, color, editor.getLabel());\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // END switch (tool)\n\t\t\t\t\t\tif (element) {\n\t\t\t\t\t\t\telement.setAttribute('visibility', 'hidden');\n\t\t\t\t\t\t\tgroup.appendChild(element);\n\t\t\t\t\t\t\thoverLayer[fromXY(i, j)] = element;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // END for j\n\t\t\t\t} // END for i\n\t\t\t} // END else\n\n\t\t\tsvg.replaceChild(group, hoverGroup); // Replace the hover layer group\n\t\t\thoverGroup = group;\n\t\t} // END function redrawHover\n\n\t\tfunction svgPos(x) { // Converts (x, y) coordinates to SVG position\n\t\t\treturn BOARD_MARGIN + CELL_SIZE / 2 + (x - 1) * CELL_SIZE;\n\t\t}\n\n\t\tfunction fromXY(x, y) { // Converts (x, y) coordinates to linear index\n\t\t\treturn (x - 1) * sizeY + (y - 1);\n\t\t}\n\t};\n\tbesogo.makeCommentPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar infoTexts = {}, // Holds text nodes for game info properties\n\t\t\tgameInfoTable = document.createElement('table'),\n\t\t\tgameInfoEdit = document.createElement('table'),\n\t\t\tcommentBox = document.createElement('div'),\n\t\t\tcommentEdit = document.createElement('textarea'),\n\t\t\tplayerInfoOrder = 'PW WR WT PB BR BT'.split(' '),\n\t\t\tinfoOrder = 'HA KM RU TM OT GN EV PC RO DT RE ON GC AN US SO CP'.split(' '),\n\t\t\tinfoIds = {\n\t\t\t\tPW: 'White Player',\n\t\t\t\tWR: 'White Rank',\n\t\t\t\tWT: 'White Team',\n\t\t\t\tPB: 'Black Player',\n\t\t\t\tBR: 'Black Rank',\n\t\t\t\tBT: 'Black Team',\n\n\t\t\t\tHA: 'Handicap',\n\t\t\t\tKM: 'Komi',\n\t\t\t\tRU: 'Rules',\n\t\t\t\tTM: 'Timing',\n\t\t\t\tOT: 'Overtime',\n\n\t\t\t\tGN: 'Game Name',\n\t\t\t\tEV: 'Event',\n\t\t\t\tPC: 'Place',\n\t\t\t\tRO: 'Round',\n\t\t\t\tDT: 'Date',\n\n\t\t\t\tRE: 'Result',\n\t\t\t\tON: 'Opening',\n\t\t\t\tGC: 'Comments',\n\n\t\t\t\tAN: 'Annotator',\n\t\t\t\tUS: 'Recorder',\n\t\t\t\tSO: 'Source',\n\t\t\t\tCP: 'Copyright'\n\t\t\t};\n\n\t\tcontainer.appendChild(makeInfoButton());\n\t\tcontainer.appendChild(makeInfoEditButton());\n\t\tcontainer.appendChild(makeCommentButton());\n\t\tcontainer.appendChild(gameInfoTable);\n\t\tcontainer.appendChild(gameInfoEdit);\n\t\tinfoTexts.C = document.createTextNode('');\n\t\tcontainer.appendChild(commentBox);\n\t\tcommentBox.appendChild(infoTexts.C);\n\t\tcontainer.appendChild(commentEdit);\n\n\t\tcommentEdit.onblur = function() {\n\t\t\teditor.setComment(commentEdit.value);\n\t\t};\n\t\tcommentEdit.addEventListener('keydown', function(evt) {\n\t\t\tevt = evt || window.event;\n\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t});\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tgameInfo: editor.getGameInfo()\n\t\t});\n\t\tgameInfoEdit.style.display = 'none'; // Hide game info editting table initially\n\n\t\tfunction update(msg) {\n\t\t\tvar temp; // Scratch for strings\n\n\t\t\tif (msg.navChange) {\n\t\t\t\ttemp = editor.getCurrent().comment || '';\n\t\t\t\tupdateText(commentBox, temp, 'C');\n\t\t\t\tif (editor.getCurrent() === editor.getRoot() &&\n\t\t\t\t\tgameInfoTable.firstChild &&\n\t\t\t\t\tgameInfoEdit.style.display === 'none') {\n\t\t\t\t\tgameInfoTable.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tcommentEdit.style.display = 'none';\n\t\t\t\tcommentBox.style.display = 'block';\n\t\t\t} else if (msg.comment !== undefined) {\n\t\t\t\tupdateText(commentBox, msg.comment, 'C');\n\t\t\t\tcommentEdit.value = msg.comment;\n\t\t\t}\n\n\t\t\tif (msg.gameInfo) { // Update game info\n\t\t\t\tupdateGameInfoTable(msg.gameInfo);\n\t\t\t\tupdateGameInfoEdit(msg.gameInfo);\n\t\t\t}\n\t\t} // END function update\n\n\t\tfunction updateGameInfoTable(gameInfo) {\n\t\t\tvar table = document.createElement('table'),\n\t\t\t\ti, id, row, cell, text; // Scratch iteration variable\n\n\t\t\ttable.className = 'besogo-gameInfo';\n\t\t\tfor (i = 0; i < infoOrder.length; i++) { // Iterate in specified order\n\t\t\t\tid = infoOrder[i];\n\n\t\t\t\tif (gameInfo[id]) { // Only add row if property exists\n\t\t\t\t\trow = document.createElement('tr');\n\t\t\t\t\ttable.appendChild(row);\n\n\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\tcell.appendChild(document.createTextNode(infoIds[id]));\n\t\t\t\t\trow.appendChild(cell);\n\n\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\ttext = document.createTextNode(gameInfo[id]);\n\t\t\t\t\tcell.appendChild(text);\n\t\t\t\t\trow.appendChild(cell);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!table.firstChild || gameInfoTable.style.display === 'none') {\n\t\t\t\ttable.style.display = 'none'; // Do not display empty table or if already hidden\n\t\t\t}\n\t\t\tcontainer.replaceChild(table, gameInfoTable);\n\t\t\tgameInfoTable = table;\n\t\t}\n\n\t\tfunction updateGameInfoEdit(gameInfo) {\n\t\t\tvar table = document.createElement('table'),\n\t\t\t\tinfoTableOrder = playerInfoOrder.concat(infoOrder),\n\t\t\t\ti, id, row, cell, text;\n\n\t\t\ttable.className = 'besogo-gameInfo';\n\t\t\tfor (i = 0; i < infoTableOrder.length; i++) { // Iterate in specified order\n\t\t\t\tid = infoTableOrder[i];\n\t\t\t\trow = document.createElement('tr');\n\t\t\t\ttable.appendChild(row);\n\n\t\t\t\tcell = document.createElement('td');\n\t\t\t\tcell.appendChild(document.createTextNode(infoIds[id]));\n\t\t\t\trow.appendChild(cell);\n\n\t\t\t\tcell = document.createElement('td');\n\t\t\t\ttext = document.createElement('input');\n\t\t\t\tif (gameInfo[id]) {\n\t\t\t\t\ttext.value = gameInfo[id];\n\t\t\t\t}\n\t\t\t\ttext.onblur = function(t, id) {\n\t\t\t\t\treturn function() { // Commit change on blur\n\t\t\t\t\t\teditor.setGameInfo(t.value, id);\n\t\t\t\t\t};\n\t\t\t\t}(text, id);\n\t\t\t\ttext.addEventListener('keydown', function(evt) {\n\t\t\t\t\tevt = evt || window.event;\n\t\t\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t\t\t});\n\t\t\t\tcell.appendChild(text);\n\t\t\t\trow.appendChild(cell);\n\t\t\t}\n\t\t\tif (gameInfoEdit.style.display === 'none') {\n\t\t\t\ttable.style.display = 'none'; // Hide if already hidden\n\t\t\t}\n\t\t\tcontainer.replaceChild(table, gameInfoEdit);\n\t\t\tgameInfoEdit = table;\n\t\t}\n\n\t\tfunction updateText(parent, text, id) {\n\t\t\tvar textNode = document.createTextNode(text);\n\t\t\tparent.replaceChild(textNode, infoTexts[id]);\n\t\t\tinfoTexts[id] = textNode;\n\t\t}\n\n\t\tfunction makeInfoButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Info';\n\t\t\tbutton.title = 'Show/hide game info';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (gameInfoTable.style.display === 'none' && gameInfoTable.firstChild) {\n\t\t\t\t\tgameInfoTable.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tgameInfoEdit.style.display = 'none';\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t\tfunction makeInfoEditButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Edit Info';\n\t\t\tbutton.title = 'Edit game info';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (gameInfoEdit.style.display === 'none') {\n\t\t\t\t\tgameInfoEdit.style.display = 'table';\n\t\t\t\t} else {\n\t\t\t\t\tgameInfoEdit.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tgameInfoTable.style.display = 'none';\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t\tfunction makeCommentButton() {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = 'Comment';\n\t\t\tbutton.title = 'Edit comment';\n\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (commentEdit.style.display === 'none') { // Comment edit box hidden\n\t\t\t\t\tcommentBox.style.display = 'none'; // Hide static comment display\n\t\t\t\t\tgameInfoTable.style.display = 'none'; // Hide game info table\n\t\t\t\t\tcommentEdit.value = editor.getCurrent().comment;\n\t\t\t\t\tcommentEdit.style.display = 'block'; // Show comment edit box\n\t\t\t\t} else { // Comment edit box open\n\t\t\t\t\tcommentEdit.style.display = 'none'; // Hide comment edit box\n\t\t\t\t\tcommentBox.style.display = 'block'; // Show static comment display\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn button;\n\t\t}\n\n\t};\n\tbesogo.makeControlPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar leftElements = [], // SVG elements for previous node buttons\n\t\t\trightElements = [], // SVG elements for next node buttons\n\t\t\tsiblingElements = [], // SVG elements for sibling buttons\n\t\t\tvariantStyleButton, // Button for changing variant style\n\t\t\thideVariantButton, // Button for toggling show/hide variants\n\t\t\tchildVariantElement, // SVG element for child style variants\n\t\t\tsiblingVariantElement, // SVG element for sibling style variants\n\t\t\thideVariantElement; // SVG element for hiding variants\n\n\t\tdrawNavButtons();\n\t\tdrawStyleButtons();\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tvariantStyle: editor.getVariantStyle()\n\t\t}); // Initialize\n\n\t\t// Callback for variant style and nav state changes\n\t\tfunction update(msg) {\n\t\t\tvar current;\n\n\t\t\tif (msg.variantStyle !== undefined) {\n\t\t\t\tupdateStyleButtons(msg.variantStyle);\n\t\t\t}\n\n\t\t\tif (msg.navChange || msg.treeChange) { // Update the navigation buttons\n\t\t\t\tcurrent = editor.getCurrent();\n\t\t\t\tif (current.parent) { // Has parent\n\t\t\t\t\tarraySetColor(leftElements, 'black');\n\t\t\t\t\tif (current.parent.children.length > 1) { // Has siblings\n\t\t\t\t\t\tarraySetColor(siblingElements, 'black');\n\t\t\t\t\t} else { // No siblings\n\t\t\t\t\t\tarraySetColor(siblingElements, besogo.GREY);\n\t\t\t\t\t}\n\t\t\t\t} else { // No parent\n\t\t\t\t\tarraySetColor(leftElements, besogo.GREY);\n\t\t\t\t\tarraySetColor(siblingElements, besogo.GREY);\n\t\t\t\t}\n\t\t\t\tif (current.children.length) { // Has children\n\t\t\t\t\tarraySetColor(rightElements, 'black');\n\t\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.borderColor = \"indianred\";\n\t\t\t\t} else { // No children\n\t\t\t\t\tarraySetColor(rightElements, besogo.GREY);\n\t\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.borderColor = \"limegreen\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction updateStyleButtons(style) { // Updates the variant style buttons\n\t\t\t\tif (style % 2) { // Sibling style variants\n\t\t\t\t\tchildVariantElement.setAttribute('fill', 'black');\n\t\t\t\t\tsiblingVariantElement.setAttribute('fill', besogo.BLUE);\n\t\t\t\t\tvariantStyleButton.title = 'Variants: child/[sibling]';\n\t\t\t\t} else { // Child style variants\n\t\t\t\t\tchildVariantElement.setAttribute('fill', besogo.BLUE);\n\t\t\t\t\tsiblingVariantElement.setAttribute('fill', besogo.RED);\n\t\t\t\t\tvariantStyleButton.title = 'Variants: [child]/sibling';\n\t\t\t\t}\n\t\t\t\tif (style >= 2) { // Hide auto-markup for variants\n\t\t\t\t\thideVariantElement.setAttribute('visibility', 'visible');\n\t\t\t\t\thideVariantButton.title = 'Variants: show/[hide]';\n\t\t\t\t} else { // Show auto-markup for variants\n\t\t\t\t\thideVariantElement.setAttribute('visibility', 'hidden');\n\t\t\t\t\thideVariantButton.title = 'Variants: [show]/hide';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction arraySetColor(list, color) { // Changes fill color of list of svg elements\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < list.length; i++) {\n\t\t\t\t\tlist[i].setAttribute('fill', color);\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function update\n\n\t\t// Draws the navigation buttons\n\t\tfunction drawNavButtons() {\n\t\t\tleftElements.push(makeNavButton('First node',\n\t\t\t\t'5,10 5,90 25,90 25,50 95,90 95,10 25,50 25,10',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.prevNode(-1);\n\t\t\t\t}));\n\t\t\tleftElements.push(makeNavButton('Jump back',\n\t\t\t\t'95,10 50,50 50,10 5,50 50,90 50,50 95,90',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.prevNode(10);\n\t\t\t\t}));\n\t\t\tleftElements.push(makeNavButton('Previous node', '85,10 85,90 15,50', function() {\n\t\t\t\teditor.prevNode(1);\n\t\t\t}));\n\n\t\t\trightElements.push(makeNavButton('Next node', '15,10 15,90 85,50', function() {\n\t\t\t\teditor.nextNode(1);\n\t\t\t}));\n\t\t\trightElements.push(makeNavButton('Jump forward',\n\t\t\t\t'5,10 50,50 50,10 95,50 50,90 50,50 5,90',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.nextNode(10);\n\t\t\t\t}));\n\t\t\trightElements.push(makeNavButton('Last node',\n\t\t\t\t'95,10 95,90 75,90 75,50 5,90 5,10 75,50 75,10',\n\t\t\t\tfunction() {\n\t\t\t\t\teditor.nextNode(-1);\n\t\t\t\t}));\n\n\t\t\tsiblingElements.push(makeNavButton('Previous sibling', '10,85 90,85 50,15', function() {\n\t\t\t\teditor.nextSibling(-1);\n\t\t\t}));\n\t\t\tsiblingElements.push(makeNavButton('Next sibling', '10,15 90,15 50,85', function() {\n\t\t\t\teditor.nextSibling(1);\n\t\t\t}));\n\n\t\t\tfunction makeNavButton(tooltip, pointString, action) { // Creates a navigation button\n\t\t\t\tvar button = document.createElement('button'),\n\t\t\t\t\tsvg = makeButtonContainer(),\n\t\t\t\t\telement = besogo.svgEl(\"polygon\", {\n\t\t\t\t\t\tpoints: pointString,\n\t\t\t\t\t\tstroke: 'none',\n\t\t\t\t\t\tfill: 'black'\n\t\t\t\t\t});\n\n\t\t\t\tbutton.title = tooltip;\n\t\t\t\tbutton.onclick = action;\n\t\t\t\tbutton.appendChild(svg);\n\t\t\t\tsvg.appendChild(element);\n\t\t\t\tcontainer.appendChild(button);\n\n\t\t\t\treturn element;\n\t\t\t} // END function makeNavButton\n\t\t} // END function drawNavButtons\n\n\t\t// Draws the variant style buttons\n\t\tfunction drawStyleButtons() {\n\t\t\tvar svg, element, coordStyleButton;\n\n\t\t\tvariantStyleButton = document.createElement('button');\n\t\t\tvariantStyleButton.onclick = function() {\n\t\t\t\teditor.toggleVariantStyle(false); // Toggles child/sibling variants\n\t\t\t};\n\t\t\tcontainer.appendChild(variantStyleButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\tvariantStyleButton.appendChild(svg);\n\t\t\telement = besogo.svgEl(\"path\", {\n\t\t\t\td: 'm75,25h-50l50,50',\n\t\t\t\tstroke: 'black',\n\t\t\t\t\"stroke-width\": 5,\n\t\t\t\tfill: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(element);\n\t\t\tchildVariantElement = besogo.svgEl('circle', {\n\t\t\t\tcx: 25,\n\t\t\t\tcy: 25,\n\t\t\t\tr: 20,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(childVariantElement);\n\t\t\tsiblingVariantElement = besogo.svgEl('circle', {\n\t\t\t\tcx: 75,\n\t\t\t\tcy: 25,\n\t\t\t\tr: 20,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(siblingVariantElement);\n\t\t\telement = besogo.svgEl('circle', {\n\t\t\t\tcx: 75,\n\t\t\t\tcy: 75,\n\t\t\t\tr: 20,\n\t\t\t\tfill: besogo.RED,\n\t\t\t\tstroke: 'none'\n\t\t\t});\n\t\t\tsvg.appendChild(element);\n\n\t\t\thideVariantButton = document.createElement('button');\n\t\t\thideVariantButton.onclick = function() {\n\t\t\t\teditor.toggleVariantStyle(true); // Toggles show/hide variants\n\t\t\t};\n\t\t\tcontainer.appendChild(hideVariantButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\thideVariantButton.appendChild(svg);\n\t\t\tsvg.appendChild(besogo.svgLabel(50, 50, besogo.RED, 'A'));\n\t\t\thideVariantElement = besogo.svgCross(50, 50, 'black');\n\t\t\tsvg.appendChild(hideVariantElement);\n\n\t\t\tcoordStyleButton = document.createElement('button');\n\t\t\tcoordStyleButton.onclick = function() {\n\t\t\t\teditor.toggleCoordStyle(); // Toggles coordinate style\n\t\t\t};\n\t\t\tcoordStyleButton.title = 'Toggle coordinates';\n\t\t\tcontainer.appendChild(coordStyleButton);\n\t\t\tsvg = makeButtonContainer();\n\t\t\tcoordStyleButton.appendChild(svg);\n\t\t\tsvg.appendChild(besogo.svgLabel(50, 50, 'black', '4'));\n\t\t} // END function drawStyleButtons\n\n\t\t// Makes an SVG container for the button graphics\n\t\tfunction makeButtonContainer() {\n\t\t\treturn besogo.svgEl('svg', {\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%',\n\t\t\t\tviewBox: \"0 0 100 100\"\n\t\t\t});\n\t\t}\n\t};\n\t(function() {\n\t\t'use strict';\n\n\t\t// Parent object to hold coordinate system helper functions\n\t\tbesogo.coord = {};\n\n\t\t// Null function for no coordinate system\n\t\tbesogo.coord.none = function(sizeX, sizeY) {\n\t\t\treturn false;\n\t\t};\n\n\t\t// Western, chess-like, \"A1\" coordinate system\n\t\tbesogo.coord.western = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = numberToLetter(i);\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Simple purely numeric coordinate system\n\t\tbesogo.coord.numeric = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = i + '';\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = i + '';\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Corner-relative, alpha-numeric, coordinate system\n\t\tbesogo.coord.corner = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tif (i < (sizeX / 2) + 1) {\n\t\t\t\t\tlabels.x[i] = numberToLetter(i);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.x[i] = (sizeX - i + 1) + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t\tif (i > (sizeY / 2)) {\n\t\t\t\t\tlabels.y[i] = numberToLetter(sizeY - i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.y[i] = i + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Corner-relative, numeric and CJK, coordinate system\n\t\tbesogo.coord.eastcor = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tif (i < (sizeX / 2) + 1) {\n\t\t\t\t\tlabels.x[i] = numberToCJK(i);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.x[i] = (sizeX - i + 1) + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = (sizeY - i + 1) + '';\n\t\t\t\tif (i > (sizeY / 2)) {\n\t\t\t\t\tlabels.y[i] = numberToCJK(sizeY - i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlabels.y[i] = i + '';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Eastern, numeric and CJK, coordinate system\n\t\tbesogo.coord.eastern = function(sizeX, sizeY) {\n\t\t\tvar labels = {\n\t\t\t\t\tx: [],\n\t\t\t\t\ty: []\n\t\t\t\t},\n\t\t\t\ti;\n\t\t\tfor (i = 1; i <= sizeX; i++) {\n\t\t\t\tlabels.x[i] = i + ''; // Columns are numeric\n\t\t\t}\n\t\t\tfor (i = 1; i <= sizeY; i++) {\n\t\t\t\tlabels.y[i] = numberToCJK(i);\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t};\n\n\t\t// Helper for converting numeric coord to letter (skipping I)\n\t\tfunction numberToLetter(number) {\n\t\t\treturn 'ABCDEFGHJKLMNOPQRSTUVWXYZ'.charAt((number - 1) % 25);\n\t\t}\n\n\t\t// Helper for converting numeric coord to CJK symbol\n\t\tfunction numberToCJK(number) {\n\t\t\tvar label = '',\n\t\t\t\tcjk = '';\n\n\t\t\tif (number >= 20) { // 20 and larger\n\t\t\t\tlabel = cjk.charAt(number / 10 - 1) + '';\n\t\t\t} else if (number >= 10) { // 10 through 19\n\t\t\t\tlabel = '';\n\t\t\t}\n\t\t\tif (number % 10) { // Ones digit if non-zero\n\t\t\t\tlabel = label + cjk.charAt((number - 1) % 10);\n\t\t\t}\n\t\t\treturn label;\n\t\t}\n\n\t})(); // END closure\n\tbesogo.makeEditor = function(sizeX, sizeY) {\n\t\t'use strict';\n\t\t// Creates an associated game state tree\n\t\tvar root = besogo.makeGameRoot(sizeX, sizeY),\n\t\t\tcurrent = root, // Navigation cursor\n\n\t\t\tlisteners = [], // Listeners of general game/editor state changes\n\n\t\t\t// Enumeration of editor tools/modes\n\t\t\tTOOLS = ['navOnly', // read-only navigate mode\n\t\t\t\t'auto', // auto-mode: navigate or auto-play color\n\t\t\t\t'playB', // play black stone\n\t\t\t\t'playW', // play white stone\n\t\t\t\t'addB', // setup black stone\n\t\t\t\t'addW', // setup white stone\n\t\t\t\t'addE', // setup empty stone\n\t\t\t\t'clrMark', // remove markup\n\t\t\t\t'circle', // circle markup\n\t\t\t\t'square', // square markup\n\t\t\t\t'triangle', // triangle markup\n\t\t\t\t'cross', // \"X\" cross markup\n\t\t\t\t'block', // filled square markup\n\t\t\t\t'label'\n\t\t\t], // label markup\n\t\t\ttool = 'auto', // Currently active tool (default: auto-mode)\n\t\t\tlabel = \"1\", // Next label that will be applied\n\n\t\t\tnavHistory = [], // Navigation history\n\n\t\t\tgameInfo = {}, // Game info properties\n\n\t\t\t// Order of coordinate systems\n\t\t\tCOORDS = 'none numeric western eastern corner eastcor'.split(' '),\n\t\t\tcoord = 'none', // Selected coordinate system\n\n\t\t\t// Variant style: even/odd - children/siblings, <2 - show auto markup for variants\n\t\t\tvariantStyle = 2; // 0-3, 0 is default\n\n\t\treturn {\n\t\t\taddListener: addListener,\n\t\t\tclick: click,\n\t\t\tnextNode: nextNode,\n\t\t\tprevNode: prevNode,\n\t\t\tnextSibling: nextSibling,\n\t\t\ttoggleCoordStyle: toggleCoordStyle,\n\t\t\tgetCoordStyle: getCoordStyle,\n\t\t\tsetCoordStyle: setCoordStyle,\n\t\t\ttoggleVariantStyle: toggleVariantStyle,\n\t\t\tgetVariantStyle: getVariantStyle,\n\t\t\tsetVariantStyle: setVariantStyle,\n\t\t\tgetGameInfo: getGameInfo,\n\t\t\tsetGameInfo: setGameInfo,\n\t\t\tsetComment: setComment,\n\t\t\tgetTool: getTool,\n\t\t\tsetTool: setTool,\n\t\t\tgetLabel: getLabel,\n\t\t\tsetLabel: setLabel,\n\t\t\tgetVariants: getVariants, // Returns variants of current node\n\t\t\tgetCurrent: getCurrent,\n\t\t\tsetCurrent: setCurrent,\n\t\t\tcutCurrent: cutCurrent,\n\t\t\tgetRoot: getRoot,\n\t\t\tloadRoot: loadRoot // Loads new game state\n\t\t};\n\n\t\t// Returns the active tool\n\t\tfunction getTool() {\n\t\t\treturn tool;\n\t\t}\n\n\t\t// Sets the active tool, returns false if failed\n\t\tfunction setTool(set) {\n\t\t\t// Toggle label mode if already label tool already selected\n\t\t\tif (set === 'label' && set === tool) {\n\t\t\t\tif (/^-?\\d+$/.test(label)) { // If current label is integer\n\t\t\t\t\tsetLabel('A'); // Toggle to characters\n\t\t\t\t} else {\n\t\t\t\t\tsetLabel('1'); // Toggle back to numbers\n\t\t\t\t}\n\t\t\t\treturn true; // Notification already handled by setLabel\n\t\t\t}\n\t\t\t// Set the tool only if in list and actually changed\n\t\t\tif (TOOLS.indexOf(set) !== -1 && tool !== set) {\n\t\t\t\ttool = set;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\ttool: tool,\n\t\t\t\t\tlabel: label\n\t\t\t\t}); // Notify tool change\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Gets the next label to apply\n\t\tfunction getLabel() {\n\t\t\treturn label;\n\t\t}\n\n\t\t// Sets the next label to apply and sets active tool to label\n\t\tfunction setLabel(set) {\n\t\t\tif (typeof set === 'string') {\n\t\t\t\tset = set.replace(/\\s/g, ' ').trim(); // Convert all whitespace to space and trim\n\t\t\t\tlabel = set || \"1\"; // Default to \"1\" if empty string\n\t\t\t\ttool = 'label'; // Also change current tool to label\n\t\t\t\tnotifyListeners({\n\t\t\t\t\ttool: tool,\n\t\t\t\t\tlabel: label\n\t\t\t\t}); // Notify tool/label change\n\t\t\t}\n\t\t}\n\n\t\t// Toggle the coordinate style\n\t\tfunction toggleCoordStyle() {\n\t\t\tcoord = COORDS[(COORDS.indexOf(coord) + 1) % COORDS.length];\n\t\t\tnotifyListeners({\n\t\t\t\tcoord: coord\n\t\t\t});\n\t\t}\n\n\t\t// Gets the current coordinate style\n\t\tfunction getCoordStyle() {\n\t\t\treturn coord;\n\t\t}\n\n\t\t// Sets the coordinate system style\n\t\tfunction setCoordStyle(setCoord) {\n\t\t\tif (besogo.coord[setCoord]) {\n\t\t\t\tcoord = setCoord;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tcoord: setCoord\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Toggles the style for showing variants\n\t\tfunction toggleVariantStyle(toggleShow) {\n\t\t\tvar childStyle = variantStyle % 2, // 0: children, 1: siblings\n\t\t\t\tshowStyle = variantStyle - childStyle; // 0: show auto-markup, 2: hide\n\t\t\tif (toggleShow) { // Truthy input toggles showing of auto-markup\n\t\t\t\tshowStyle = (showStyle + 2) % 4; // 0 => 2 or 2 => 0\n\t\t\t} else { // Falsy input toggles child vs sibling style\n\t\t\t\tchildStyle = (childStyle + 1) % 2; // 0 => 1 or 1 => 0\n\t\t\t}\n\t\t\tvariantStyle = childStyle + showStyle;\n\t\t\tnotifyListeners({\n\t\t\t\tvariantStyle: variantStyle,\n\t\t\t\tmarkupChange: true\n\t\t\t});\n\t\t}\n\n\t\t// Returns the variant style\n\t\tfunction getVariantStyle() {\n\t\t\treturn variantStyle;\n\t\t}\n\n\t\t// Directly sets the variant style\n\t\tfunction setVariantStyle(style) {\n\t\t\tif (style === 0 || style === 1 || style === 2 || style === 3) {\n\t\t\t\tvariantStyle = 3;\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tvariantStyle: variantStyle,\n\t\t\t\t\tmarkupChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction getGameInfo() {\n\t\t\treturn gameInfo;\n\t\t}\n\n\t\tfunction setGameInfo(info, id) {\n\t\t\tif (id) {\n\t\t\t\tgameInfo[id] = info;\n\t\t\t} else {\n\t\t\t\tgameInfo = info;\n\t\t\t}\n\t\t\tnotifyListeners({\n\t\t\t\tgameInfo: gameInfo\n\t\t\t});\n\t\t}\n\n\t\tfunction setComment(text) {\n\t\t\ttext = text.trim(); // Trim whitespace and standardize line breaks\n\t\t\ttext = text.replace(/\\r\\n/g, '\\n').replace(/\\n\\r/g, '\\n').replace(/\\r/g, '\\n');\n\t\t\ttext.replace(/\\f\\t\\v\\u0085\\u00a0/g, ' '); // Convert other whitespace to space\n\t\t\tcurrent.comment = text;\n\t\t\tnotifyListeners({\n\t\t\t\tcomment: text\n\t\t\t});\n\t\t}\n\n\t\t// Returns variants of the current node according to the set style\n\t\tfunction getVariants() {\n\t\t\tif (variantStyle >= 2) { // Do not show variants if style >= 2\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tif (variantStyle === 1) { // Display sibling variants\n\t\t\t\t// Root node does not have parent nor siblings\n\t\t\t\treturn current.parent ? current.parent.children : [];\n\t\t\t}\n\t\t\treturn current.children; // Otherwise, style must be 0, display child variants\n\t\t}\n\n\t\t// Returns the currently active node in the game state tree\n\t\tfunction getCurrent() {\n\t\t\treturn current;\n\t\t}\n\n\t\t// Returns the root of the game state tree\n\t\tfunction getRoot() {\n\t\t\treturn root;\n\t\t}\n\n\t\tfunction loadRoot(load) {\n\t\t\troot = load;\n\t\t\tcurrent = load;\n\t\t\tnotifyListeners({\n\t\t\t\ttreeChange: true,\n\t\t\t\tnavChange: true,\n\t\t\t\tstoneChange: true\n\t\t\t});\n\t\t}\n\n\t\t// Navigates forward num nodes (to the end if num === -1)\n\t\tfunction nextNode(num) {\n\t\t\tif (current.children.length === 0) { // Check if no children\n\t\t\t\treturn false; // Do nothing if no children (avoid notification)\n\t\t\t}\n\t\t\twhile (current.children.length > 0 && num !== 0) {\n\t\t\t\tif (navHistory.length) { // Non-empty navigation history\n\t\t\t\t\tcurrent = navHistory.pop();\n\t\t\t\t} else { // Empty navigation history\n\t\t\t\t\tcurrent = current.children[0]; // Go to first child\n\t\t\t\t}\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\tnotifyListeners({\n\t\t\t\tnavChange: true\n\t\t\t}, true); // Preserve history\n\t\t}\n\n\t\t// Navigates backward num nodes (to the root if num === -1)\n\t\tfunction prevNode(num) {\n\t\t\tif (current.parent === null) { // Check if root\n\t\t\t\treturn false; // Do nothing if already at root (avoid notification)\n\t\t\t}\n\t\t\twhile (current.parent && num !== 0) {\n\t\t\t\tnavHistory.push(current); // Save current into navigation history\n\t\t\t\tcurrent = current.parent;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\tnotifyListeners({\n\t\t\t\tnavChange: true\n\t\t\t}, true); // Preserve history\n\t\t}\n\n\t\t// Cyclically switches through siblings\n\t\tfunction nextSibling(change) {\n\t\t\tvar siblings,\n\t\t\t\ti = 0;\n\n\t\t\tif (current.parent) {\n\t\t\t\tsiblings = current.parent.children;\n\n\t\t\t\t// Exit early if only child\n\t\t\t\tif (siblings.length === 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Find index of current amongst siblings\n\t\t\t\ti = siblings.indexOf(current);\n\n\t\t\t\t// Apply change cyclically\n\t\t\t\ti = (i + change) % siblings.length;\n\t\t\t\tif (i < 0) {\n\t\t\t\t\ti += siblings.length;\n\t\t\t\t}\n\n\t\t\t\tcurrent = siblings[i];\n\t\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tnavChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Sets the current node\n\t\tfunction setCurrent(node) {\n\t\t\tif (current !== node) {\n\t\t\t\tcurrent = node;\n\t\t\t\t// Notify listeners of navigation (with no tree edits)\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tnavChange: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Removes current branch from the tree\n\t\tfunction cutCurrent() {\n\t\t\tvar parent = current.parent;\n\t\t\tif (tool === 'navOnly') {\n\t\t\t\treturn; // Tree editing disabled in navOnly mode\n\t\t\t}\n\t\t\tif (parent) {\n\t\t\t\tif (confirm(\"Delete this branch?\") === true) {\n\t\t\t\t\tparent.removeChild(current);\n\t\t\t\t\tcurrent = parent;\n\t\t\t\t\t// Notify navigation and tree edited\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle click with application of selected tool\n\t\tfunction click(i, j, ctrlKey, shiftKey) {\n\t\t\tswitch (tool) {\n\t\t\t\tcase 'navOnly':\n\t\t\t\t\tnavigate(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'auto':\n\t\t\t\t\tif (!navigate(i, j, shiftKey) && !shiftKey) { // Try to navigate to (i, j)\n\t\t\t\t\t\tplayMove(i, j, 0, ctrlKey); // Play auto-color move if navigate fails\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'playB':\n\t\t\t\t\tplayMove(i, j, -1, ctrlKey); // Black move\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'playW':\n\t\t\t\t\tplayMove(i, j, 1, ctrlKey); // White move\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addB':\n\t\t\t\t\tplaceSetup(i, j, -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addW':\n\t\t\t\t\tplaceSetup(i, j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'addE':\n\t\t\t\t\tplaceSetup(i, j, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'clrMark':\n\t\t\t\t\tsetMarkup(i, j, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'circle':\n\t\t\t\t\tsetMarkup(i, j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'square':\n\t\t\t\t\tsetMarkup(i, j, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'triangle':\n\t\t\t\t\tsetMarkup(i, j, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cross':\n\t\t\t\t\tsetMarkup(i, j, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'block':\n\t\t\t\t\tsetMarkup(i, j, 5);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'label':\n\t\t\t\t\tsetMarkup(i, j, label);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Navigates to child with move at (x, y), searching tree if shiftKey pressed\n\t\t// Returns true is successful, false if not\n\t\tfunction navigate(x, y, shiftKey) {\n\t\t\tvar i, move,\n\t\t\t\tchildren = current.children;\n\n\t\t\t// Look for move at same location in children\n\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\tmove = children[i].move;\n\t\t\t\tif (move && move.x === x && move.y === y) {\n\t\t\t\t\tcurrent = children[i]; // Navigate to child if found\n\t\t\t\t\t// Notify navigation (with no tree edits)\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\tnavChange: true\n\t\t\t\t\t});\n\t\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.pointerEvents = \"none\";\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdocument.querySelector('[title=\"Next node\"]').click();\n\t\t\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.pointerEvents = \"auto\";\n\t\t\t\t\t}, 400);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (document.getElementsByClassName(\"besogo-diagram\")[0].style.borderColor !== \"limegreen\") {\n\t\t\t\terrorCheck = true;\n\t\t\t}\n\t\t\tif (Persistence.isAvailable()) {\n\t\t\tPersistence.setItem(\"errorCheck\", errorCheck);\n\t\t\t}\n\t\t\treturn false;\n\t\t\t}\n\t\t// Plays a move at the given color and location\n\t\t// Set allowAll to truthy to allow illegal moves\n\t\tfunction playMove(i, j, color, allowAll) {\n\t\t\tvar next;\n\t\t\t// Check if current node is immutable or root\n\t\t\tif (!current.isMutable('move') || !current.parent) {\n\t\t\t\tnext = current.makeChild(); // Create a new child node\n\t\t\t\tif (next.playMove(i, j, color, allowAll)) { // Play in new node\n\t\t\t\t\t// Keep (add to game state tree) only if move succeeds\n\t\t\t\t\tcurrent.addChild(next);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t\t// Notify tree change, navigation, and stone change\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true,\n\t\t\t\t\t\tstoneChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// Current node is mutable and not root\n\t\t\t} else if (current.playMove(i, j, color, allowAll)) { // Play in current\n\t\t\t\t// Only need to update if move succeeds\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tstoneChange: true\n\t\t\t\t}); // Stones changed\n\t\t\t}\n\t\t}\n\n\t\t// Places a setup stone at the given color and location\n\t\tfunction placeSetup(i, j, color) {\n\t\t\tvar next;\n\t\t\tif (color === current.getStone(i, j)) { // Compare setup to current\n\t\t\t\tif (color !== 0) {\n\t\t\t\t\tcolor = 0; // Same as current indicates removal desired\n\t\t\t\t} else { // Color and current are both empty\n\t\t\t\t\treturn; // No change if attempting to set empty to empty\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if current node can accept setup stones\n\t\t\tif (!current.isMutable('setup')) {\n\t\t\t\tnext = current.makeChild(); // Create a new child node\n\t\t\t\tif (next.placeSetup(i, j, color)) { // Place setup stone in new node\n\t\t\t\t\t// Keep (add to game state tree) only if change occurs\n\t\t\t\t\tcurrent.addChild(next);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t\t// Notify tree change, navigation, and stone change\n\t\t\t\t\tnotifyListeners({\n\t\t\t\t\t\ttreeChange: true,\n\t\t\t\t\t\tnavChange: true,\n\t\t\t\t\t\tstoneChange: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (current.placeSetup(i, j, color)) { // Try setup in current\n\t\t\t\t// Only need to update if change occurs\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tstoneChange: true\n\t\t\t\t}); // Stones changed\n\t\t\t}\n\t\t}\n\n\t\t// Sets the markup at the given location and place\n\t\tfunction setMarkup(i, j, mark) {\n\t\t\tvar temp; // For label incrementing\n\t\t\tif (mark === current.getMarkup(i, j)) { // Compare mark to current\n\t\t\t\tif (mark !== 0) {\n\t\t\t\t\tmark = 0; // Same as current indicates removal desired\n\t\t\t\t} else { // Mark and current are both empty\n\t\t\t\t\treturn; // No change if attempting to set empty to empty\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (current.addMarkup(i, j, mark)) { // Try to add the markup\n\t\t\t\tif (typeof mark === 'string') { // If markup is a label, increment the label\n\t\t\t\t\tif (/^-?\\d+$/.test(mark)) { // Integer number label\n\t\t\t\t\t\ttemp = +mark; // Convert to number\n\t\t\t\t\t\t// Increment and convert back to string\n\t\t\t\t\t\tsetLabel(\"\" + (temp + 1));\n\t\t\t\t\t} else if (/[A-Za-z]$/.test(mark)) { // Ends with [A-Za-z]\n\t\t\t\t\t\t// Get the last character in the label\n\t\t\t\t\t\ttemp = mark.charAt(mark.length - 1);\n\t\t\t\t\t\tif (temp === 'z') { // Cyclical increment\n\t\t\t\t\t\t\ttemp = 'A'; // Move onto uppercase letters\n\t\t\t\t\t\t} else if (temp === 'Z') {\n\t\t\t\t\t\t\ttemp = 'a'; // Move onto lowercase letters\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp = String.fromCharCode(temp.charCodeAt() + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Replace last character of label with incremented char\n\t\t\t\t\t\tsetLabel(mark.slice(0, mark.length - 1) + temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnotifyListeners({\n\t\t\t\t\tmarkupChange: true\n\t\t\t\t}); // Notify markup change\n\t\t\t}\n\t\t}\n\n\t\t// Adds a listener (by call back func) that will be notified on game/editor state changes\n\t\tfunction addListener(listener) {\n\t\t\tlisteners.push(listener);\n\t\t}\n\n\t\t// Notify listeners with the given message object\n\t\t//  Data sent to listeners:\n\t\t//    tool: changed tool selection\n\t\t//    label: changed next label\n\t\t//    coord: changed coordinate system \n\t\t//    variantStyle: changed variant style\n\t\t//    gameInfo: changed game info\n\t\t//    comment: changed comment in current node\n\t\t//  Flags sent to listeners:\n\t\t//    treeChange: nodes added or removed from tree\n\t\t//    navChange: current switched to different node\n\t\t//    stoneChange: stones modified in current node\n\t\t//    markupChange: markup modified in current node\n\t\tfunction notifyListeners(msg, keepHistory) {\n\t\t\tvar i;\n\t\t\tif (!keepHistory && msg.navChange) {\n\t\t\t\tnavHistory = []; // Clear navigation history\n\t\t\t}\n\t\t\tfor (i = 0; i < listeners.length; i++) {\n\t\t\t\tlisteners[i](msg);\n\t\t\t}\n\t\t}\n\t};\n\tbesogo.makeFilePanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar fileChooser, // Reference to the file chooser element\n\t\t\telement, // Scratch variable for creating elements\n\t\t\tWARNING = \"Everything not saved will be lost\";\n\n\t\tmakeNewBoardButton(9); // New 9x9 board button\n\t\tmakeNewBoardButton(13); // New 13x13 board button\n\t\tmakeNewBoardButton(19); // New 19x19 board button\n\t\tmakeNewBoardButton('?'); // New custom board button\n\n\t\t// Hidden file chooser element\n\t\tfileChooser = makeFileChooser();\n\t\tcontainer.appendChild(fileChooser);\n\n\t\t// Load file button\n\t\telement = document.createElement('input');\n\t\telement.type = 'button';\n\t\telement.value = 'Open';\n\t\telement.title = 'Import SGF';\n\t\telement.onclick = function() { // Bind click to the hidden file chooser\n\t\t\tfileChooser.click();\n\t\t};\n\t\tcontainer.appendChild(element);\n\n\t\t// Save file button\n\t\telement = document.createElement('input');\n\t\telement.type = 'button';\n\t\telement.value = 'Save';\n\t\telement.title = 'Export SGF';\n\t\telement.onclick = function() {\n\t\t\tvar fileName = prompt('Save file as', 'export.sgf');\n\t\t\tif (fileName) { // Canceled or empty string does nothing\n\t\t\t\tsaveFile(fileName, besogo.composeSgf(editor));\n\t\t\t}\n\t\t};\n\t\tcontainer.appendChild(element);\n\n\n\t\t// Makes a new board button\n\t\tfunction makeNewBoardButton(size) {\n\t\t\tvar button = document.createElement('input');\n\t\t\tbutton.type = 'button';\n\t\t\tbutton.value = size + \"x\" + size;\n\t\t\tif (size === '?') { // Make button for custom sized board\n\t\t\t\tbutton.title = \"New custom size board\";\n\t\t\t\tbutton.onclick = function() {\n\t\t\t\t\tvar input = prompt(\"Enter custom size for new board\" + \"\\n\" + WARNING, \"19:19\"),\n\t\t\t\t\t\tsize;\n\t\t\t\t\tif (input) { // Canceled or empty string does nothing\n\t\t\t\t\t\tsize = besogo.parseSize(input);\n\t\t\t\t\t\teditor.loadRoot(besogo.makeGameRoot(size.x, size.y));\n\t\t\t\t\t\teditor.setGameInfo({});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else { // Make button for fixed size board\n\t\t\t\tbutton.title = \"New \" + size + \"x\" + size + \" board\";\n\t\t\t\tbutton.onclick = function() {\n\t\t\t\t\tif (confirm(button.title + \"?\\n\" + WARNING)) {\n\t\t\t\t\t\teditor.loadRoot(besogo.makeGameRoot(size, size));\n\t\t\t\t\t\teditor.setGameInfo({});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tcontainer.appendChild(button);\n\t\t}\n\n\t\t// Creates the file selector\n\t\tfunction makeFileChooser() {\n\t\t\tvar chooser = document.createElement('input');\n\t\t\tchooser.type = 'file';\n\t\t\tchooser.style.display = 'none'; // Keep hidden\n\t\t\tchooser.onchange = readFile; // Read, parse and load on file select\n\t\t\treturn chooser;\n\t\t}\n\n\t\t// Reads, parses and loads an SGF file\n\t\tfunction readFile(evt) {\n\t\t\tvar file = evt.target.files[0], // Selected file\n\t\t\t\treader = new FileReader(),\n\t\t\t\tnewChooser = makeFileChooser(); // Create new file input to reset selection\n\n\t\t\tcontainer.replaceChild(newChooser, fileChooser); // Replace with the reset selector\n\t\t\tfileChooser = newChooser;\n\n\t\t\treader.onload = function(e) { // Parse and load game tree\n\t\t\t\tvar sgf;\n\t\t\t\ttry {\n\t\t\t\t\tsgf = besogo.parseSgf(e.target.result);\n\t\t\t\t} catch (error) {\n\t\t\t\t\talert('SGF parse error at ' + error.at + ':\\n' + error.message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbesogo.loadSgf(sgf, editor);\n\t\t\t};\n\t\t\tif (confirm(\"Load '\" + file.name + \"'?\\n\" + WARNING)) {\n\t\t\t\treader.readAsText(file); // Initiate file read\n\t\t\t}\n\t\t}\n\n\t\t// Composes SGF file and initializes download\n\t\tfunction saveFile(fileName, text) {\n\t\t\tvar link = document.createElement('a'),\n\t\t\t\tblob = new Blob([text], {\n\t\t\t\t\tencoding: \"UTF-8\",\n\t\t\t\t\ttype: \"text/plain;charset=UTF-8\"\n\t\t\t\t});\n\n\t\t\tlink.download = fileName; // Set download file name\n\t\t\tlink.href = URL.createObjectURL(blob);\n\t\t\tlink.style.display = 'none'; // Make link hidden\n\t\t\tcontainer.appendChild(link); // Add link to ensure that clicking works\n\t\t\tlink.click(); // Click on link to initiate download\n\t\t\tcontainer.removeChild(link); // Immediately remove the link\n\t\t}\n\t};\n\tbesogo.makeGameRoot = function(sizeX, sizeY) {\n\t\t'use strict';\n\t\tvar BLACK = -1, // Stone state constants\n\t\t\tWHITE = 1, // Equal to -BLACK\n\t\t\tEMPTY = 0, // Any falsy (e.g., undefined) value is also empty\n\n\t\t\troot = { // Inherited attributes of root node\n\t\t\t\tnextToMove: BLACK,\n\t\t\t\tblackCaps: 0,\n\t\t\t\twhiteCaps: 0,\n\t\t\t\tmoveNumber: 0\n\t\t\t};\n\n\t\t// Initializes non-inherited attributes\n\t\tfunction initNode(node, parent) {\n\t\t\tnode.parent = parent;\n\t\t\tnode.children = [];\n\n\t\t\tnode.move = null;\n\t\t\tnode.setupStones = [];\n\t\t\tnode.markup = [];\n\t\t\tnode.comment = ''; // Comment on this node\n\t\t}\n\t\tinitNode(root, null); // Initialize root node with null parent\n\n\n\t\t// Plays a move, returns true if successful\n\t\t// Set allow to truthy to allow overwrite, suicide and ko\n\t\troot.playMove = function(x, y, color, allow) {\n\t\t\tvar captures = 0, // Number of captures made by this move\n\t\t\t\toverwrite = false, // Flags whether move overwrites a stone\n\t\t\t\tprevMove, // Previous move for ko check\n\t\t\t\ttestBoard, // Copy of board state to test captures, ko, and suicide\n\t\t\t\tpending, // Pending capture locations\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!this.isMutable('move')) {\n\t\t\t\treturn false; // Move fails if node is immutable\n\t\t\t}\n\n\t\t\tif (!color) { // Falsy color indicates auto-color\n\t\t\t\tcolor = this.nextToMove;\n\t\t\t}\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\tthis.move = { // Register as pass move if out of bounds\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0, // Log pass as position (0, 0)\n\t\t\t\t\tcolor: color,\n\t\t\t\t\tcaptures: 0, // Pass never captures\n\t\t\t\t\toverwrite: false // Pass is never an overwrite\n\t\t\t\t};\n\t\t\t\tthis.nextToMove = -color; // Update next to move\n\t\t\t\tthis.moveNumber++; // Increment move number\n\t\t\t\treturn true; // Pass move successful\n\t\t\t}\n\n\t\t\tif (this.getStone(x, y)) { // Check for overwrite\n\t\t\t\tif (!allow) {\n\t\t\t\t\treturn false; // Reject overwrite move if not allowed\n\t\t\t\t}\n\t\t\t\toverwrite = true; // Otherwise, flag overwrite and proceed\n\t\t\t}\n\n\t\t\ttestBoard = Object.create(this); // Copy board state (no need to initialize)\n\t\t\tpending = []; // Initialize pending capture array\n\n\t\t\tsetStone(testBoard, x, y, color); // Place the move stone\n\n\t\t\t// Check for captures of surrounding chains\n\t\t\tcaptureStones(testBoard, x - 1, y, color, pending);\n\t\t\tcaptureStones(testBoard, x + 1, y, color, pending);\n\t\t\tcaptureStones(testBoard, x, y - 1, color, pending);\n\t\t\tcaptureStones(testBoard, x, y + 1, color, pending);\n\n\t\t\tcaptures = pending.length; // Capture count\n\n\t\t\tprevMove = this.parent ? this.parent.move : null; // Previous move played\n\t\t\tif (!allow && prevMove && // If previous move exists, ...\n\t\t\t\tprevMove.color === -color && // was of the opposite color, ...\n\t\t\t\tprevMove.overwrite === false && // not an overwrite, ...\n\t\t\t\tprevMove.captures === 1 && // captured exactly one stone, and if ...\n\t\t\t\tcaptures === 1 && // this move captured exactly one stone at the location ...\n\t\t\t\t!testBoard.getStone(prevMove.x, prevMove.y)) { // of the previous move\n\t\t\t\treturn false; // Reject ko move if not allowed\n\t\t\t}\n\n\t\t\tif (captures === 0) { // Check for suicide if nothing was captured\n\t\t\t\tcaptureStones(testBoard, x, y, -color, pending); // Invert color for suicide check\n\t\t\t\tcaptures = -pending.length; // Count suicide as negative captures\n\t\t\t\tif (captures < 0 && !allow) {\n\t\t\t\t\treturn false; // Reject suicidal move if not allowed\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (color * captures < 0) { // Capture by black or suicide by white\n\t\t\t\tthis.blackCaps += Math.abs(captures); // Tally captures for black\n\t\t\t} else { // Capture by white or suicide by black\n\t\t\t\tthis.whiteCaps += Math.abs(captures); // Tally captures for white\n\t\t\t}\n\n\t\t\tsetStone(this, x, y, color); // Place the stone\n\t\t\tfor (i = 0; i < pending.length; i++) { // Remove the captures\n\t\t\t\tsetStone(this, pending[i].x, pending[i].y, EMPTY);\n\t\t\t}\n\n\t\t\tthis.move = { // Log the move\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tcolor: color,\n\t\t\t\tcaptures: captures,\n\t\t\t\toverwrite: overwrite\n\t\t\t};\n\t\t\tthis.nextToMove = -color; // Update next to move\n\t\t\tthis.moveNumber++; // Increment move number\n\t\t\treturn true;\n\t\t}; // END func root.playMove\n\n\t\t// Check for and perform capture of opposite color chain at (x, y)\n\t\tfunction captureStones(board, x, y, color, captures) {\n\t\t\tvar pending = [],\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!recursiveCapture(board, x, y, color, pending)) { // Captured chain found\n\t\t\t\tfor (i = 0; i < pending.length; i++) { // Remove captured stones\n\t\t\t\t\tsetStone(board, pending[i].x, pending[i].y, EMPTY);\n\t\t\t\t\tcaptures.push(pending[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Recursively builds a chain of pending captures starting from (x, y)\n\t\t// Stops and returns true if chain has liberties\n\t\tfunction recursiveCapture(board, x, y, color, pending) {\n\t\t\tvar i; // Scratch iteration variable\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Stop if out of bounds\n\t\t\t}\n\t\t\tif (board.getStone(x, y) === color) {\n\t\t\t\treturn false; // Stop if other color found\n\t\t\t}\n\t\t\tif (!board.getStone(x, y)) {\n\t\t\t\treturn true; // Stop and signal that liberty was found\n\t\t\t}\n\t\t\tfor (i = 0; i < pending.length; i++) {\n\t\t\t\tif (pending[i].x === x && pending[i].y === y) {\n\t\t\t\t\treturn false; // Stop if already in pending captures\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpending.push({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t}); // Add new stone into chain of pending captures\n\n\t\t\t// Recursively check for liberties and expand chain\n\t\t\tif (recursiveCapture(board, x - 1, y, color, pending) ||\n\t\t\t\trecursiveCapture(board, x + 1, y, color, pending) ||\n\t\t\t\trecursiveCapture(board, x, y - 1, color, pending) ||\n\t\t\t\trecursiveCapture(board, x, y + 1, color, pending)) {\n\t\t\t\treturn true; // Stop and signal liberty found in subchain\n\t\t\t}\n\t\t\treturn false; // Otherwise, no liberties found\n\t\t}\n\n\t\t// Places a setup stone, returns true if successful\n\t\troot.placeSetup = function(x, y, color) {\n\t\t\tvar prevColor = (this.parent && this.parent.getStone(x, y)) || EMPTY;\n\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Do not allow out of bounds setup\n\t\t\t}\n\t\t\tif (!this.isMutable('setup') || this.getStone(x, y) === color) {\n\t\t\t\t// Prevent setup changes in immutable node or quit early if no change\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsetStone(this, x, y, color); // Place the setup stone\n\t\t\tthis.setupStones[fromXY(x, y)] = color - prevColor; // Record the necessary change\n\t\t\treturn true;\n\t\t};\n\n\t\t// Adds markup, returns true if successful\n\t\troot.addMarkup = function(x, y, mark) {\n\t\t\tif (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n\t\t\t\treturn false; // Do not allow out of bounds markup\n\t\t\t}\n\t\t\tif (this.getMarkup(x, y) === mark) { // Quit early if no change to make\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.markup[fromXY(x, y)] = mark;\n\t\t\treturn true;\n\t\t};\n\n\t\t// Returns the stone status of the given position\n\t\troot.getStone = function(x, y) {\n\t\t\treturn this['board' + x + '-' + y] || EMPTY;\n\t\t};\n\n\t\t// Directly sets the stone state for the given game node\n\t\tfunction setStone(node, x, y, color) {\n\t\t\tnode['board' + x + '-' + y] = color;\n\t\t}\n\n\t\t// Gets the setup stone placed at (x, y), returns false if none\n\t\troot.getSetup = function(x, y) {\n\t\t\tif (!this.setupStones[fromXY(x, y)]) { // No setup stone placed\n\t\t\t\treturn false;\n\t\t\t} else { // Determine net effect of setup stone\n\t\t\t\tswitch (this.getStone(x, y)) {\n\t\t\t\t\tcase EMPTY:\n\t\t\t\t\t\treturn 'AE';\n\t\t\t\t\tcase BLACK:\n\t\t\t\t\t\treturn 'AB';\n\t\t\t\t\tcase WHITE:\n\t\t\t\t\t\treturn 'AW';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Gets the markup at (x, y)\n\t\troot.getMarkup = function(x, y) {\n\t\t\treturn this.markup[fromXY(x, y)] || EMPTY;\n\t\t};\n\n\t\t// Determines the type of this node\n\t\troot.getType = function() {\n\t\t\tvar i;\n\n\t\t\tif (this.move) { // Logged move implies move node\n\t\t\t\treturn 'move';\n\t\t\t}\n\n\t\t\tfor (i = 0; i < this.setupStones.length; i++) {\n\t\t\t\tif (this.setupStones[i]) { // Any setup stones implies setup node\n\t\t\t\t\treturn 'setup';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'empty'; // Otherwise, \"empty\" (neither move nor setup)\n\t\t};\n\n\t\t// Checks if this node can be modified by a 'type' action\n\t\troot.isMutable = function(type) {\n\t\t\t// Can only add a move to an empty node with no children\n\t\t\tif (type === 'move' && this.getType() === 'empty' && this.children.length === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Can only add setup stones to a non-move node with no children\n\t\t\tif (type === 'setup' && this.getType() !== 'move' && this.children.length === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// Gets siblings of this node\n\t\troot.getSiblings = function() {\n\t\t\treturn (this.parent && this.parent.children) || [];\n\t\t};\n\n\t\t// Makes a child node of this node, but does NOT add it to children\n\t\troot.makeChild = function() {\n\t\t\tvar child = Object.create(this); // Child inherits properties\n\t\t\tinitNode(child, this); // Initialize other properties\n\n\t\t\treturn child;\n\t\t};\n\n\t\t// Adds a child to this node\n\t\troot.addChild = function(child) {\n\t\t\tthis.children.push(child);\n\t\t};\n\n\t\t// Remove child node from this node, returning false if failed\n\t\troot.removeChild = function(child) {\n\t\t\tvar i = this.children.indexOf(child);\n\t\t\tif (i !== -1) {\n\t\t\t\tthis.children.splice(i, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// Gets board size\n\t\troot.getSize = function() {\n\t\t\treturn {\n\t\t\t\tx: sizeX,\n\t\t\t\ty: sizeY\n\t\t\t};\n\t\t};\n\n\t\treturn root;\n\n\t\t// Convert (x, y) coordinates to linear index\n\t\tfunction fromXY(x, y) {\n\t\t\treturn (x - 1) * sizeY + (y - 1);\n\t\t}\n\t};\n\t// Load a parsed SGF object into a game state tree\n\tbesogo.loadSgf = function(sgf, editor) {\n\t\t'use strict';\n\t\tvar size = {\n\t\t\t\tx: 19,\n\t\t\t\ty: 19\n\t\t\t}, // Default size (may be changed by load)\n\t\t\troot;\n\n\t\tloadRootProps(sgf); // Load size, variants style and game info\n\t\troot = besogo.makeGameRoot(size.x, size.y);\n\n\t\tloadNodeTree(sgf, root); // Load the rest of game tree\n\t\teditor.loadRoot(root); // Load root into the editor\n\n\n\t\t// Loads the game tree\n\t\tfunction loadNodeTree(sgfNode, gameNode) {\n\t\t\tvar i, nextGameNode;\n\n\t\t\t// Load properties from the SGF node into the game state node\n\t\t\tfor (i = 0; i < sgfNode.props.length; i++) {\n\t\t\t\tloadProp(gameNode, sgfNode.props[i]);\n\t\t\t}\n\n\t\t\t// Recursively load the rest of the tree\n\t\t\tfor (i = 0; i < sgfNode.children.length; i++) {\n\t\t\t\tnextGameNode = gameNode.makeChild();\n\t\t\t\tgameNode.addChild(nextGameNode);\n\t\t\t\tloadNodeTree(sgfNode.children[i], nextGameNode);\n\t\t\t}\n\t\t}\n\n\t\t// Loads property into node\n\t\tfunction loadProp(node, prop) {\n\t\t\tvar setupFunc = 'placeSetup',\n\t\t\t\tmarkupFunc = 'addMarkup',\n\t\t\t\tmove;\n\n\t\t\tswitch (prop.id) {\n\t\t\t\tcase 'B': // Play a black move\n\t\t\t\t\tmove = lettersToCoords(prop.values[0]);\n\t\t\t\t\tnode.playMove(move.x, move.y, -1, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W': // Play a white move\n\t\t\t\t\tmove = lettersToCoords(prop.values[0]);\n\t\t\t\t\tnode.playMove(move.x, move.y, 1, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AB': // Setup black stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AW': // Setup white stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AE': // Setup empty stones\n\t\t\t\t\tapplyPointList(prop.values, node, setupFunc, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'CR': // Add circle markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SQ': // Add square markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'TR': // Add triangle markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M': // Intentional fallthrough treats 'M' as 'MA'\n\t\t\t\tcase 'MA': // Add 'X' cross markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SL': // Add 'selected' (small filled square) markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 5);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L': // Intentional fallthrough treats 'L' as 'LB'\n\t\t\t\tcase 'LB': // Add label markup\n\t\t\t\t\tapplyPointList(prop.values, node, markupFunc, 'label');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C': // Comment placed on node\n\t\t\t\t\tif (node.comment) {\n\t\t\t\t\t\tnode.comment += '\\n' + prop.values.join().trim();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.comment = prop.values.join().trim();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} // END function loadProp\n\n\t\t// Extracts point list and calls func on each\n\t\t// Set param to 'label' to signal handling of label markup property\n\t\tfunction applyPointList(values, node, func, param) {\n\t\t\tvar i, x, y, // Scratch iteration variables\n\t\t\t\tpoint, // Current point in iteration\n\t\t\t\totherPoint, // Bottom-right point of compressed point lists\n\t\t\t\tlabel; // Label extracted from value\n\t\t\tfor (i = 0; i < values.length; i++) {\n\t\t\t\tpoint = lettersToCoords(values[i].slice(0, 2));\n\t\t\t\tif (param === 'label') { // Label markup property\n\t\t\t\t\tlabel = values[i].slice(3).replace(/\\n/g, ' ');\n\t\t\t\t\tnode[func](point.x, point.y, label); // Apply with extracted label\n\t\t\t\t} else { // Not a label markup property\n\t\t\t\t\tif (values[i].charAt(2) === ':') { // Expand compressed point list\n\t\t\t\t\t\totherPoint = lettersToCoords(values[i].slice(3));\n\t\t\t\t\t\tif (otherPoint.x === point.x && otherPoint.y === point.y) {\n\t\t\t\t\t\t\t// Redundant compressed pointlist\n\t\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t\t} else if (otherPoint.x < point.x || otherPoint.y < point.y) {\n\t\t\t\t\t\t\t// Only apply to corners if not arranged properly\n\t\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t\t\tnode[func](otherPoint.x, otherPoint.y, param);\n\t\t\t\t\t\t} else { // Iterate over the compressed points\n\t\t\t\t\t\t\tfor (x = point.x; x <= otherPoint.x; x++) {\n\t\t\t\t\t\t\t\tfor (y = point.y; y <= otherPoint.y; y++) {\n\t\t\t\t\t\t\t\t\tnode[func](x, y, param);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // Apply on single point\n\t\t\t\t\t\tnode[func](point.x, point.y, param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // END function applyPointList\n\n\t\t// Loads root properties (size, variant style and game info)\n\t\tfunction loadRootProps(node) {\n\t\t\tvar gameInfoIds = ['PB', 'BR', 'BT', 'PW', 'WR', 'WT', // Player info\n\t\t\t\t\t'HA', 'KM', 'RU', 'TM', 'OT', // Game parameters\n\t\t\t\t\t'DT', 'EV', 'GN', 'PC', 'RO', // Event info\n\t\t\t\t\t'GC', 'ON', 'RE', // General comments\n\t\t\t\t\t'AN', 'CP', 'SO', 'US'\n\t\t\t\t], // IP credits\n\t\t\t\tgameInfo = {}, // Structure for game info properties\n\t\t\t\ti, id, value; // Scratch iteration variables\n\n\t\t\tfor (i = 0; i < node.props.length; i++) {\n\t\t\t\tid = node.props[i].id; // Property ID\n\t\t\t\tvalue = node.props[i].values.join().trim(); // Join the values array\n\t\t\t\tif (id === 'SZ') { // Size property\n\t\t\t\t\tsize = besogo.parseSize(value);\n\t\t\t\t} else if (id === 'ST') { // Style property\n\t\t\t\t\teditor.setVariantStyle(+value); // Converts value to number\n\t\t\t\t} else if (gameInfoIds.indexOf(id) !== -1) { // Game info property\n\t\t\t\t\tif (id !== 'GC') { // Treat all but GC as simpletext\n\t\t\t\t\t\tvalue = value.replace(/\\n/g, ' '); // Convert line breaks to spaces\n\t\t\t\t\t}\n\t\t\t\t\tif (value) { // Skip load of empty game info strings\n\t\t\t\t\t\tgameInfo[id] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teditor.setGameInfo(gameInfo);\n\t\t}\n\n\t\t// Converts letters to numerical coordinates\n\t\tfunction lettersToCoords(letters) {\n\t\t\tif (letters.match(/^[A-Za-z]{2}$/)) { // Verify input is two letters\n\t\t\t\treturn {\n\t\t\t\t\tx: charToNum(letters.charAt(0)),\n\t\t\t\t\ty: charToNum(letters.charAt(1))\n\t\t\t\t};\n\t\t\t} else { // Anything but two letters\n\t\t\t\treturn {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t}; // Return (0, 0) coordinates\n\t\t\t}\n\t\t}\n\n\t\tfunction charToNum(c) { // Helper for lettersToCoords\n\t\t\tif (c.match(/[A-Z]/)) { // Letters A-Z to 27-52\n\t\t\t\treturn c.charCodeAt(0) - 'A'.charCodeAt(0) + 27;\n\t\t\t} else { // Letters a-z to 1-26\n\t\t\t\treturn c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n\t\t\t}\n\t\t}\n\t};\n\tbesogo.makeNamesPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar playerBox = document.createElement('div'),\n\t\t\twhiteBox = document.createElement('div'),\n\t\t\tblackBox = document.createElement('div'),\n\t\t\twhiteInfo = document.createTextNode(''),\n\t\t\tblackInfo = document.createTextNode(''),\n\t\t\twhiteCaps = document.createElement('span'),\n\t\t\tblackCaps = document.createElement('span');\n\n\t\tplayerBox.className = 'besogo-playerInfo';\n\t\twhiteBox.className = 'besogo-whiteInfo';\n\t\tblackBox.className = 'besogo-blackInfo';\n\t\twhiteCaps.className = 'besogo-whiteCaps';\n\t\twhiteCaps.title = 'White captures';\n\t\tblackCaps.className = 'besogo-blackCaps';\n\t\tblackCaps.title = 'Black captures';\n\t\twhiteBox.appendChild(whiteInfo);\n\t\twhiteBox.appendChild(whiteCaps);\n\t\tblackBox.appendChild(blackInfo);\n\t\tblackBox.appendChild(blackCaps);\n\t\tplayerBox.appendChild(whiteBox);\n\t\tplayerBox.appendChild(blackBox);\n\t\tcontainer.appendChild(playerBox);\n\n\t\teditor.addListener(update);\n\t\tupdate({\n\t\t\tnavChange: true,\n\t\t\tgameInfo: editor.getGameInfo()\n\t\t});\n\n\t\tfunction update(msg) {\n\t\t\tvar infoString, // Scratch string\n\t\t\t\ttextNode,\n\t\t\t\tcurrent,\n\t\t\t\tpassFlag = 0;\n\n\t\t\tif (msg.gameInfo) {\n\t\t\t\tinfoString = (msg.gameInfo.PW || 'White') + // White name\n\t\t\t\t\t' (' + (msg.gameInfo.WR || '?') + ')' + // White rank\n\t\t\t\t\t(msg.gameInfo.WT ? ' ' + msg.gameInfo.WT : ''); // White team\n\t\t\t\ttextNode = document.createTextNode(infoString);\n\t\t\t\twhiteBox.replaceChild(textNode, whiteInfo);\n\t\t\t\twhiteInfo = textNode;\n\n\t\t\t\tinfoString = (msg.gameInfo.PB || 'Black') + // Black name\n\t\t\t\t\t' (' + (msg.gameInfo.BR || '?') + ')' + // Black rank\n\t\t\t\t\t(msg.gameInfo.BT ? ' ' + msg.gameInfo.BT : ''); // Black team\n\t\t\t\ttextNode = document.createTextNode(infoString);\n\t\t\t\tblackBox.replaceChild(textNode, blackInfo);\n\t\t\t\tblackInfo = textNode;\n\t\t\t}\n\n\t\t\tif (msg.navChange || msg.stoneChange) {\n\t\t\t\tcurrent = editor.getCurrent();\n\t\t\t\tif (current.move && current.move.x === 0 && current.move.y === 0) {\n\t\t\t\t\tpassFlag = current.move.color;\n\t\t\t\t}\n\t\t\t\tupdateText(whiteCaps, (passFlag === 1 ? 'Passed  ' : '') + current.whiteCaps);\n\t\t\t\tupdateText(blackCaps, current.blackCaps + (passFlag === -1 ? '  Passed' : ''));\n\t\t\t}\n\t\t}\n\n\t\tfunction updateText(parent, text) {\n\t\t\tvar textNode = document.createTextNode(text);\n\t\t\twhile (parent.firstChild) {\n\t\t\t\tparent.removeChild(parent.firstChild);\n\t\t\t}\n\t\t\tparent.appendChild(textNode);\n\t\t}\n\t};\n\tbesogo.parseSgf = function(text) {\n\t\t'use strict';\n\t\tvar at = 0, // Current position\n\t\t\tch = text.charAt(at); // Current character at position\n\n\t\tfindOpenParens(); // Find beginning of game tree\n\t\treturn parseTree(); // Parse game tree\n\n\t\t// Builds and throws an error\n\t\tfunction error(msg) {\n\t\t\tthrow {\n\t\t\t\tname: \"Syntax Error\",\n\t\t\t\tmessage: msg,\n\t\t\t\tat: at,\n\t\t\t\ttext: text\n\t\t\t};\n\t\t}\n\n\t\t// Advances text position by one\n\t\tfunction next(check) {\n\t\t\tif (check && check !== ch) { // Verify current character if param given\n\t\t\t\terror(\"Expected '\" + check + \"' instead of '\" + ch + \"'\");\n\t\t\t}\n\t\t\tat++;\n\t\t\tch = text.charAt(at);\n\t\t\treturn ch;\n\t\t}\n\n\t\t// Skips over whitespace until non-whitespace found\n\t\tfunction white() {\n\t\t\twhile (ch && ch <= ' ') {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t\t// Skips all chars until '(' or end found\n\t\tfunction findOpenParens() {\n\t\t\twhile (ch && ch !== '(') {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t\t// Returns true if line break (CR, LF, CR+LF, LF+CR) found\n\t\t// Advances the cursor ONCE for double character (CR+LF, LF+CR) line breaks\n\t\tfunction lineBreak() {\n\t\t\tif (ch === '\\n') { // Line Feed (LF)\n\t\t\t\tif (text.charAt(at + 1) === '\\r') { // LF+CR, double character line break\n\t\t\t\t\tnext(); // Advance cursor only once (pointing at second character)\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (ch === '\\r') { // Carriage Return (CR)\n\t\t\t\tif (text.charAt(at + 1) === '\\n') { // CR+LF, double character line break\n\t\t\t\t\tnext(); // Advance cursor only once (pointing at second character)\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false; // Did not find a line break or advance\n\t\t}\n\n\t\t// Parses a sub-tree of the game record\n\t\tfunction parseTree() {\n\t\t\tvar rootNode, // Root of this sub-tree\n\t\t\t\tcurrentNode, // Pointer to parent of the next node\n\t\t\t\tnextNode; // Scratch for parsing the next node or sub-tree\n\n\t\t\tnext('('); // Double-check opening parens at start of sub-tree\n\t\t\twhite(); // Skip whitespace before root node\n\n\t\t\tif (ch !== \";\") { // Error on sub-tree missing root node\n\t\t\t\terror(\"Sub-tree missing root\");\n\t\t\t}\n\t\t\trootNode = parseNode(); // Get the first node of this sub-tree\n\t\t\twhite(); // Skip whitespace before parsing next node\n\n\t\t\tcurrentNode = rootNode; // Parent of the next node parsed\n\t\t\twhile (ch === ';') { // Get sequence of nodes within this sub-tree\n\t\t\t\tnextNode = parseNode(); // Parse the next node\n\t\t\t\t// Add next node as child of current\n\t\t\t\tcurrentNode.children.push(nextNode);\n\t\t\t\tcurrentNode = nextNode; // Advance current pointer to this child\n\t\t\t\twhite(); // Skip whitespace between/after sequence nodes\n\t\t\t}\n\n\t\t\t// Look for sub-trees of this sub-tree\n\t\t\twhile (ch === \"(\") {\n\t\t\t\tnextNode = parseTree(); // Parse the next sub-tree\n\t\t\t\t// Add sub-tree as child of last sequence node\n\t\t\t\tcurrentNode.children.push(nextNode); // Do NOT advance current\n\t\t\t\twhite(); // Skip whitespace between/after sub-trees\n\t\t\t}\n\t\t\tnext(')'); // Expect closing parenthesis at end of this sub-tree\n\n\t\t\treturn rootNode;\n\t\t}\n\n\t\t// Parses a node and its properties\n\t\tfunction parseNode() {\n\t\t\tvar property, // Scratch for parsing properties\n\t\t\t\tnode = {\n\t\t\t\t\tprops: [],\n\t\t\t\t\tchildren: []\n\t\t\t\t}; // Node to construct\n\n\t\t\tnext(';'); // Double-check semi-colon at start of node\n\t\t\twhite(); // Skip whitespace before properties\n\t\t\t// Parse properties until end of node detected\n\t\t\twhile (ch && ch !== ';' && ch !== '(' && ch !== ')') {\n\t\t\t\tproperty = parseProperty(); // Parse the property and values\n\t\t\t\tnode.props.push(property); // Add property to node\n\t\t\t\twhite(); // Skip whitespace between/after properties\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\n\t\t// Parses a property and its values\n\t\tfunction parseProperty() {\n\t\t\tvar property = {\n\t\t\t\tid: '',\n\t\t\t\tvalues: []\n\t\t\t}; // Property to construct\n\n\t\t\t// Look for property ID within letters\n\t\t\twhile (ch && /[A-Za-z]/.test(ch)) {\n\t\t\t\tif (/[A-Z]/.test(ch)) { // Ignores lower case letters\n\t\t\t\t\tproperty.id += ch; // Only adds upper case letters\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t}\n\t\t\tif (!property.id) { // Error if id empty\n\t\t\t\terror('Missing property ID');\n\t\t\t}\n\n\t\t\twhite(); // Skip whitespace before values\n\t\t\twhile (ch === '[') { // Look for values of this property\n\t\t\t\tproperty.values.push(parseValue());\n\t\t\t\twhite(); // Skip whitespace between/after values\n\t\t\t}\n\t\t\tif (property.values.length === 0) { // Error on empty list of values\n\t\t\t\terror('Missing property values');\n\t\t\t}\n\n\t\t\treturn property;\n\t\t}\n\n\t\t// Parses a value\n\t\tfunction parseValue() {\n\t\t\tvar value = '';\n\t\t\tnext('['); // Double-check opening bracket at start of value\n\n\t\t\t// Read until end of value (unescaped closing bracket)\n\t\t\twhile (ch && ch !== ']') {\n\t\t\t\tif (ch === '\\\\') { // Backslash escape handling\n\t\t\t\t\tnext('\\\\');\n\t\t\t\t\tif (lineBreak()) { // Soft (escaped) line break\n\t\t\t\t\t\t// Nothing, soft line breaks are removed\n\t\t\t\t\t} else if (ch <= ' ') { // Other whitespace\n\t\t\t\t\t\tvalue += ' '; // Convert to space\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += ch; // Pass other escaped characters verbatim\n\t\t\t\t\t}\n\t\t\t\t} else { // Non-escaped character\n\t\t\t\t\tif (lineBreak()) { // Hard (non-escaped) line break\n\t\t\t\t\t\tvalue += '\\n'; // Convert all new lines to just LF\n\t\t\t\t\t} else if (ch <= ' ') { // Other whitespace\n\t\t\t\t\t\tvalue += ' '; // Convert to space\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += ch; // Other characters\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t}\n\t\t\tnext(']'); // Expect closing bracket at end of value\n\n\t\t\treturn value;\n\t\t}\n\t};\n\t// Convert game state tree into SGF string\n\tbesogo.composeSgf = function(editor) {\n\t\t'use strict';\n\t\treturn '(' + composeNode(editor.getRoot()) + ')';\n\n\t\t// Recursively composes game node tree\n\t\tfunction composeNode(tree) {\n\t\t\tvar string = ';', // Node starts with semi-colon\n\t\t\t\tchildren = tree.children,\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (!tree.parent) { // Null parent means node is root\n\t\t\t\t// Compose root-specific properties\n\t\t\t\tstring += composeRootProps(tree);\n\t\t\t}\n\t\t\tstring += composeNodeProps(tree); // Compose general properties\n\n\t\t\t// Recurse composition on child nodes\n\t\t\tif (children.length === 1) { // Continue sequence if only one child\n\t\t\t\tstring += '\\n' + composeNode(children[0]);\n\t\t\t} else if (children.length > 1) {\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tstring += '\\n(' + composeNode(children[i]) + ')';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn string;\n\t\t}\n\n\t\t// Composes root specific properties\n\t\tfunction composeRootProps(tree) {\n\t\t\tvar string = 'FF[4]GM[1]CA[UTF-8]AP[besogo:' + besogo.VERSION + ']',\n\t\t\t\tx = tree.getSize().x,\n\t\t\t\ty = tree.getSize().y,\n\t\t\t\tgameInfo = editor.getGameInfo(), // Game info structure\n\t\t\t\thasGameInfo = false, // Flag for existence of game info\n\t\t\t\tid; // Scratch iteration variable\n\n\t\t\tif (x === y) { // Square board size\n\t\t\t\tstring += 'SZ[' + x + ']';\n\t\t\t} else { // Non-square board size\n\t\t\t\tstring += 'SZ[' + x + ':' + y + ']';\n\t\t\t}\n\t\t\tstring += 'ST[' + editor.getVariantStyle() + ']\\n'; // Line break after header\n\n\t\t\tfor (id in gameInfo) { // Compose game info properties\n\t\t\t\tif (gameInfo.hasOwnProperty(id) && gameInfo[id]) { // Skip empty strings\n\t\t\t\t\tstring += id + '[' + escapeText(gameInfo[id]) + ']';\n\t\t\t\t\thasGameInfo = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += (hasGameInfo ? '\\n' : ''); // Line break if game info exists\n\n\t\t\treturn string;\n\t\t}\n\n\t\t// Composes other properties\n\t\tfunction composeNodeProps(node) {\n\t\t\tvar string = '',\n\t\t\t\tprops, // Scratch variable for property structures\n\t\t\t\tstone, i, j; // Scratch iteration variables\n\n\t\t\t// Compose either move or setup properties depending on type of node\n\t\t\tif (node.getType() === 'move') { // Compose move properties\n\t\t\t\tstone = node.move;\n\t\t\t\tstring += (stone.color === 1) ? 'W' : 'B';\n\t\t\t\tstring += '[' + coordsToLetters(stone.x, stone.y) + ']';\n\t\t\t} else if (node.getType() === 'setup') { // Compose setup properties\n\t\t\t\tprops = {\n\t\t\t\t\tAB: [],\n\t\t\t\t\tAW: [],\n\t\t\t\t\tAE: []\n\t\t\t\t};\n\t\t\t\tfor (i = 1; i <= node.getSize().x; i++) {\n\t\t\t\t\tfor (j = 1; j <= node.getSize().y; j++) {\n\t\t\t\t\t\tstone = node.getSetup(i, j);\n\t\t\t\t\t\tif (stone) { // If setup stone placed, add to structure\n\t\t\t\t\t\t\tprops[stone].push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstring += composePointLists(props);\n\t\t\t}\n\n\t\t\t// Compose markup properties\n\t\t\tprops = {\n\t\t\t\tCR: [],\n\t\t\t\tSQ: [],\n\t\t\t\tTR: [],\n\t\t\t\tMA: [],\n\t\t\t\tSL: [],\n\t\t\t\tLB: []\n\t\t\t};\n\t\t\tfor (i = 1; i <= node.getSize().x; i++) {\n\t\t\t\tfor (j = 1; j <= node.getSize().y; j++) {\n\t\t\t\t\tstone = node.getMarkup(i, j);\n\t\t\t\t\tif (stone) { // If markup placed\n\t\t\t\t\t\tif (typeof stone === 'string') { // String is label mark\n\t\t\t\t\t\t\tprops.LB.push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j,\n\t\t\t\t\t\t\t\tlabel: stone\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else { // Numerical code for markup\n\t\t\t\t\t\t\t// Convert numerical code to property ID\n\t\t\t\t\t\t\tstone = (['CR', 'SQ', 'TR', 'MA', 'SL'])[stone - 1];\n\t\t\t\t\t\t\tprops[stone].push({\n\t\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\t\ty: j\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += composePointLists(props);\n\n\t\t\tif (node.comment) { // Compose comment property\n\t\t\t\tstring += (string ? '\\n' : ''); // Add line break if other properties exist\n\t\t\t\tstring += 'C[' + escapeText(node.comment) + ']';\n\t\t\t}\n\n\t\t\treturn string;\n\t\t} // END function composeNodeProps\n\n\t\t// Composes properties from structure of point lists\n\t\t// Each member should be an array of points for property ID = key\n\t\t// Each point should specify point with (x, y) and may have optional label\n\t\tfunction composePointLists(lists) {\n\t\t\tvar string = '',\n\t\t\t\tid, points, i; // Scratch iteration variables\n\n\t\t\tfor (id in lists) { // Object own keys specifies property IDs\n\t\t\t\tif (lists.hasOwnProperty(id)) {\n\t\t\t\t\tpoints = lists[id]; // Corresponding members are point lists\n\t\t\t\t\tif (points.length > 0) { // Only add property if list non-empty\n\t\t\t\t\t\tstring += id;\n\t\t\t\t\t\tfor (i = 0; i < points.length; i++) {\n\t\t\t\t\t\t\tstring += '[' + coordsToLetters(points[i].x, points[i].y);\n\t\t\t\t\t\t\tif (points[i].label) { // Add optional composed label\n\t\t\t\t\t\t\t\tstring += ':' + escapeText(points[i].label);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstring += ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\n\t\t// Escapes backslash and close bracket for text output\n\t\tfunction escapeText(input) {\n\t\t\tinput = input.replace(/\\\\/g, '\\\\\\\\'); // Escape backslash\n\t\t\treturn input.replace(/\\]/g, '\\\\]'); // Escape close bracket\n\t\t}\n\n\t\t// Converts numerical coordinates to letters\n\t\tfunction coordsToLetters(x, y) {\n\t\t\tif (x === 0 || y === 0) {\n\t\t\t\treturn '';\n\t\t\t} else {\n\t\t\t\treturn numToChar(x) + numToChar(y);\n\t\t\t}\n\t\t}\n\n\t\tfunction numToChar(num) { // Helper for coordsToLetters\n\t\t\tif (num > 26) { // Numbers 27-52 to A-Z\n\t\t\t\treturn String.fromCharCode('A'.charCodeAt(0) + num - 27);\n\t\t\t} else { // Numbers 1-26 to a-z\n\t\t\t\treturn String.fromCharCode('a'.charCodeAt(0) + num - 1);\n\t\t\t}\n\t\t}\n\t};\n\t(function() {\n\t\t'use strict';\n\n\t\t// Color palette\n\t\tbesogo.RED = '#be0119'; // Darker red (marked variant)\n\t\tbesogo.LRED = '#ff474c'; // Lighter red (auto-marked variant)\n\t\tbesogo.BLUE = '#0165fc'; // Bright blue (last move)\n\t\tbesogo.PURP = '#9a0eea'; // Red + blue (variant + last move)\n\t\tbesogo.GREY = '#929591'; // Between white and black\n\t\tbesogo.GOLD = '#dbb40c'; // Tool selection\n\t\tbesogo.TURQ = '#06c2ac'; // Turqoise (nav selection)\n\n\t\tbesogo.BLACK_STONES = 4; // Number of black stone images\n\t\tbesogo.WHITE_STONES = 11; // Number of white stone images\n\n\t\t// Makes an SVG element with given name and attributes\n\t\tbesogo.svgEl = function(name, attributes) {\n\t\t\tvar attr, // Scratch iteration variable\n\t\t\t\telement = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n\n\t\t\tfor (attr in (attributes || {})) { // Add attributes if supplied\n\t\t\t\tif (attributes.hasOwnProperty(attr)) {\n\t\t\t\t\telement.setAttribute(attr, attributes[attr]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn element;\n\t\t};\n\n\t\t// Makes an SVG group for containing the shadow layer\n\t\tbesogo.svgShadowGroup = function() {\n\t\t\tvar group = besogo.svgEl('g'),\n\t\t\t\tfilter = besogo.svgEl('filter', {\n\t\t\t\t\tid: 'blur'\n\t\t\t\t}),\n\t\t\t\tblur = besogo.svgEl('feGaussianBlur', {\n\t\t\t\t\tin: 'SourceGraphic',\n\t\t\t\t\tstdDeviation: '2'\n\t\t\t\t});\n\n\t\t\tfilter.appendChild(blur);\n\t\t\tgroup.appendChild(filter);\n\t\t\treturn group;\n\t\t};\n\n\t\t// Makes a stone shadow\n\t\tbesogo.svgShadow = function(x, y) {\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 43,\n\t\t\t\tstroke: 'none',\n\t\t\t\tfill: 'black',\n\t\t\t\topacity: 0.32,\n\t\t\t\tfilter: 'url(#blur)'\n\t\t\t});\n\t\t};\n\n\t\t// Makes a photo realistic stone element\n\t\tbesogo.realStone = function(x, y, color, index) {\n\t\t\tvar element;\n\n\t\t\tif (color < 0) {\n\t\t\t\tcolor = 'black' + (index % besogo.BLACK_STONES);\n\t\t\t} else {\n\t\t\t\tcolor = 'white' + (index % besogo.WHITE_STONES);\n\t\t\t}\n\t\t\tcolor = '_' + color + '.png';\n\n\t\t\telement = besogo.svgEl(\"image\", {\n\t\t\t\tx: (x - 44),\n\t\t\t\ty: (y - 44),\n\t\t\t\theight: 88,\n\t\t\t\twidth: 88\n\t\t\t});\n\t\t\telement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', color);\n\n\t\t\treturn element;\n\t\t};\n\n\t\t// Makes a stone element\n\t\tbesogo.svgStone = function(x, y, color) {\n\t\t\tvar className = \"besogo-svg-greyStone\"; // Grey stone by default\n\n\t\t\tif (color === -1) { // Black stone\n\t\t\t\tclassName = \"besogo-svg-blackStone\";\n\t\t\t} else if (color === 1) { // White stone\n\t\t\t\tclassName = \"besogo-svg-whiteStone\";\n\t\t\t}\n\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 42,\n\t\t\t\t'class': className\n\t\t\t});\n\t\t};\n\n\t\t// Makes a circle at (x, y)\n\t\tbesogo.svgCircle = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y,\n\t\t\t\tr: 27,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes a square at (x, y)\n\t\tbesogo.svgSquare = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: (x - 23),\n\t\t\t\ty: (y - 23),\n\t\t\t\twidth: 46,\n\t\t\t\theight: 46,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an equilateral triangle at (x, y)\n\t\tbesogo.svgTriangle = function(x, y, color) {\n\t\t\t// Approximates an equilateral triangle centered on (x, y)\n\t\t\tvar pointString = \"\" + x + \",\" + (y - 30) + \" \" +\n\t\t\t\t(x - 26) + \",\" + (y + 15) + \" \" +\n\t\t\t\t(x + 26) + \",\" + (y + 15);\n\n\t\t\treturn besogo.svgEl(\"polygon\", {\n\t\t\t\tpoints: pointString,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an \"X\" cross at (x, y)\n\t\tbesogo.svgCross = function(x, y, color) {\n\t\t\tvar path = \"m\" + (x - 24) + \",\" + (y - 24) + \"l48,48m0,-48l-48,48\";\n\n\t\t\treturn besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes an \"+\" plus sign at (x, y)\n\t\tbesogo.svgPlus = function(x, y, color) {\n\t\t\tvar path = \"m\" + x + \",\" + (y - 28) + \"v56m-28,-28h56\";\n\n\t\t\treturn besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t};\n\n\t\t// Makes a small filled square at (x, y)\n\t\tbesogo.svgBlock = function(x, y, color) {\n\t\t\treturn besogo.svgEl(\"rect\", {\n\t\t\t\tx: x - 18,\n\t\t\t\ty: y - 18,\n\t\t\t\twidth: 36,\n\t\t\t\theight: 36,\n\t\t\t\tstroke: \"none\",\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: color\n\t\t\t});\n\t\t};\n\n\t\t// Makes a label at (x, y)\n\t\tbesogo.svgLabel = function(x, y, color, label) {\n\t\t\tvar element,\n\t\t\t\tsize;\n\n\t\t\t// Trims label to 3 characters\n\t\t\tif (label.length > 3) {\n\t\t\t\tlabel = label.slice(0, 2) + '';\n\t\t\t}\n\n\t\t\t// Set font size according to label length\n\t\t\tswitch (label.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsize = 72;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsize = 56;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsize = 36;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\telement = besogo.svgEl(\"text\", {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tdy: \".65ex\", // Seems to work for vertically centering these fonts\n\t\t\t\t\"font-size\": size,\n\t\t\t\t\"text-anchor\": \"middle\", // Horizontal centering\n\t\t\t\t\"font-family\": \"Helvetica, Arial, sans-serif\",\n\t\t\t\tfill: color\n\t\t\t});\n\t\t\telement.appendChild(document.createTextNode(label));\n\n\t\t\treturn element;\n\t\t};\n\n\t})(); // END closure\n\tbesogo.makeToolPanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar element, // Scratch for building SVG images\n\t\t\tsvg, // Scratch for building SVG images\n\t\t\tlabelText, // Text area for next label input\n\t\t\tselectors = {}, // Holds selection rects\n\t\t\tpassButton = document.createElement('input'),\n\t\t\tcutButton = document.createElement('input');\n\n\t\tsvg = makeButtonSVG('auto', 'Auto-play/nav'); // Auto-play/nav tool button\n\t\tsvg.appendChild(makeYinYang(0, 0));\n\n\t\tsvg = makeButtonSVG('playB', 'Play black'); // Play black button\n\t\tsvg.appendChild(besogo.svgStone(0, 0, -1));\n\n\t\tsvg = makeButtonSVG('playW', 'Play white'); // Play white button\n\t\tsvg.appendChild(besogo.svgStone(0, 0, 1));\n\n\t\tsvg = makeButtonSVG('addB', 'Set black'); // Add black button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0, -1)); // Black stone\n\t\telement.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('addW', 'Set white'); // Add white button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0, 1)); // White stone\n\t\telement.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('addE', 'Set empty'); // Add empty button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgStone(0, 0)); // Grey stone\n\t\telement.appendChild(besogo.svgCross(0, 0, besogo.RED)); // Red cross\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('circle', 'Circle'); // Circle markup button\n\t\tsvg.appendChild(besogo.svgCircle(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('square', 'Square'); // Square markup button\n\t\tsvg.appendChild(besogo.svgSquare(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('triangle', 'Triangle'); // Triangle markup button\n\t\tsvg.appendChild(besogo.svgTriangle(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('cross', 'Cross'); // Cross markup button\n\t\tsvg.appendChild(besogo.svgCross(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('block', 'Block'); // Block markup button\n\t\tsvg.appendChild(besogo.svgBlock(0, 0, 'black'));\n\n\t\tsvg = makeButtonSVG('clrMark', 'Clear mark'); // Clear markup button\n\t\telement = besogo.svgEl('g');\n\t\telement.appendChild(besogo.svgTriangle(0, 0, besogo.GREY));\n\t\telement.appendChild(besogo.svgCross(0, 0, besogo.RED));\n\t\tsvg.appendChild(element);\n\n\t\tsvg = makeButtonSVG('label', 'Label'); // Label markup button\n\t\tsvg.appendChild(besogo.svgLabel(0, 0, 'black', 'A1'));\n\n\t\tlabelText = document.createElement(\"input\"); // Label entry text field\n\t\tlabelText.type = \"text\";\n\t\tlabelText.title = 'Next label';\n\t\tlabelText.onblur = function() {\n\t\t\teditor.setLabel(labelText.value);\n\t\t};\n\t\tlabelText.addEventListener('keydown', function(evt) {\n\t\t\tevt = evt || window.event;\n\t\t\tevt.stopPropagation(); // Stop keydown propagation when in focus\n\t\t});\n\t\tcontainer.appendChild(labelText);\n\n\t\tpassButton.type = 'button';\n\t\tpassButton.value = 'Pass';\n\t\tpassButton.title = 'Pass move';\n\t\tpassButton.onclick = function() {\n\t\t\tvar tool = editor.getTool();\n\t\t\tif (tool !== 'navOnly' && tool !== 'auto' && tool !== 'playB' && tool !== 'playW') {\n\t\t\t\teditor.setTool('auto'); // Ensures that a move tool is selected\n\t\t\t}\n\t\t\teditor.click(0, 0, false); // Clicking off the board signals a pass\n\t\t};\n\t\tcontainer.appendChild(passButton);\n\n\t\tcutButton.type = 'button';\n\t\tcutButton.value = 'Cut';\n\t\tcutButton.title = 'Remove branch';\n\t\tcutButton.onclick = function() {\n\t\t\teditor.cutCurrent();\n\t\t};\n\t\tcontainer.appendChild(cutButton);\n\n\t\teditor.addListener(toolStateUpdate); // Set up listener for tool state updates\n\t\ttoolStateUpdate({\n\t\t\tlabel: editor.getLabel(),\n\t\t\ttool: editor.getTool()\n\t\t}); // Initialize\n\n\n\t\t// Creates a button holding an SVG image\n\t\tfunction makeButtonSVG(tool, tooltip) {\n\t\t\tvar button = document.createElement('button'),\n\t\t\t\tsvg = besogo.svgEl('svg', { // Icon container\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\theight: '100%',\n\t\t\t\t\tviewBox: '-55 -55 110 110'\n\t\t\t\t}), // Centered on (0, 0)\n\t\t\t\tselected = besogo.svgEl(\"rect\", { // Selection rectangle\n\t\t\t\t\tx: -50, // Center on (0, 0)\n\t\t\t\t\ty: -50,\n\t\t\t\t\twidth: 100,\n\t\t\t\t\theight: 100,\n\t\t\t\t\tfill: 'none',\n\t\t\t\t\t'stroke-width': 8,\n\t\t\t\t\tstroke: besogo.GOLD,\n\t\t\t\t\trx: 20, // Rounded rectangle\n\t\t\t\t\try: 20, // Thanks, Steve\n\t\t\t\t\tvisibility: 'hidden'\n\t\t\t\t});\n\n\t\t\tcontainer.appendChild(button);\n\t\t\tbutton.appendChild(svg);\n\t\t\tbutton.onclick = function() {\n\t\t\t\teditor.setTool(tool);\n\t\t\t};\n\t\t\tbutton.title = tooltip;\n\t\t\tselectors[tool] = selected;\n\t\t\tsvg.appendChild(selected);\n\t\t\treturn svg; // Returns reference to the icon container\n\t\t}\n\n\t\t// Callback for updating tool state and label\n\t\tfunction toolStateUpdate(msg) {\n\t\t\tvar tool;\n\t\t\tif (msg.label) {\n\t\t\t\tlabelText.value = msg.label;\n\t\t\t}\n\t\t\tif (msg.tool) {\n\t\t\t\tfor (tool in selectors) { // Update which tool is selected\n\t\t\t\t\tif (selectors.hasOwnProperty(tool)) {\n\t\t\t\t\t\tif (msg.tool === tool) {\n\t\t\t\t\t\t\tselectors[tool].setAttribute('visibility', 'visible');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselectors[tool].setAttribute('visibility', 'hidden');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draws a yin yang\n\t\tfunction makeYinYang(x, y) {\n\t\t\tvar element = besogo.svgEl('g');\n\n\t\t\t// Draw black half circle on right side\n\t\t\telement.appendChild(besogo.svgEl(\"path\", {\n\t\t\t\td: \"m\" + x + \",\" + (y - 44) + \" a44 44 0 0 1 0,88z\",\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"black\"\n\t\t\t}));\n\n\t\t\t// Draw white part of ying yang on left side\n\t\t\telement.appendChild(besogo.svgEl(\"path\", {\n\t\t\t\td: \"m\" + x + \",\" + (y + 44) + \"a44 44 0 0 1 0,-88a22 22 0 0 1 0,44z\",\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"white\"\n\t\t\t}));\n\n\t\t\t// Draw round part of black half of ying yang\n\t\t\telement.appendChild(besogo.svgEl(\"circle\", {\n\t\t\t\tcx: x,\n\t\t\t\tcy: y + 22,\n\t\t\t\tr: 22,\n\t\t\t\tstroke: \"none\",\n\t\t\t\tfill: \"black\"\n\t\t\t}));\n\n\t\t\treturn element;\n\t\t}\n\t};\n\tbesogo.makeTreePanel = function(container, editor) {\n\t\t'use strict';\n\t\tvar svg,\n\t\t\tpathGroup,\n\t\t\tbottomLayer,\n\t\t\tcurrentMarker,\n\t\t\tSCALE = 0.25; // Tree size scaling factor\n\n\t\trebuildNavTree();\n\t\teditor.addListener(treeUpdate);\n\n\n\t\t// Callback for handling tree changes\n\t\tfunction treeUpdate(msg) {\n\t\t\tif (msg.treeChange) { // Tree structure changed\n\t\t\t\trebuildNavTree(); // Rebuild entire tree\n\t\t\t} else if (msg.navChange) { // Only navigation changed\n\t\t\t\tupdateCurrentMarker(); // Update current location marker\n\t\t\t} else if (msg.stoneChange) { // Only stones in current changed\n\t\t\t\tupdateCurrentNodeIcon();\n\t\t\t}\n\t\t}\n\n\t\t// Updates the current marker in the tree\n\t\tfunction updateCurrentMarker() {\n\t\t\tvar current = editor.getCurrent();\n\n\t\t\tsetSelectionMarker(currentMarker);\n\t\t\tsetCurrentMarker(current.navTreeMarker);\n\t\t}\n\n\t\t// Sets marker element to indicate the current node\n\t\tfunction setCurrentMarker(marker) {\n\t\t\tvar width = container.clientWidth,\n\t\t\t\theight = container.clientHeight,\n\t\t\t\ttop = container.scrollTop,\n\t\t\t\tleft = container.scrollLeft,\n\t\t\t\tmarkX = (marker.getAttribute('x') - 5) * SCALE, // Computed position of marker\n\t\t\t\tmarkY = (marker.getAttribute('y') - 5) * SCALE,\n\t\t\t\tGRIDSIZE = 120 * SCALE; // Size of the square grid\n\n\t\t\tif (markX < left) { // Ensure horizontal visibility of current marker\n\t\t\t\tcontainer.scrollLeft = markX;\n\t\t\t} else if (markX + GRIDSIZE > left + width) {\n\t\t\t\tcontainer.scrollLeft = markX + GRIDSIZE - width;\n\t\t\t}\n\t\t\tif (markY < top) { // Ensure vertical visibility of current marker\n\t\t\t\tcontainer.scrollTop = markY;\n\t\t\t} else if (markY + GRIDSIZE > top + height) {\n\t\t\t\tcontainer.scrollTop = markY + GRIDSIZE - height;\n\t\t\t}\n\n\t\t\tmarker.setAttribute('opacity', 1); // Always visible\n\t\t\tmarker.onmouseover = null; // Clear hover over action\n\t\t\tmarker.onmouseout = null; // Clear hover off action\n\t\t\tbottomLayer.appendChild(marker); // Moves marker to the background\n\t\t\tcurrentMarker = marker;\n\t\t}\n\n\t\t// Sets marker\n\t\tfunction setSelectionMarker(marker) {\n\t\t\tmarker.setAttribute('opacity', 0); // Normally invisible\n\t\t\tmarker.onmouseover = function() { // Show on hover over\n\t\t\t\tmarker.setAttribute('opacity', 0.5);\n\t\t\t};\n\t\t\tmarker.onmouseout = function() { // Hide on hover off\n\t\t\t\tmarker.setAttribute('opacity', 0);\n\t\t\t};\n\t\t\tsvg.appendChild(marker); // Move marker to foreground\n\t\t}\n\n\t\t// Rebuilds the entire navigation tree\n\t\tfunction rebuildNavTree() {\n\t\t\tvar current = editor.getCurrent(), // Current location in game state tree\n\t\t\t\troot = editor.getRoot(), // Root node of game state\n\t\t\t\tnextOpen = [], // Tracks occupied grid positions\n\t\t\t\toldSvg = svg, // Store the old SVG root\n\t\t\t\tbackground = besogo.svgEl(\"rect\", { // Background color for tree\n\t\t\t\t\theight: '100%',\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\t'class': 'besogo-svg-board'\n\t\t\t\t}),\n\t\t\t\tpath, // Root path\n\t\t\t\twidth, // Calculated dimensions of the SVG\n\t\t\t\theight;\n\n\t\t\tsvg = besogo.svgEl(\"svg\");\n\t\t\tbottomLayer = besogo.svgEl(\"g\"); // Holder for the current marker\n\t\t\tpathGroup = besogo.svgEl(\"g\"); // Holder for path elements\n\n\t\t\tsvg.appendChild(background); // Background color first\n\t\t\tsvg.appendChild(bottomLayer); // Bottom layer (for current marker) second\n\t\t\tsvg.appendChild(pathGroup); // Navigation path third\n\n\t\t\tpath = recursiveTreeBuild(root, 0, 0, nextOpen); // Build the tree\n\t\t\tpathGroup.appendChild(finishPath(path, 'black')); // Finish and add root path\n\n\t\t\twidth = 120 * nextOpen.length; // Compute height and width of nav tree\n\t\t\theight = 120 * Math.max.apply(Math, nextOpen);\n\t\t\tsvg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);\n\t\t\tsvg.setAttribute('height', height * SCALE); // Scale down the actual SVG size\n\t\t\tsvg.setAttribute('width', width * SCALE);\n\n\t\t\tif (oldSvg) { // Replace SVG in container\n\t\t\t\tcontainer.replaceChild(svg, oldSvg);\n\t\t\t} else { // SVG not yet added to container\n\t\t\t\tcontainer.appendChild(svg);\n\t\t\t}\n\n\t\t\tsetCurrentMarker(current.navTreeMarker); // Set current marker and ensure visible\n\t\t} // END function rebuildNavTree\n\n\t\t// Recursively builds the tree\n\t\tfunction recursiveTreeBuild(node, x, y, nextOpen) {\n\t\t\tvar children = node.children,\n\t\t\t\tposition,\n\t\t\t\tpath,\n\t\t\t\tchildPath,\n\t\t\t\ti; // Scratch iteration variable\n\n\t\t\tif (children.length === 0) { // Reached end of branch\n\t\t\t\tpath = 'm' + svgPos(x) + ',' + svgPos(y); // Start path at end of branch\n\t\t\t} else { // Current node has children\n\t\t\t\tposition = (nextOpen[x + 1] || 0); // First open spot in next column\n\t\t\t\tposition = (position < y) ? y : position; // Bring level with current y\n\n\t\t\t\tif (y < position - 1) { // Check if first child natural drop > 1\n\t\t\t\t\ty = position - 1; // Bring current y within 1 of first child drop\n\t\t\t\t}\n\t\t\t\t// Place first child and extend path\n\t\t\t\tpath = recursiveTreeBuild(children[0], x + 1, position, nextOpen) +\n\t\t\t\t\textendPath(x, y, nextOpen);\n\n\t\t\t\t// Place other children (intentionally starting at i = 1)\n\t\t\t\tfor (i = 1; i < children.length; i++) {\n\t\t\t\t\tposition = nextOpen[x + 1];\n\t\t\t\t\tchildPath = recursiveTreeBuild(children[i], x + 1, position, nextOpen) +\n\t\t\t\t\t\textendPath(x, y, nextOpen, position - 1);\n\t\t\t\t\t// End path at beginning of branch\n\t\t\t\t\tpathGroup.appendChild(finishPath(childPath, 'black'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvg.appendChild(makeNodeIcon(node, x, y));\n\t\t\taddSelectionMarker(node, x, y);\n\n\t\t\tnextOpen[x] = y + 1; // Claims (x, y)\n\t\t\treturn path;\n\t\t} // END function recursiveTreeBuild\n\n\t\tfunction makeNodeIcon(node, x, y) { // Makes a node icon for the tree\n\t\t\tvar element,\n\t\t\t\tcolor;\n\n\t\t\tswitch (node.getType()) {\n\t\t\t\tcase 'move': // Move node\n\t\t\t\t\tcolor = node.move.color;\n\t\t\t\t\telement = besogo.svgEl(\"g\");\n\t\t\t\t\telement.appendChild(besogo.svgStone(svgPos(x), svgPos(y), color));\n\t\t\t\t\tcolor = (color === -1) ? \"white\" : \"black\";\n\t\t\t\t\telement.appendChild(besogo.svgLabel(svgPos(x), svgPos(y), color,\n\t\t\t\t\t\t'' + node.moveNumber));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'setup': // Setup node\n\t\t\t\t\telement = besogo.svgEl(\"g\");\n\t\t\t\t\telement.appendChild(besogo.svgStone(svgPos(x), svgPos(y))); // Grey stone\n\t\t\t\t\telement.appendChild(besogo.svgPlus(svgPos(x), svgPos(y), besogo.RED));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: // Empty node\n\t\t\t\t\telement = besogo.svgStone(svgPos(x), svgPos(y)); // Grey stone\n\t\t\t}\n\t\t\tnode.navTreeIcon = element; // Save icon reference in game state tree\n\t\t\tnode.navTreeX = x; // Save position of the icon\n\t\t\tnode.navTreeY = y;\n\n\t\t\treturn element;\n\t\t} // END function makeNodeIcon\n\n\t\tfunction updateCurrentNodeIcon() { // Updates the current node icon\n\t\t\tvar current = editor.getCurrent(), // Current location in game state tree\n\t\t\t\toldIcon = current.navTreeIcon,\n\t\t\t\tnewIcon = makeNodeIcon(current, current.navTreeX, current.navTreeY);\n\t\t\tsvg.replaceChild(newIcon, oldIcon);\n\t\t}\n\n\t\tfunction addSelectionMarker(node, x, y) {\n\t\t\tvar element = besogo.svgEl(\"rect\", { // Create selection marker\n\t\t\t\tx: svgPos(x) - 55,\n\t\t\t\ty: svgPos(y) - 55,\n\t\t\t\twidth: 110,\n\t\t\t\theight: 110,\n\t\t\t\tfill: besogo.TURQ\n\t\t\t});\n\t\t\telement.onclick = function() {\n\t\t\t\teditor.setCurrent(node);\n\t\t\t};\n\n\t\t\tnode.navTreeMarker = element; // Save selection marker in node\n\t\t\tsetSelectionMarker(element); // Add as and set selection marker properties\n\t\t}\n\n\t\tfunction extendPath(x, y, nextOpen, prevChildPos) { // Extends path from child to current\n\t\t\tvar childPos = nextOpen[x + 1] - 1; // Position of child\n\t\t\tif (childPos === y) { // Child is horizontally level with current\n\t\t\t\treturn 'h-120'; // Horizontal line back to current\n\t\t\t} else if (childPos === y + 1) { // Child is one drop from current\n\t\t\t\treturn 'l-120,-120'; // Diagonal drop line back to current\n\t\t\t} else if (prevChildPos && prevChildPos !== y) {\n\t\t\t\t// Previous is already dropped, extend back to previous child drop line\n\t\t\t\treturn 'l-60,-60v-' + (120 * (childPos - prevChildPos));\n\t\t\t} else { // Extend double-bend drop line back to parent\n\t\t\t\treturn 'l-60,-60v-' + (120 * (childPos - y - 1)) + 'l-60,-60';\n\t\t\t}\n\t\t}\n\n\t\tfunction finishPath(path, color) { // Finishes path element\n\t\t\tvar element = besogo.svgEl(\"path\", {\n\t\t\t\td: path,\n\t\t\t\tstroke: color,\n\t\t\t\t\"stroke-width\": 8,\n\t\t\t\tfill: \"none\"\n\t\t\t});\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction svgPos(x) { // Converts (x, y) coordinates to SVG position\n\t\t\treturn (x * 120) + 60;\n\t\t}\n\t};\n\tbesogo.autoInit();\n</script>\n<style>\n\t.besogo-container {\n\t\tborder: 4px solid indianred;\n\t\tborder-radius: 6px;\n\t\tpadding: 7px;\n\t}\n\n\t.besogo-control {\n\t\tmax-width: 400px;\n\t\tmargin: auto;\n\t\tmargin-top: 20px;\n\t}\n\n\t[title=\"Variants: child/[sibling]\"],\n\t[title=\"Variants: [child]/sibling\"],\n\t[title=\"Variants: show/[hide]\"],\n\t[title=\"Toggle coordinates\"],\n\t.besogo-gameInfo {\n\t\tdisplay: none !important;\n\t}\n\n\t.besogo-comment>div {\n\t\tvisibility: visible;\n\t\tmargin-top: 10px;\n\t\tborder-bottom-left-radius: 10px;\n\t\tborder-bottom-right-radius: 10px;\n\t\tpadding: 25px;\n\t\tcolor: #D7DEE9;\n\t\t/* FONT COLOR */\n\t\tbackground-color: #333B45;\n\t\t/* BACKGROUND COLOR */\n\n\t}\n\n\t.card {\n\n\t\theight: 85%;\n\n\t}\n</style>"
                }
            ],
            "type": 0,
            "vers": []
        }
    ],
    "notes": [
        {
            "__type__": "Note",
            "fields": [
                "(;FF[4]CA[UTF-8]GM[1]DT[2021-11-24]PC[OGS: https://online-go.com/game/38948711]GN[Friendly Match]PB[Towel Sniffer]PW[noob_bot_2]BR[?]WR[14k]TM[120]OT[30 fischer]RE[W+R]SZ[19]KM[7.5]RU[Chinese]AP[Sabaki:0.52.0]KTV[1.0]C[noob_bot_2: Hi! This is bot. Join 'noob_bot' group and have fun! Undo will be accepted. You can send undo message if you need.<br><br>SGF generated by KaTrain 1.9.3];B[pd]SBKV[38.52](;W[dp])(;W[dd])(;W[pp]))"
            ],
            "guid": "o;RR6TdLx:",
            "note_model_uuid": "2c89bbe8-4e0f-11ec-899d-d45d6450590b",
            "tags": []
        },
        {
            "__type__": "Note",
            "fields": [
                "(;GM[1]FF[4]SZ[19]HA[0]KM[0]GN[Cho L&amp;amp;D (abc)]AB[aa][ea][eb][ac][bc][cc][dc][ec]AW[da][fa][bb][cb][db][fb][fc][ad][bd][cd][fd][de][ff]C[Elementary]AP[Sabaki:0.52.0]CA[UTF-8];B[ca];W[ba];B[ab];W[dd];B[ca]C[Correct.])"
            ],
            "guid": "IWmXowQNV%",
            "note_model_uuid": "2c89c052-4e0f-11ec-899d-d45d6450590b",
            "tags": []
        }
    ]
}