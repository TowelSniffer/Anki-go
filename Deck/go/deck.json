{
    "__type__": "Deck",
    "children": [
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "fcc8d66c-b836-11eb-bd0c-d45d6450590b",
            "deck_config_uuid": "52ca97d1-8f2f-11eb-8a99-d45d6450590b",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "_shinkaya4.jpg"
            ],
            "name": "1. Learn Go",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[de][ed][fe]AW[ee]LB[ef:1]C[Black to capture the white stone with the next move. Since diagonal intersections do not count, this stone has only 1 liberty left.] (;B[ef]TE[1]C[Yup. But that was easy. Try the next one. Next puzzle]) (;B[df]C[No. To be fair, after this move White would not be able to escape but I am asking you to CAPTURE with a single move.]) (;B[ff]C[No. To be fair, after this move White would not be able to escape but I am asking you to CAPTURE with a single move.]) (;B[eg]C[Yeah, yeah, very clever. Stop joking and capture with ONE move.]))"
                    ],
                    "guid": "t`pC$hc/8`",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ba][cb][fa][fb][ec]AW[da][ea][eb][ca]C[Black to capture the whole White group with the next move!] (;B[db]TE[1]C[Right on! <br><a class='puzzleNext' onclick='loadTsumego('2-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[bb]C[To be fair, White would still not be able to escape after this move, but the assignment was to capture in one move.]) (;B[cc]C[To be fair, White would still not be able to escape after this move, but the assignment was to capture in one move.]) (;B[dc]C[To be fair, White would still not be able to escape after this move, but the assignment was to capture in one move.]) (;B[fc]C[To be fair, White would still not be able to escape after this move, but the assignment was to capture in one move.]))"
                    ],
                    "guid": "voY;eUT>TP",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[ia][fa][ea]AB[id][ie]C[Sides and especially corners can be very tricky! Any stone at the edge of the board is already shorter on liberties. Black to capture the white stone. This time more than one move will be required.] (;B[ha] ;W[ib]C[To reduce the stone to 1 liberty first (while blocking access to White's other stones) is the right idea! Now finish the deal.] (;B[hb];W[ic] ;B[hc]TE[1]C[That's the way! At the edge of the board it is hard to find more liberties. <br><a class='puzzleNext' onclick='loadTsumego('2-4','pzl4',tsumego)'>Next puzzle</a>]) (;B[hc] ;W[hb]C[Interesting idea! But now White gets the time (has the extra liberty) to counter attack.] (;B[ga];W[gb]) (;B[gb];W[ga];B[ic] ;W[ha]C[Good attempt, but White managed to safely connect to her other stones.]) (;B[gc] ;W[gb]C[White is now safe.]))) (;B[ib];W[ha];B[hb] ;W[ga]C[No, this way White gets to connect to her other stones]) (;B[hb] ;W[ha]C[Good idea! But it does not work here, White's other stones are too close.] (;B[ib] ;W[ga]C[White is safely connected.]) (;B[ga];W[gb])))"
                    ],
                    "guid": "oA<qN4U$)v",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ee]AW[de][ed][fe]C[Now it is black stone that is in atari! Save it from capture.] (;B[ef]TE[1]LB[df:1][eg:2][ff:3]C[Precisely. By connecting to another stone, you increased the liberties of your group (from 1 to 3) and prevented White from capturing.]) (;B[ff];W[ef]) (;B[df];W[ef]) (;B[eg];W[ef]) (;B[dg];W[ef]) (;B[fg];W[ef]))"
                    ],
                    "guid": "cI4I$je9V5",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]SZ[9]CA[UTF-8]AB[ga][gb][gc][hc][ic][ig][ih][hh][gh][gi][hi][ii][gg]AW[ha][hb][ib][if][hf][gf][ff][fg][fh][fi][cb][bc][cd][dc]LB[cc:A][ia:C][hg:B]C[You are not allowed to place a stone at A or B, the placed stone would have no liberties. However; you can place a stone at C because you capture something with that move. Try it.];B[ia]TE[1]C[Feels good, right? <br><a class='puzzleNext' onclick='loadTsumego('3-2','pzl2',tsumego)'>Next puzzle</a>])"
                    ],
                    "guid": "Olqzot7;oy",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]C[Black can capture something here too. Find out what.]AB[da][fb][fa][ec][gc][hc][ic][fc][hb][ha]AW[ea][eb][cb][ca][dc][bc][ac][cc];B[db]TE[1]C[Yes, perfect! <br><a class='puzzleNext' onclick='loadTsumego('3-3','pzl3',tsumego)'>Next puzzle</a>])"
                    ],
                    "guid": "I/#1hNSj7z",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Sabaki:0.43.3]CA[UTF-8]SZ[9]AB[ca][cb][cc][cd][bd][ad]AW[ac][bc][bb][ba]LB[aa:A][ab:B]C[In situations like these, Black can play both A or B. While the placed stone can get captured with the next move, it is not against the rules, because whichever spot you choose the stone will have at least one liberty for the moment. Try it.] (;B[aa] ;W[ab]C[As expected, your stone got captured but is it a bad result? Capture the whole White group.];B[aa]TE[1]C[Perfect. The last move captured something so it is not illegal either. Black sacrificed one stone, but captured much more.]) (;B[ab] ;W[aa]C[As expected, your stone got captured but is it a bad result? Capture the whole White group.];B[ab]TE[1]C[Perfect. The last move captured something so it is not illegal either. Black sacrificed one stone, but captured much more.]))"
                    ],
                    "guid": "rWNJv?J@G8",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ed][fe][ef]AW[ce][dd][ee][df]LB[de:A]C[First let's have a look at an isolated example. Capture the white stone at A. This move is not suicide because by capturing it you gain one extra liberty.];B[de] ;W[ec]MA[de]LB[ee:A][fc:B]C[White must not retake the marked stone(X) immediately. It is prohibited by the Ko rule. The board position would repeat. Instead White has played at E7. You can connect to end the ko at A or play elsewhere at B (for example).] (;B[ee]TE[1]C[This ko is now over. However, ko makes little sense as an isolated situation. Explore the other option or check out <a class='puzzleNext' onclick='loadTsumego('4-2','pzl2',tsumego)'>next puzzle</a>.]) (;B[fc] ;W[ee]MA[ee]TE[1]C[The board position is now different than before so White may recapture the original ko. It is now you, who has to play elsewhere once before you may recapture that stone. Explore the other option or see <a class='puzzleNext' onclick='loadTsumego('4-2','pzl2',tsumego)'>next puzzle</a>.]))"
                    ],
                    "guid": "iF*CDXG9NO",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ba][ab][cb][ca][bb][db][da][eb][fc][gc][hc][ic]AW[fb][gb][ga][ha][hb][ib][ac][bc][cc][dc][ec][ea]MA[ba][ca][da][eb][db][cb][bb][ab]C[A lot more than capture of one stone can depend on the result of a ko. Let's check out this scary situation. Eight of black stones are in atari! Try to find a way to save them somehow.] (;B[ed];W[aa]) (;B[dd];W[aa]) (;B[cd];W[aa]) (;B[bd];W[aa]) (;B[ad];W[aa]) (;B[fa] ;W[fd]C[Correct! This is a good first step. This is also a ko (just on the edge of the board). Your stone is in atari, but White cannot recapture right away. She must play somewhere else at least once.] (;B[ia]TE[1]C[An easy win for Black! Check out Puzzle 3 to see how it may get even scarier. <br><a class='puzzleNext' onclick='loadTsumego('4-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[ea] ;W[aa]C[Oh no! You just made White very happy. Be more careful next time.]) (;B[gd] ;W[ea]C[Not a good choice! Now White get's to recapture the ko and since Black cannot retake E4 immediately, White will just probably capture all your stones after next move.]) (;B[hd] ;W[ea]C[Not a good choice! Now White get's to recapture the ko and since Black cannot retake E4 immediately, White will just probably capture all your stones after next move.]) (;B[ed] ;W[ea]C[Not a good choice! Now White get's to recapture the ko and since Black cannot retake E4 immediately, White will just probably capture all your stones after next move.])))"
                    ],
                    "guid": "Kf,36>VR-0",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]C[The local ko situation is the same as before. However, there are also other groups on the board. It changes the whole ko fight dramatically. Try to save your stones now.]AB[ab][ba][cb][ca][bb][db][da][eb][fc][gc][hc][ic][ah][bh][ch][ci] [ei][eh][fh][fi][gh][hh][hi][ih][ii][bi]AW[ea][fb][gb][ga][ha][hb][ib][ec][dc][cc][bc][ac][ag][bg][cg][dg] [eg][fg][gg][hg][ig] (;B[fa] ;W[dh]C[Yes, the start is the same. This time however, White has something to threaten because there are other, not yet completely settled, stones on the board. White's move (at D2) is what we call a ko-threat.]MA[ah][ch][bi][ci][bh][eh][ei][fh][gh][fi][hh][ih][ii][hi] (;B[di] ;W[ea]MA[ab][bb][cb][db][eb][da][ca][ba]TE[1]C[If Black chooses to answer the threat, White gets to re-take the ko. Since there is nothing big for Black to threaten, he will probably lose the ko and all the stones at the top. Go back and see what would happen if you ignored the ko threat.]) (;B[ia] ;W[di]MA[ah][bh][ch][ci][bi][eh][ei][fi][fh][gh][hh][ih][ii][hi]TE[1]C[Black can choose to ignore the threat and finish the ko but that means he will lose all his bottom stones now. The hard part of ko fights is judging who has more threats and how valuable they are.])) (;B[dh] ;W[aa]TE[1]C[A very interesting idea! Indeed, you can avoid the ko completely. However, it is often better to force the ko (even though you can't win it) to force your opponent to lose one of her ko threats.]))"
                    ],
                    "guid": "m7t6BT?c?K",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;FF[4]GM[1]VW[aa][ba][ca][da][ea][fa][ga][ha][ia][ja][ab][bb][cb][db][eb][fb][gb][hb][ib][jb][ac][bc][cc][dc][ec][fc][gc][hc][ic][jc][ad][bd][cd][dd][ed][fd][gd][hd][id][jd][ae][be][ce][de][ee][fe][ge][he][ie][je][af][bf][cf][df][ef][ff][gf][hf][if][jf][ag][bg][cg][dg][eg][fg][gg][hg][ig][jg][ah][bh][ch][dh][eh][fh][gh][hh][ih][jh][ai][bi][ci][di][ei][fi][gi][hi][ii][ji][aj][bj][cj][dj][ej][fj][gj][hj][ij][jj]SZ[9]ST[2]EV[N° 1 .|. Level #2]AB[ff][dc][eb][ec][dd][cd][de][df][dg][dh][eh][fi]AW[fb][fc][fd][ee][ge][ef][eg][fh][gi][fg]C[Save the stone that is in atari (danger of immediate capture).]AP[Sabaki:0.43.3]CA[UTF-8](;B[ei];W[gh]C[Very good. Then make sure that all the borders are clearly defined. There should be no place where the border is still open. Only territory that is FULLY surrounded can be counted.](;B[ea];W[fa]TE[1]C[Not perfect, but good enough. The game is now ready to be scored but you could have played better (Playing F9 would have been an extra 2 points).])(;B[fa];W[ga]C[Now there is a stone in atari again. Fix it.];B[ea];W[gb]C[Great! Now the game is ready to be scored AND you played all the best moves.]TE[1]))(;B[gh];W[ei]C[Oooops, well that did not go so well. Better try again.])(;B[gf];W[ei]C[You've lost the stone at F1. Try again.]))"
                    ],
                    "guid": "NNF2_U/w_8",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Sabaki:0.43.3]CA[UTF-8]SZ[9]AB[ab][bb][cb][db][da]AW[ac][bc][cc][dc][eb][ea][fc]C[Your black group is in trouble but there is still time to save it! Do it now.] (;B[ba]L[aa][ca]TE[1]C[Nothing White can do now.  :) <br><a class=\"puzzleNext\" onclick=\"loadTsumego(\" 6-2','pzl2',tsumego)'=\"\">Next puzzle</a>]) (;B[aa] ;W[ba]C[Now what?];B[ca] ;W[ba]C[Try something different from the start.]) (;B[ca] ;W[ba]C[Now what?];B[aa] ;W[ba]C[Try something different from the start.]) (;B[ec]C[What are you trying you sneaky sneaker?];W[ba];B[fb];W[ed];B[fa] ;W[ec]C[Huh, did not work out so well, did it? Now your group will eventually die.]) (;B[ed]C[What are you trying you sneaky sneaker?];W[ba];B[ec] ;W[ca]C[ATARI!] (;B[aa] ;W[ba]C[Atari again.] (;B[fb];W[ca] ;PL[B]AB[gc]C[Try a different way to save the original group but at least you got a little compensation. :)]) (;B[ca] ;W[ba]C[Try a different way to save the group.])) (;B[fb] ;W[aa]C[Try a different way to save the original group.];PL[B]AB[gc]C[Try a different way to save the original group but at least you got a little compensation. :)])))"
                    ],
                    "guid": "NSN@+NW~M",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]C[Switch places! Now you destroy White!]AB[ad][bd][cc][dd][db][da]AW[bb][cb][ca][bc][ac] (;B[aa] ;W[ba]C[Yeah, all you need to do is take away the one move White needed to stay alive. Now White can't make two eyes anymore.];B[ab]TE[1]C[Yeah! Of course the last two moves were not necessary, just to illustrate. <br><a class='puzzleNext' onclick='loadTsumego('6-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[ba] ;W[aa]C[Now what?]) (;B[ab] ;W[aa]C[Now what?]))"
                    ],
                    "guid": "Pky(piu(R",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[ab][bb][cb][db][ba][ea]AB[fb][eb][dc][cc][bc][ac][ed]C[This one is to try and clearly illustrate the concept of false eyes. Kill the whole White group. It can be done. Just take away the one spot White needs to have two eyes.] (;B[da] ;W[ca]C[This move, really? But White just captured your stone... Perhaps, but now E9 is not connected to the rest of the White group. You can atari the E9 stone whenever you like. This makes the eye at D9 false. The whole group will eventually die.];B[fa];W[da] ;B[aa]TE[1]C[There is nothing White could have done after the first move. <br><a class='puzzleNext' onclick='loadTsumego('6-4','pzl4',tsumego)'>Next puzzle</a>]) (;B[fa] ;W[da]C[The atari may feel good but White just connects and has two eyes. In fact you have pushed White into making the correct move (for White).]) (;B[ca] ;W[da]C[What was the plan again?]))"
                    ],
                    "guid": "c:s1~1D:FW",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Sabaki:0.43.3]CA[UTF-8]SZ[9]AB[ha][ib][ga][hc]AW[hd][id][fa][fb][fd][fc][ge]C[A little harder to see now.  Save your black group. Remember, you somehow need to get two separate eyes.] (;B[gb] ;W[gc]C[Perfect start! J9 and H8 will form the eyes but White keeps up the pressure. You need one more move. Play A9 to see what happens if you play elsewhere.]MA[aa] (;B[ic]C[Right on! Now White can't endanger Black in any way.]TE[1]) (;B[aa] ;W[ic]C[See now? The H7 stone is not really connected to your group. Now White can put it into atari and ruin your eye.];B[hb];W[ia])) (;B[ic] ;W[gb]C[Ah-oh. Where will you get your second eye now? You need te be efficient. There is no time to waste.] (;B[gc];W[hb]) (;B[hb] ;W[gc]C[Just one eye. White can now capture at any time.])) (;B[gc];W[gb] ;B[hb]C[Still just one eye. White can surround and then capture now.]))"
                    ],
                    "guid": "ceJDiWZ>OT",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[ed][de]AB[fe][ee]C[This is the classic 'CUT NOW' shape. You have two solidly connected stones with lots of room. White has two lone stones. Prevent them from ever connecting. It should be good for you.] (;B[dd];W[cd] ;B[dc]TE[1]C[When you cut something the first thing to expect is that your cutting stone will get in atari (although it is often not the best move for your opponent) so you need to be sure that the stone can escape. <br><a class='puzzleNext' onclick='loadTsumego('7-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[fd];W[dd]) (;B[dc];W[dd]) (;B[cc];W[dd]) (;B[cd];W[dd]) (;B[df];W[dd]) (;B[cf];W[dd]) (;B[fc];W[dd]))"
                    ],
                    "guid": "gQKE#<Vdls",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]C[Cutting onto 2nd line can be tricky though. White just cut you, keep your stones connected somehow.]AB[ce][bd]AW[cd][dd][be]CR[be] (;B[bf];W[ae] (;B[ad];W[bc] ;B[af]TE[1]C[Exactly. Stones so close to the edge have nowhere to run to gain more liberties. <br><a class='puzzleNext' onclick='loadTsumego('7-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[af];W[bc] (;B[ad]TE[1]C[Exactly. Stones so close to the edge have nowhere to run to gain more liberties. <br><a class='puzzleNext' onclick='loadTsumego('7-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[ac];W[ad] ;B[bd]TE[1]C[Very clever! Snapback. <br><a class='puzzleNext' onclick='loadTsumego('7-3','pzl3',tsumego)'>Next puzzle</a>])) (;B[cf];W[bc] (;B[af];W[ad]) (;B[ad];W[ac]))) (;B[cf];W[bc] (;B[bf];W[ad]) (;B[ad];W[ae];B[bf];W[ac])) (;B[bc] ;W[cf]C[This black stone will be captured in a ladder. Try another way]))"
                    ],
                    "guid": "i4}V04%W2",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Sabaki:0.43.3]CA[UTF-8]SZ[9]AW[ca][cb][cc][bd][ag][bg][cg][cf][ce]AB[da][db][dc][cd][de][df][dg][dh][ch][bh][ah][dd]C[Cutting onto 2nd line can be REALLY tricky though. Sometimes you can get away with it by sacrificing one stone :)](;B[bc];W[bb];B[be];W[ac](;B[bf];W[ae];B[af]C[Not bad, right? :)]TE[1])(;B[af]C[Not bad, right? :)]TE[1])(;B[ae];W[ad]C[Not so good. Now you can't capture those white stones. Just try.];B[bf];W[af]))(;B[be];W[ae](;B[bf];W[af])(;B[bc];W[bf](;B[bb]C[Not bad :)]TE[1])(;B[ac];W[bb];B[ab]C[Yes, possible.]TE[1];W[ad];B[ba]TE[1])(;B[ba]C[Interesting choice, but it works! Good job.]TE[1])(;B[ab]TE[1]C[Yes, this move technically also works, though it can lead to some complications. Maybe something simpler would be safer (or were you just trying to trick me?)]))))"
                    ],
                    "guid": "fTgsz.;=lu",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[ae][be][dc][eb][ea][cd]AB[ce][dd][ec][ee][cf][fc]C[White is getting SO MUCH points in the corner. If only there was a way to break through his border...] (;B[cc] ;W[db]C[Double atari is the answer! Whichever stone white saves she/he is still in trouble. (And you get to capture the other)] (;B[bd]TE[1]C[Yup. Having a lot of diagonal stones can often be a problem, because there is so many places to cut them. <br><a class=\"puzzleNext\" onclick=\"loadTsumego(\" 8-2','pzl2',tsumego)'=\"\">Next puzzle</a>]) (;B[cb] ;W[bd]TE[1]C[You are getting way too clever for this tutorial. Yes, this also works and Black will capture first, but try to keep it simple. :) <br><a class=\"puzzleNext\" onclick=\"loadTsumego(\" 8-2','pzl2',tsumego)'=\"\">Next puzzle</a>]) (;B[bc] ;W[bd]TE[1]C[You are getting way too clever for this tutorial. Yes, this also works and Black will capture first, but try to keep it simple. :) <br><a class=\"puzzleNext\" onclick=\"loadTsumego(\" 8-2','pzl2',tsumego)'=\"\">Next puzzle</a>])) (;B[bd] ;W[cc]C[This only threatened one stone. White can save it.];B[bc];W[bb] (;B[cb];W[db];B[ab];W[ba] (;B[ca] ;W[da]C[A good effort, but no]) (;B[bf];W[ac] (;B[af] ;W[ad]C[A good effort, but no];B[bc] ;W[aa]C[A good effort, but no]) (;B[ad] ;W[ac]C[A good effort, but no])) (;B[aa] ;W[ac]C[A good effort, but no])) (;B[ab];W[ac] (;B[cb];W[ad]) (;B[ad] ;W[ac]C[A good effort, but no]))) (;B[db];W[cc];B[cb];W[bb] (;B[bc];W[bd] (;B[ac] ;W[ca]C[A good effort, but no]) (;B[ba];W[ab];B[ac] ;W[ad]C[A good effort, but no])) (;B[ba];W[ca] (;B[da] ;W[ca]C[A good effort, but no]) (;B[bc];W[da];B[cb] ;W[aa]C[A good effort, but no]))) (;B[bc];W[cc]))"
                    ],
                    "guid": "xjE0L{%7v`",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[gc][gd][fe][ef][df][fb][ce][ga][cf]AW[fc][fd][de][ee][dc][cd][eb][bd]C[Works even better with more than one stone! Capture some white stones.] (;B[ed];W[dd] ;B[ec]TE[1]C[Oh yeah. <br><a class='puzzleNext' onclick='loadTsumego('8-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[ec];W[ed]) (;B[dd];W[ed]))"
                    ],
                    "guid": "Q!h)yzrin{",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ag][bg][dg][ed][de][hg][ig][gh][cf][ee][fe][ge][hd][gf]AW[dd][ec][ce][be][ae][bc][fd][gd][hc][ic][he][ie][bb]C[White is winning for now, but his border sure does not seem bulletproof. This time you have to set it up a little.] (;B[dc] ;W[cd]C[Great start. Now for the finishing blow.] (;B[fc];W[gc] ;B[eb]C[White is devastated.]TE[1]) (;B[gc];W[fc])) (;B[fc] ;W[gc]C[Great start. Now for the finishing blow.] (;B[dc];W[fb] ;B[cd]C[White is devastated.]TE[1]) (;B[fb] ;W[dc]C[Oh no, this gave white time to fix. You should have sacrificed the one stone for much bigger gain.]) (;B[cd];W[dc] (;B[bd] ;W[ad]MA[bd][cd]) (;B[cc] ;W[cb]MA[cc][cd]))) (;B[cd];W[dc] (;B[fc] ;W[gc]C[Nope, that just solidified white.]) (;B[gc] ;W[fc]C[Nope, that just solidified white.]) (;B[bd] ;W[ad]C[A good effort, but your stones will just get captured.]MA[bd][cd])) (;B[gc];W[fc] (;B[cd] ;W[dc]C[Nope, that just solidified white.]) (;B[dc] ;W[cd]C[Nope, that just solidified white.];B[fb];W[gb];B[eb];W[gc])))"
                    ],
                    "guid": "hUktu4yq=U",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ee]AW[ed][dd][fe][ef]C[It is easy. Your stone is in atari, save it.];B[de] ;W[ce]C[Oh no, atari again, quickly, save them.];B[df] ;W[dg]C[Ooops, now it is three stones in atari? (See the pattern emerging?) Save them.];B[cf] ;W[bf]C[Keep going];B[cg] ;W[ch]C[Almost there, keep saving them, can't give up now.];B[bg] ;W[bh]C[huh a different move to spice things up? This might be your chance];B[ag] ;W[ah]C[ummmm you are in atari again...] (;B[af] ;W[ae]TE[1]C[Yeah, there was no way to save that stone. Every move just kept making it worse. <br><a class='puzzleNext' onclick='loadTsumego('9-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[be] ;W[af]TE[1]C[Yeah, there was no way to save that stone. Every move just kept making it worse. <br><a class='puzzleNext' onclick='loadTsumego('9-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[cd] ;W[af]TE[1]C[Yeah, there was no way to save that stone. Every move just kept making it worse. <br><a class='puzzleNext' onclick='loadTsumego('9-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[ff] ;W[af]TE[1]C[Yeah, there was no way to save that stone. Every move just kept making it worse. <br><a class='puzzleNext' onclick='loadTsumego('9-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[eg] ;W[af]TE[1]C[Yeah, there was no way to save that stone. Every move just kept making it worse. <br><a class='puzzleNext' onclick='loadTsumego('9-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[dh] ;W[af]TE[1]C[Yeah, there was no way to save that stone. Every move just kept making it worse. <br><a class='puzzleNext' onclick='loadTsumego('9-2','pzl2',tsumego)'>Next puzzle</a>]))"
                    ],
                    "guid": "qUtA.6jD,W",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[ed][ef][de][ff]AB[ee][hc]C[The shape where ladders start is usually something similar to this. (Just often with more stones around). Even one little stone can make all the difference though. Try saving your stone again.] (;B[fe];W[ge];B[fd] ;W[fc]C[That little stone in the distance? We call it ladder breaker. And it makes all the difference in the world.];B[gd];W[hd];B[gc] ;W[gb]TE[1]C[By connecting to another stone you got that very needed extra liberties. Now white is in a sea of trouble. Do you see all the upcoming double ataris? :) <br><a class='puzzleNext' onclick='loadTsumego('9-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[fd];W[fe]) (;B[ge];W[fe]) (;B[gd];W[fe]))"
                    ],
                    "guid": "C4{mtoAT+h",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]C[Doesn't have to be a single stone either. Capture the five white stones. Be careful, it is a little trickier than before.]AW[de][ee][fe][fd][ec][ef]AB[ed][dd][ce][df][ff][fc][eg][fg] (;B[ge];W[gd] (;B[hd];W[gc] (;B[gb] ;W[fb]C[Ooops, you pushed your opponent into putting you in atari!]) (;B[fb];W[cd];B[dc];W[cf] (;B[dg] ;W[be]C[White is out.]) (;B[be] ;W[dg]C[White is out]))) (;B[gc] ;W[hd]C[This way you did not catch the stones in a ladder. White is able to secure 3 liberties, can you still capture?] (;B[he] ;W[cf]C[Atari];B[dg] ;W[cd]C[And double atari. White will capture something and escape.]) (;B[hc] ;W[cf]C[Atari];B[dg] ;W[cd]C[And double atari. White will capture something and escape.]) (;B[id] ;W[cf]C[Atari];B[dg] ;W[cd]C[And double atari. White will capture something and escape.]))) (;B[gd];W[ge];B[he];W[gf] (;B[gg];W[hf] (;B[hg];W[if] (;B[ig];W[ie] ;B[id]TE[1]) (;B[ie];W[ig] ;B[ih]TE[1])) (;B[if];W[hg];B[hh];W[ig] ;B[ih]TE[1])) (;B[hf];W[gg] (;B[hg] ;W[gh]C[White will get out. Three liberties now.]) (;B[gh];W[hg] (;B[ig];W[hh] (;B[hi];W[ih] ;B[ii]TE[1]) (;B[ih];W[hi] (;B[ii];W[if]) (;B[gi];W[gc] ;B[ii]TE[1]))) (;B[hh];W[ig] (;B[ih];W[hd] (;B[if]TE[1]) (;B[gc];W[ie])) (;B[if];W[hd];B[ih])))) (;B[hg] ;W[gc]C[Nope, no time for clever moves, you need to keep white to only one liberty, otherwise you get double-ataried.])))"
                    ],
                    "guid": "MymCxeyv)H",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[cb][cc][bd][ac][dd][gg]AB[be][ce][cd][dc][ec][db]C[White just cut you with his D6 stone, hoping to split your groups. Capture his stone to stay connected.]CR[dd] (;B[ed];W[de] (;B[df];W[ee];B[fe];W[ef];B[eg];W[ff] (;B[gf] ;W[fg]C[No, the ladder does not work for you. White can connect to his other stone.]) (;B[fg] ;W[gf]C[No, the ladder does not work for you. White can connect to his other stone.])) (;B[ee] ;W[df]C[Can't kill white now.])) (;B[de];W[ed] (;B[fd];W[ee];B[ef];W[fe];B[ge] ;W[ff]C[No, the ladder does not work for you.] (;B[fg] ;W[gf]C[No, the ladder does not work for you. White can connect to his other stone.]) (;B[gf] ;W[fg]C[No, the ladder does not work for you. White can connect to his other stone.])) (;B[ee] ;W[fd]C[Can't kill white now.])) (;B[ee];W[ed];B[fd] ;W[de]TE[1];B[df]TE[1]C[Oh yeah. You do not have to take away a liberty right away. Just take away the possible escape routes. The capture itself can wait for a bit. Patience! <br><a class='puzzleNext' onclick='loadTsumego('10-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[fe];W[de];B[df];W[ef] ;B[ee]TE[1]C[Yes, this works too. <br><a class='puzzleNext' onclick='loadTsumego('10-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[ef];W[ed];B[fd];W[fe] ;B[ee]TE[1]C[Yes, this works too. <br><a class='puzzleNext' onclick='loadTsumego('10-2','pzl2',tsumego)'>Next puzzle</a>]))"
                    ],
                    "guid": "nyDV18GSpt",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[dc][ec][fc][cd][bd][de][df][bf]AW[ca][bb][bc][cc][db][dd][ed][ee]C[Same idea. Capture white's cutting stones.] (;B[ef];W[gd];B[fd];W[fe];B[ge];W[ff] (;B[fg];W[gf] ;B[hf]C[Atari. And it falls apart from now. Find a better way.]) (;B[gf] ;W[fg]C[Can't kill white now.])) (;B[ff] ;W[gd]C[This is probably the most severe response by white. But it is not enough.];B[fd];W[fe];B[ge];W[gf] (;B[ef]C[White is sad now.]TE[1]) (;B[he]TE[1]C[Yes, depending on the situation you may want to extend here first...])) (;B[gf];W[ff] (;B[fg] ;W[ge]DO[]C[The original net might have been too lose. Depending on your fighting abilities you may still capture first, but you could have saved yourself a lot of trouble.]) (;B[ge] ;W[fg]C[The original net might have been too lose. Depending on your fighting abilities you may still capture first, but you could have saved yourself a lot of trouble.])) (;B[ge] ;W[ff]C[A bit too loose. White can probably break through and escape capture.]))"
                    ],
                    "guid": "s98D]w%Ol}",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[cd][cc][dc][ec][fd][fe][ff][gc][ef]AW[dd][ed][ce][cf][df][be][dg][bg]C[Capture the two white stones.] (;B[ee] ;W[de]C[Ummmmm, no.]) (;B[de] ;W[ee]C[Ahaaaa, white captured your stone. But does that help her/him in any way?];B[de]TE[1]C[No. No it doesn't help white in any way. Very good. <br><a class='puzzleNext' onclick='loadTsumego('11-2','pzl2',tsumego)'>Next puzzle</a>]))"
                    ],
                    "guid": "D19gX7Xf[8",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[de][dd][dc][ec][fc][fd][fe][df][ff][eg][eh][dh][ch][bh][ah][fh] [gh][hh][ih][hg][hf][if][bg][bf][be]AB[db][eb][fb][cc][cd][ce][gc][gd][ge][cf][gf][fg][dg][cg][gg][ee] [af]C[A little harder now, capture something.] (;B[ed];W[ef]) (;B[ef];W[ed] (;B[ee];W[ef]) (;B[ef];W[ee] ;B[ef]TE[1]C[Ouch. Next puzzle])))"
                    ],
                    "guid": "G5:%,7p@TD",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]C[Is white really safe? This is a tough one.]AB[df][bd][bc][cc][dc][ec][fc][fd][ge][gf][gg][gh][fh]AW[cd][dd][ed][fe][ff][fg][be][cf][dg][eh] (;B[ee] ;W[eg]C[White can't atari those stones from either side, as it would be self atari. Connecting seems the strongest option.] (;B[de] ;W[ce]C[No]) (;B[ef] ;W[de]C[What?]) (;B[ce];W[de] ;B[ce]C[Magic!]TE[1])) (;B[ef];W[ee] (;B[ce];W[eg]) (;B[eg];W[de])) (;B[de];W[ee];B[ce];W[ef]))"
                    ],
                    "guid": "LhBMJ0)-WF",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ab][bb][cb][db][eb][fb][fa]AW[ac][bc][cc][dc][ec][fc][gc][gb][ga][ba][ca][da]C[It is your turn. If you want to say the three white stones are dead, you will have to capture them to prove it!] (;B[ea] ;W[aa]C[Ouch! Turns out however you try to put these stones into atari you will always get captured first. Dang it! See puzzle 2 <br><a class='puzzleNext' onclick='loadTsumego('12-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[aa] ;W[ea]C[Ouch! Turns out however you try to put these stones into atari you will always get captured first. Dang it! See puzzle 2 <br><a class='puzzleNext' onclick='loadTsumego('12-2','pzl2',tsumego)'>Next puzzle</a>]))"
                    ],
                    "guid": "c:wDA-::fR",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]C[Let's switch sides. If the first player could not capture those three stones, then it is him who must be in trouble, right? Capture the big helpless white group!]AB[ba][ca][da][ac][bc][cc][dc][ec][fc][gc][gb][ga]AW[ab][bb][cb][db][eb][fb][fa] (;B[ea] ;W[aa]C[Your opponent still captures first. Question is, can you prevent life now? Can you prevent two eyes?] (;B[ca] ;W[da]C[You cannot.]) (;B[da] ;W[ca]C[You cannot.])) (;B[aa] ;W[ea]C[Your opponent still captures first. Question is, can you prevent life now? Can you prevent two eyes?] (;B[ca] ;W[ba]C[You cannot.]) (;B[ba] ;W[ca]C[You cannot.])))"
                    ],
                    "guid": "zIU&jL%hW6",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ah][bi][ch][bh][ci][cg][dg][ei][fi][fh]AW[af][bf][cf][df][eg][fg][gh][gi][gf][di]C[Looks like a dire situation for Black. White's D1 is falsifying your eye. Is there still a way to save your group? (wouldn't ask if there wasn't...)] (;B[dh] ;W[eh]C[You can capture, yeah, but now your stones are in atari and you have just one eye. The whole group dies.]) (;B[eh] ;W[dh]C[What a weird move. Ugly shape and self-atari at once. And yet, it is the only correct move. White captures.] (;B[eh];W[ei] ;B[fi]TE[1]C[But there is now enough room and a handy cut to recapture and get an eye. <br><a class='puzzleNext' onclick='loadTsumego('12plus-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[ei];W[eh])))"
                    ],
                    "guid": "y|&8BP4=4M",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[hc][hd][he][hf][id][gg][gh][ii][gi][hi][fg][eg][ih]AB[ha][hb][ib][fb][gc][gd][ge][gf][hh][hg][ig][ic]C[Capture the white stones at the right. Note that White has 2 liberties and Black only 1. By all logic White will capture first...] (;B[ie];W[if]) (;B[if] ;W[ie]C[And indeed she does.];B[hg];W[ig] ;B[if]TE[1]C[But black captures better. So cool.]))"
                    ],
                    "guid": "eePHi?M[Ud",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[19]AB[df][cn][dp][ko][lq][oq][oo][qp][qf][pd][dk][dr][eq][cd][ci][bd] [dg]AW[jc][fq][fo][ip][iq][qn][pm][qk][qh][oh][nc][er][fr][ed][dc][cc] [gd]CR[nc]C[Consider this theoretical situation. Corners and sides are taken, where do you think should Black play, and who do you think is winning?] (;B[pb]TE[1]C[A perfect choice! Black is slightly ahead in this game and you just took away the only target White could have attacked. This was a weak group for Black. <br><a class='puzzleNext' onclick='loadTsumego('14-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[pc]TE[1]C[A perfect choice! Black is slightly ahead in this game and you just took away the only target White could have attacked. This was a weak group for Black. <br><a class='puzzleNext' onclick='loadTsumego('14-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[oc]TE[1]C[A perfect choice! Black is slightly ahead in this game and you just took away the only target White could have attacked. This was a weak group for Black. <br><a class='puzzleNext' onclick='loadTsumego('14-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[qc]TE[1]C[A little too carefull perhaps, but still the right idea! Black was slightly ahead on the board and now White does not have a weak group to attack. This was a weak group for Black. <br><a class='puzzleNext' onclick='loadTsumego('14-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[fp] ;W[gp]C[This does not help Black in any way. White improved the security of that group and Black is left with a stone in atari. If Black protects, White will have sente. If Black lets that stone be captured, it will result in another even more severe atari.]) (;B[gp] ;W[fp]C[This is too crazy an attack for Black to try now. Black was winning and this attack does not seem to lead anywhere.]) (;B[lc] ;W[pc]MA[lc][pd][qf]C[This is an interesting idea, but not the best. Indeed the one white stone was not super strong, but now Black has two weak groups to take care of, while White only has one (the original stone). White will either live in the corner, or will get a decent attack on the pincering stone.];B[qc];W[qb] (;B[rb];W[pb] (;B[rd] ;W[od]TR[lc]C[White is fine, your corner is now small and the black stone will get attacked.]) (;B[qd] ;W[ne]C[White is fine, your corner is now small and the black stone will get attacked.])) (;B[pb]) (;B[oc];W[pb];B[ob] ;W[qd]C[White will live in the corner comfortably.])))"
                    ],
                    "guid": "m/rP>x:mT2",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[19]C[Biggest move for Black in this situation?]AB[pd][pf][qi][dp][nq][pr][kq][fq][cp][bo][co][fr][ep][gp][oc][db] [dc][cd][gc][cg][cf][qr][ql][ol][ob][pq]AW[cb][cc][ic][lc][nc][pp][qq][cn][cq][bp][bq][er][eq][dq][en][nd] [ie][qn][ck][bd][bb][ac][ci][rr][hb][rp][on] (;B[dd]TE[1]C[So simple, but so good. A solid connection preventing the disconnection into two groups. Perfect. <br><a class='puzzleNext' onclick='loadTsumego('14-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[de]LB[ed:A]TE[1]C[Good, preventing the disconnection into two groups. White will get a free peep at A, but it should not cause any major trouble. <br><a class='puzzleNext' onclick='loadTsumego('14-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[ed] ;W[ce]TE[1]C[A little bit weird, but still the correct idea. White gets some forcing moves out of it, maybe it would be better to stick to a simpler solution. <br><a class='puzzleNext' onclick='loadTsumego('14-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[ce] ;W[fe]C[Not that good. While will immediately get quite a strong attack on the group forcing Black to protect again without having too great eye potential. Black is unlikely to die outright, but White will profit from attacking.]) (;B[ee]TE[1]C[Fancy... Works too. <br><a class='puzzleNext' onclick='loadTsumego('14-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[nf] ;W[dd]C[Yes, it seems there is a lot of points to make, but not all Black's groups were safe. Now they are disconnected into two weak groups and they will suffer.]) (;B[ng] ;W[dd]C[Yes, it seems there is a lot of points to make, but not all Black's groups were safe. Now they are disconnected into two weak groups and they will suffer.]) (;B[mo] ;W[dd]C[Yes, it seems there is a lot of points to make, but not all Black's groups were safe. Now they are disconnected into two weak groups and they will suffer.]) (;B[no] ;W[dd]C[Yes, it seems there is a lot of points to make, but not all Black's groups were safe. Now they are disconnected into two weak groups and they will suffer.]) (;B[dn] (;W[dm] (;B[cm] ;W[do]C[Nah, you only lost points and potential and did not fix the original problem.]) (;B[dd]TE[1]C[Fair enough. Not sure what Black gained by the forcy move, but fine. <br><a class='puzzleNext' onclick='loadTsumego('14-3','pzl3',tsumego)'>Next puzzle</a>]) (;B[de]TE[1]C[Fair enough. Not sure what Black gained by the forcy move, but fine. <br><a class='puzzleNext' onclick='loadTsumego('14- 3','pzl3',tsumego)'>Next puzzle</a>]) (;B[ed]TE[1]C[Fair enough. Not sure what Black gained by the forcy move, but fine. <br><a class='puzzleNext' onclick='loadTsumego('14- 3','pzl3',tsumego)'>Next puzzle</a>])) (;W[de])))"
                    ],
                    "guid": "|kSB9EH`T",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]SZ[19]CA[UTF-8]AB[cc][dd][cf][dk][cn][cq][dp][ep][eq][fp][gp][ho][po][pn][qn][rm] [sn][qk][pk][ok][nj][pb][nc][kc][io][qj][ri][rj][qb]AW[cr][er][fq][gq][hp][ip][jp][nq][op][pp][qq][rp][ro][rn][qo][oj] [pj][qi][qf][pd][qc][ic][fc][db][dq][dr][ph][rh][sh][rc]C[Is there a weak group? Can you threaten something big? Where would you play?] (;B[hd] ;W[hc]C[Perfect! Great start. Pressure the weakest group to grow your own potential. Finish the sequence.] (;B[fd];W[gd];B[ge] ;W[gc]CR[do][eo][fo][go][gn][gm][gk][gj][gi][gh][gg][gf][gl][dn][en][fn] [fm][em][dm][cm][cl][dl][el][fl][fk][fj][ej][dj][cj][ck][dk][ek] [ci][ei][fh][fg][ff][ee][ef][eg][eh][fi][di][dh][ch][cg][dg][df] [de][fe][ce][be][bh][bk][bn][am][al][aj][ai][af][ae][ac][bc][bd] [ad][cd][bf][ag][ah][bi][bj][ak][bl][bm][an][bg]TE[1]C[Now Black is threatening a huge moyo. It would now be time for some protective moves, and then let White try and fight to reduce.]) (;B[gd];W[gc] ;B[fd]CR[ae][be][ce][de][ee][fe][ge][he][hf][hg][hh][hi][hj][hk][hl][hm] [hn][gn][go][fo][fn][fm][gm][gl][gk][gi][gh][gg][gf][ff][fg][fh] [fj][fk][fl][gj][fi][ef][ei][el][em][en][eo][do][dl][ek][ej][dm] [dn][bn][an][cm][bm][am][al][aj][ah][af][bf][bi][bk][bl][cl][ck] [ak][bj][dj][di][ci][cj][ai][ag][bh][dh][eg][dg][df][cd][ad][bg] [ch][eh][cg][bd]TE[1]C[Now Black is threatening a huge moyo. It would now be time for some protective moves, and then  let White try and fight to reduce.])) (;B[fd] ;W[gc]CR[ac][bc][bd][ad][cd][be][ce][de][ee][fe][ae][ff][ef][df][af][bf] [bn][an][dn][do][eo][fo][go][gn][fn][en][fm][fl][fk][fj][fi][fh] [fg][eg][eh][ek][el][dm][dl][em][ej][ei][di][dj][dh][dg][cg][ci] [ck][cl][cm][bm][bk][bh][bg][ch][cj][bj][bi][bl][am][ak][ag][ai] [aj][ah][al]TE[1]C[Probably not THE best move, but the idea is solid. Attack White's weakest group in a way that grows Black's big moyo. Let White try and find a way to reduce all that potential.]) (;B[dh] ;W[fe]C[This is way too passive. Black had a chance to threaten a really big moyo. Now white fixed her weakest group and reduced a lot of Black's potential at the same time. It will be hard for Black to get back into the game now.]) (;B[ch] ;W[fe]C[This is way too passive. Black had a chance to threaten a really big moyo. Now white fixed her weakest group and reduced a lot of Black's potential at the same time. It will be hard for Black to get back into the game now.]) (;B[di] ;W[fe]C[This is way too passive. Black had a chance to threaten a really big moyo. Now white fixed her weakest group and reduced a lot of Black's potential at the same time. It will be hard for Black to get back into the game now.]) (;B[cp] ;W[fe]C[Oh no, giving up sente for this one little stone is way too small now. You have to keep the whole 19x19 board in mind. White will now reduce most of Black's potential while fixing her own weaknesses. Black will struggle to catch up.]) (;B[bq] ;W[fe]C[Oh no, giving up sente for this one little stone is way too small now. You have to keep the whole 19x19 board in mind. White will now reduce most of Black's potential while fixing her own weaknesses. Black will struggle to catch up.]) (;B[gd];W[gc] (;B[fd];W[hd] ;B[he]TE[1]C[H16 would have been a better threat originally, but still the idea is solid. Pressure White's group to grow Black's moyo and then let White to worry about trying to reduce all that potential.]) (;B[hd];W[fd] ;B[fe]TE[1]C[H16 would have been a better threat originally, but still the idea is solid. Pressure White's group to grow Black's moyo and then let White to worry about trying to reduce all that potential.])) (;B[bp] ;W[fe]C[Oh no, giving up sente for this one little stone is way too small now. You have to keep the whole 19x19 board in mind. White will now reduce most of Black's potential while fixing her own weaknesses. Black will struggle to catch up.]) (;B[fe]C[Now Black is threatening a huge moyo. Let White try and fight to reduce.]CR[ac][bc][ad][cd][bd][ae][de][ee][ce][be][af][bf][df][ef][fh][fj] [fl][fn][fo][ff][fg][fi][fk][fm][eo][ei][eg][eh][ej][en][em][el] [ek][dg][dh][di][dj][dl][dm][dn][do][ag][cg][bg][ah][bh][ch][ci] [bi][ai][cj][ck][bj][aj][ak][bk][al][bl][cl][cm][bm][am][an][bn]TE[1]))"
                    ],
                    "guid": "PhzKal5c<m",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]SZ[9]CA[UTF-8]AB[ff][fg][fh][he][gf][ec][eb][fd][ed][hd]AW[ef][eh][db][dc][cd][de][cg][fe][eg][ee][dd][cf]LB[aa:1][ba:2][ca:3][ab:4][bb:5][cb:6][ac:7][bc:8][cc:9][ad:10] [bd:11][ae:12][be:13][ce:14][af:15][bf:16][fa:1][ga:2][ha:3] [ia:4][fb:5][gb:6][hb:7][ib:8][fc:9][id:13][ie:14][hf:15][if:16] [gg:17][hg:18][ig:19][gh:20][hh:21][ih:22][gi:23][hi:24][ii:25] [gc:10][hc:11][ic:12][ah:21][bh:22][ch:23][dh:24][ai:25][bi:26] [ci:27][di:28][df:17][ag:18][bg:19][dg:20][fe:A]C[A simple example to show you the idea. It is endgame, no captures or komi (for simplicity) and it does not really look all that good for black, does it? White just pushed with A. Could that be a bit of an endgame mistake?] (;B[da] ;W[ca]C[Yes, ignoring white's attack is absolutely essential.];B[ea] ;W[cb]C[White needs to protect here otherwise you can capture C9 so you get to keep sente!];B[ei];W[di];B[fi];W[dh] ;B[ge]TE[1]LB[aa:1][ba:2][ab:3][bb:4][ac:5][bc:6][cc:7][ad:8][bd:9][ae:10] [be:11][ce:12][af:13][bf:14][fa:1][ga:2][ha:3][ia:4][fb:5][gb:6] [hb:7][ib:8][fc:9][id:14][ie:15][hf:16][if:17][gg:18][hg:19] [ig:20][gh:21][hh:22][ih:23][gi:24][hi:25][ii:26][gc:10][hc:11] [ic:12][gd:13][ah:19][bh:20][ch:21][ai:22][bi:23][ci:24][df:15] [ag:16][bg:17][dg:18]C[And you even get to defend against the original attack. That's how powerful good use of sente can be. Black wins! <br><a class='puzzleNext' onclick='loadTsumego('1-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[ge] ;W[fi]C[It is a natural response, right? Opponent attacked so you defend. Let's see how it ends.];B[gi];W[ei] (;B[gh];W[ea];B[fa];W[da] (;B[fb]C[OOOOF. What a beatdown. You failed to get sente in time.]LB[aa:1][ba:2][ca:3][ab:4][bb:5][cb:6][ac:7][bc:8][cc:9][ad:10] [bd:11][ae:12][be:13][ce:14][af:15][bf:16][ga:1][ha:2][ia:3] [gb:4][hb:5][ib:6][fc:7][id:12][ie:13][hf:14][if:15][gg:16] [hg:17][ig:18][hh:19][ih:20][hi:21][ii:22][gc:8][hc:9][ic:10] [gd:11][ah:21][bh:22][ch:23][dh:24][ai:25][bi:26][ci:27][di:28] [df:17][ag:18][bg:19][dg:20]) (;B[gb]C[OOOOF. What a beatdown. You failed to get sente in time.]LB[aa:1][ba:2][ca:3][ab:4][bb:5][cb:6][ac:7][bc:8][cc:9][ad:10] [bd:11][ae:12][be:13][ce:14][af:15][bf:16][ga:1][ha:2][ia:3] [fb:4][hb:5][ib:6][fc:7][gc:8][hc:9][ic:10][gd:11][id:12][ie:13] [hf:14][if:15][gg:16][hg:17][ig:18][hh:19][ih:20][hi:21][ii:22] [ah:21][bh:22][ch:23][dh:24][ai:25][bi:26][ci:27][di:28][df:17] [ag:18][bg:19][dg:20])) (;B[hh];W[ea];B[fa];W[da] (;B[fb]C[OOOOF. What a beatdown. You failed to get sente in time.]LB[aa:1][ba:2][ca:3][ab:4][bb:5][cb:6][ac:7][bc:8][cc:9][ad:10] [bd:11][ae:12][be:13][ce:14][af:15][bf:16][ah:21][bh:22][ch:23] [dh:24][ai:25][bi:26][ci:27][di:28][ga:1][ha:2][ia:3][gb:4][hb:5] [ib:6][fc:7][gc:8][hc:9][ic:10][gd:11][id:12][ie:13][hf:14] [if:15][gg:16][hg:17][ig:18][gh:19][ih:20][hi:21][ii:22][df:17] [ag:18][bg:19][dg:20]) (;B[gb]C[OOOOF. What a beatdown. You failed to get sente in time.]LB[aa:1][ba:2][ca:3][ab:4][bb:5][cb:6][ac:7][bc:8][cc:9][ad:10] [bd:11][ae:12][be:13][ce:14][af:15][bf:16][ah:21][bh:22][ch:23] [dh:24][ai:25][bi:26][ci:27][di:28][ga:1][ha:2][ia:3][fb:4][hb:5] [ib:6][fc:7][gc:8][hc:9][ic:10][gd:11][id:12][ie:13][hf:14] [if:15][gg:16][hg:17][ig:18][gh:19][ih:20][hi:21][ii:22][df:17] [ag:18][bg:19][dg:20])) (;B[da];W[ca];B[ea];W[cb] (;B[hh]C[A good attempt but not good enough. You failed to get sente in time.]LB[aa:1][ba:2][ab:3][bb:4][ac:5][bc:6][cc:7][ad:8][bd:9][ae:10] [be:11][ce:12][af:13][bf:14][fa:1][ga:2][ha:3][ia:4][fb:5][gb:6] [hb:7][ib:8][fc:9][gc:10][hc:11][ic:12][gd:13][id:14][ie:15] [hf:16][if:17][gg:18][hg:19][ig:20][gh:21][ih:22][hi:23][ii:24] [ah:19][bh:20][ch:21][dh:22][ai:23][bi:24][ci:25][di:26][df:15] [ag:16][bg:17][dg:18]) (;B[gh]C[A good attempt but not good enough. You failed to get sente in time.]LB[aa:1][ba:2][ab:3][bb:4][ac:5][bc:6][cc:7][ad:8][bd:9][ae:10] [be:11][ce:12][af:13][bf:14][fa:1][ga:2][ha:3][ia:4][fb:5][gb:6] [hb:7][ib:8][fc:9][gc:10][hc:11][ic:12][gd:13][id:14][ie:15] [hf:16][if:17][gg:18][hg:19][ig:20][hh:21][ih:22][hi:23][ii:24] [ah:19][bh:20][ch:21][dh:22][ai:23][bi:24][ci:25][di:26][df:15] [ag:16][bg:17][dg:18]))) (;B[ei] ;W[di]C[Yes, ignoring white's attack is absoltely essential.];B[fi] ;W[dh]C[White needs to protect here otherwise you can capture C9 so you get to keep sente!];B[da];W[ca];B[ea];W[cb] ;B[ge]TE[1]LB[aa:1][ba:2][ab:3][bb:4][ac:5][bc:6][cc:7][ad:8][bd:9][ae:10] [be:11][ce:12][af:13][bf:14][fa:1][ga:2][ha:3][ia:4][fb:5][gb:6] [hb:7][ib:8][fc:9][id:14][ie:15][hf:16][if:17][gg:18][hg:19] [ig:20][gh:21][hh:22][ih:23][gi:24][hi:25][ii:26][gc:10][hc:11] [ic:12][gd:13][ah:19][bh:20][ch:21][ai:22][bi:23][ci:24][df:15] [ag:16][bg:17][dg:18]C[And you even get to defend against the original attack. That's how powerfull good use of sente can be. Black wins! <br><a class='puzzleNext' onclick='loadTsumego('15-2','pzl2',tsumego)'>Next puzzle</a>]) (;B[ea] ;W[da]C[Too weak. You need to push the borders harder.];B[fi];W[ei] ;B[ge]C[You did manage to get sente in time but failed to push hard enough on the borders. Try again.]LB[aa:1][ba:2][ca:3][ab:4][bb:5][cb:6][ac:7][bc:8][cc:9][ad:10] [bd:11][ae:12][be:13][ce:14][af:15][bf:16][fa:1][ga:2][ha:3] [ia:4][fb:5][gb:6][hb:7][ib:8][fc:9][id:14][ie:15][hf:16][if:17] [gg:18][hg:19][ig:20][gh:21][hh:22][ih:23][gi:24][hi:25][ii:26] [gc:10][hc:11][ic:12][gd:13][df:17][ag:18][bg:19][dg:20][ah:21] [bh:22][ch:23][dh:24][ai:25][bi:26][ci:27][di:28]) (;B[fi];W[ei];B[ea];W[da] ;B[ge]C[You did manage to get sente in time but failed to push hard enough on the borders. Try again.]LB[aa:1][ba:2][ca:3][ab:4][bb:5][cb:6][ac:7][bc:8][cc:9][ad:10] [bd:11][ae:12][be:13][ce:14][af:15][bf:16][fa:1][ga:2][ha:3] [ia:4][fb:5][gb:6][hb:7][ib:8][fc:9][id:14][ie:15][hf:16][if:17] [gg:18][hg:19][ig:20][gh:21][hh:22][ih:23][gi:24][hi:25][ii:26] [gc:10][hc:11][ic:12][gd:13][df:17][ag:18][bg:19][dg:20][ah:21] [bh:22][ch:23][dh:24][ai:25][bi:26][ci:27][di:28]))"
                    ],
                    "guid": "r=AcDX4W1b",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]SZ[9]CA[UTF-8]AB[hh][hg][hf][he][hd][hc][gc][fc][ec][dc][cc][bc][bd][be][bf][bg] [bh]AW[ch][cg][cf][gh][gg][gf][ce][cd][dd][ed][fd][gd][ge][df][ee]C[Great work. I have decided to show you some magic as a reward. Sometimes endgame can be very beautiful. Imagine a situation like this and play the best endgame you can. There is a wonderful trick. Think about moves you would not normally consider.] (;B[gi];W[fi] (;B[hi];W[bi] (;B[fh];W[ei];B[eh];W[di];B[dh] ;W[ci]LB[de:1][fe:2][ef:3][ff:4][dg:5][eg:6][fg:7][dh:8][eh:9][fh:10]C[No, the capture trick does not work here... You reduced white to 10 points but gave him extra captures. Not the best result!]) (;B[ah] ;W[ci]LB[de:1][fe:2][ef:3][ff:4][dg:5][eg:6][fg:7][dh:8][eh:9][fh:10] [di:11][ei:12])) (;B[ci];W[di] (;B[hi] ;W[bi]MA[ci]LB[de:1][fe:2][ef:3][ff:4][dg:5][eg:6][fg:7][dh:8][eh:9][fh:10] [ei:11]C[You only reduced white to 11 points. But I like that you try things out! That's the way to learn.]) (;B[bi] ;W[hi]LB[de:1][fe:2][ef:3][ff:4][dg:5][eg:6][fg:7][dh:8][eh:9][fh:10] [ei:11]MA[gi]C[You only reduced white to 11 points. But I like that you try things out! That's the way to learn.]))) (;B[ei] ;W[gi]C[This is a wonderfull move! It cannot be captured. Whichever way white tries to block you off, you can connect to the other side.]CR[ei] (;B[ci] ;W[dh]C[A peep at your connection.];B[di];W[eh] (;B[fi];W[fh] ;B[bi]LB[de:1][fe:2][ef:3][ff:4][dg:5][eg:6][fg:7];W[hi]C[A huge reduction, but white reduced two points from your side. You can still do a point better. Don't worry if you can't see these sequences in your games just yet. But it shows there is something to look out for in endgame as well. Don't just go blindly through the motions.]TE[2]) (;B[hi];W[fi] ;B[bi]LB[de:1][fe:2][ef:3][ff:4][dg:5][eg:6][fg:7][fh:8]TE[1]C[You reduced white to 8 points and kept the whole side. This is the best! Don't worry if you can't see these sequences in your games just yet. But it shows there is something to look out for in endgame as well. Don't just go blindly through the motions.])) (;B[di] ;W[ci]C[Not like that, black is cut off.])) (;B[ci];W[di];B[bi];W[hi];B[dh];W[ei];B[eh];W[fi];B[fh] ;W[gi]C[No, the capture trick does not work here... You reduced white to 10 points but gave him extra captures. Not the best result!]LB[de:1][fe:2][ef:3][ff:4][dg:5][eg:6][fg:7][dh:8][eh:9][fh:10]))"
                    ],
                    "guid": "HVa5H@@*}b",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[13]C[And some examples of 4 stones shapes is as far as I will go. There are much more though.]AB[jj][kj][kh][cd][cc][dc]LB[dd:A][ki:B][ih:D][ii:E][jh:C] (;B[dd]C[This is the only move that is even worse than an empty triangle. It is basically two empty triangles combined. We call it a dumpling. Because it gets eaten.]) (;B[ki]SQ[jj][kj][ki]C[Nah, not too good. You basically just created an extended empty triangle.Do not imagine shapes separately. They are usually mixed up and combined with other stones, but are still there.]) (;B[jh]C[A bamboo joint. This is a very strong shape for connections. These stones cannot possibly be separated. Not that good if you are trying to create an eye though.]) (;B[ih]C[A table shape. Very strong and robust shape. Good in fights.]) (;B[ii]C[Sometimes called J-shape. If there are stones around and you need to protect your cuts (and only then) it can be a very strong move.]))"
                    ],
                    "guid": "qCAvyk`br{",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[ee][eg][ge][fc][df][gd][cf]AW[ce][cg][dc][ec][fd][fb][bf]C[One of your stones is in atari (danger of immediate capture) find it and save it.];B[gc]TE[1])"
                    ],
                    "guid": "Gb=x]=Ma4.",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[fe][fc][gf][de][hg][be][he]AW[cc][gg][fg][dg][hh][hf][ih]C[One of your stones is in atari (danger of immediate capture) find it and save it.] (;B[if]TE[1]) (;B[ig];W[if]))"
                    ],
                    "guid": "vGN[Cf8{tU",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[aa][ab][ac][bc][cb][ca][ba][cc][ga][gb][gc][gd][ge][gf][hf][if] [af][bf][cf][df][dg][dh][di]AW[da][db][dc][cd][dd][bd][ad][ha][hb][hc][hd][he][ie][ib][ic][ag] [bg][cg][ch][ci][bi][ah][ai]LB[bb:A][ia:B][id:C][bh:D]C[Which of these is the only legal move for black? A, B, C, or D?];B[bh]TE[1])"
                    ],
                    "guid": "Lt:#_5DbBD",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[fi][fh][fg][ff][fe][ee][ed][ec][ea][eb][ei][dh]AB[da][dc][dd][de][ef][eg][eh][cf][db][di][df]C[Your D1 stone is in atari. Can you save it? Play C2 to let white capture, if you think not.]LB[ch:X] (;B[ci];W[ch] (;B[bh];W[bi]) (;B[bi];W[bh];B[ah];W[ai])) (;B[ch] ;W[ci]TE[1]C[Correct, the stone was impossible to save.]))"
                    ],
                    "guid": "zt4.*_>ui!",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]MA[gg]C[Can you kill White's group? Play X if you do not think so.]AB[ea][fb][fc][ec][bd][dc][cd][hb]AW[bb][cb][db][eb][ba][ab][fa] (;B[gg] ;W[da]C[Too bad. It was possible to kill the whole white group.]LB[aa:1][ca:2]) (;B[ga] ;W[da]C[Not good enough, white has 2 eyes now.]LB[aa:1][ca:2]) (;B[da] ;W[ca]C[This (perhaps strange looking move) is correct. Even though your stones get captured, you took the only spot White needed for a second eye. Finish the deal.] (;B[ga] ;W[ea]C[Nope.]) (;B[ea] ;W[da]LB[ea:A]TE[1]C[A is a false eye now and White has nowhere to get another one. The whole group will eventually die.]MA[ba][ca][da][db][cb][bb][ab][eb][fa])) (;B[ac] ;W[da]C[Not good enough, white has 2 eyes now.]LB[aa:1][ca:2]) (;B[bc] ;W[da]C[Not good enough, white has 2 eyes now.]LB[aa:1][ca:2]) (;B[cc] ;W[da]C[Not good enough, white has 2 eyes now.]LB[aa:1][ca:2]))"
                    ],
                    "guid": "vB]dBQ:8o/",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[ac][bc][cc][dc][ca][ea][fb][ec][gc]AB[ab][bb][cb][db][eb]MA[gg]C[Now try and save your group. Remember you need to have a plan for 2 eyes. 1 is not enough to survive. Play X if you think the stones can't be saved.] (;B[ba];W[da];B[fa];W[ea] ;B[da]LB[aa:1][ca:2]C[All is good!]TE[1]) (;B[da];W[ba] (;B[fa] ;W[ga]C[Not too good. A is a false eye now and black is completely surrounded. The whole group will die.]MA[da][db][cb][bb][ab][eb][fa]) (;B[aa] ;W[fa]C[White did not even need that last move and Black still has only one eye. The whole group will die.]MA[aa][ab][bb][cb][db][eb][da])) (;B[fa];W[ga]) (;B[gg] ;W[da]MA[ab][bb][cb][db][eb]C[Too bad. It was possible to save your group.]))"
                    ],
                    "guid": "nj8,lHcb3_",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[dd][cd][bc][cf][fc][gc][hd][id][hb][df][ef][eg]AB[dc][ed][fe][ge][he][dg][cg][fg][ff][eh][bg]C[Prevent White from separating ANY of your stones from the rest.] (;B[ec];W[ee] (;B[fd];W[dh] (;B[fh]C[Perfect. All your stones remain safely connected.]TE[1]) (;B[ch]MA[dh]C[Perfect. All your stones remain safely connected.]TE[1])) (;B[dh];W[fd]) (;B[fh];W[fd])) (;B[fd];W[ec]) (;B[dh];W[ec]) (;B[fh];W[ec]) (;B[ee];W[ec]))"
                    ],
                    "guid": "gjDY)_9{Y2",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AW[fd][fe][ce][gc][gb][ga][hd][id][ib]AB[ed][fc][gd][ge][gf][fb]C[Capture White's cutting stones.] (;B[ff];W[ee] (;B[de];W[ef];B[eg];W[df] (;B[cf] ;W[dd]C[Does not work like this.]) (;B[dg] ;W[cf]C[Does not work like this.])) (;B[ef];W[de])) (;B[ef];W[ee];B[de];W[dd] ;B[ff]C[Very nice a net!]TE[1]) (;B[ee];W[ff];B[fg];W[ef];B[df] ;W[eg]MA[eg][ef][ff][fe][fd]C[A ladder works if you set it up correctly!]TE[1]))"
                    ],
                    "guid": "b<Rgqa:W!Z",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]AP[Drago:4.23]CA[UTF-8]SZ[9]AB[eb][dc][dd][de][df][eg][ff][fe][gd][ea]AW[ef][ee][ed][ec][fb][gc][hc][hb][db][cb]MA[gg]C[Save your two stones. Play X if you think it is impossible.] (;B[fc];W[fd] ;B[fc]TE[1]C[Snapback! I guess it was more about capturing white than saving black, but at least you can see how often these two overlap.]) (;B[fd] ;W[fc]MA[ea][eb]) (;B[gg] ;W[fc]C[Nope, it was possible to save them.]))"
                    ],
                    "guid": "HgGZ_[z5Ja",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::Tutorial"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "fcc9cc4d-b836-11eb-b0e7-d45d6450590b",
            "deck_config_uuid": "52ca97d1-8f2f-11eb-8a99-d45d6450590b",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "_shinkaya4.jpg"
            ],
            "name": "2. Tactics",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]SZ[19]HA[0]KM[0]GN[Cho L&amp;D (abc)]AB[fb][gb][bc][cc][dc][ec][be]AW[ba][fa][ab][bb][cb][db]C[Elementary](;B[ea]WV[];W[da]C[Wrong.])(;B[da];W[eb];B[ea];W[ca];B[ea]C[Correct.])(;B[eb]WV[];W[da]C[Wrong.]))"
                    ],
                    "guid": "vKT^#}/HFh",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::examples"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "(;GM[1]FF[4]SZ[19]HA[0]KM[0]GN[Cho L&amp;D (abc)]AB[eb][fb][bc][cc][dc][be]AW[da][ab][bb][cb][db]C[Elementary](;B[ba]C[Correct.])(;B[ca]WV[];W[ba]C[Wrong.])(;B[aa]WV[];W[ba]C[Wrong.])(;B[ac]WV[];W[ba]C[Wrong.])(;B[ea]WV[];W[ba]C[Wrong.]))"
                    ],
                    "guid": "zaA<#AQ%,I",
                    "note_model_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
                    "tags": [
                        "Go::examples"
                    ]
                }
            ]
        }
    ],
    "crowdanki_uuid": "fcc84923-b836-11eb-a19b-d45d6450590b",
    "deck_config_uuid": "fcc84924-b836-11eb-8b81-d45d6450590b",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "autoplay": true,
            "crowdanki_uuid": "fcc84924-b836-11eb-8b81-d45d6450590b",
            "dyn": false,
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.0
            },
            "maxTaken": 60,
            "name": "6 cards per day",
            "new": {
                "bury": false,
                "delays": [
                    1.0,
                    10.0
                ],
                "initialFactor": 2500,
                "ints": [
                    1,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 6,
                "retirementActions": {
                    "delete": false,
                    "move": false,
                    "suspend": true,
                    "tag": true
                },
                "retiringInterval": 0,
                "separate": true,
                "weeklySchedule": [
                    true,
                    true,
                    true,
                    true,
                    true,
                    true,
                    true
                ]
            },
            "newMix": 0,
            "newPerDayMinimum": 0,
            "replayq": true,
            "rev": {
                "bury": false,
                "ease4": 1.3,
                "fuzz": 0.05,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "minSpace": 1,
                "perDay": 9999
            },
            "reviewOrder": 0,
            "timer": 0
        },
        {
            "__type__": "DeckConfig",
            "autoplay": true,
            "crowdanki_uuid": "52ca97d1-8f2f-11eb-8a99-d45d6450590b",
            "dyn": false,
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0
                ],
                "leechAction": 0,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.0
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": false,
                "delays": [
                    1.0,
                    10.0
                ],
                "initialFactor": 2500,
                "ints": [
                    1,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 9992,
                "separate": true,
                "weeklySchedule": [
                    true,
                    true,
                    true,
                    true,
                    true,
                    true,
                    true
                ]
            },
            "newMix": 0,
            "newPerDayMinimum": 0,
            "replayq": true,
            "rev": {
                "bury": false,
                "ease4": 1.3,
                "fuzz": 0.05,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "minSpace": 1,
                "perDay": 200
            },
            "reviewOrder": 0,
            "timer": 0
        }
    ],
    "desc": "",
    "dyn": 0,
    "extendNew": 10,
    "extendRev": 50,
    "media_files": [
        "_shinkaya4.jpg"
    ],
    "name": "go",
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "fcc91287-b836-11eb-8d14-d45d6450590b",
            "css": "::-webkit-scrollbar {\n    display: none;\n}\n\n.night_mode {background-color: black;} /*  a simple way to stop inverted colours on ankidroid*/\n\n.card {\ncolor:black!important;\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: -webkit-box;\n\t-webkit-box-align: stretch;\n\t-webkit-box-pack: center;\n\t-webkit-box-orient: vertical;\n\tfont-size:22px;\n    text-align: center; /* ALIGN TEXT */\n}\n\nbody {\nmargin: 0\n}\n\n\n.besogo-comment > input {\n    display: none;\n}\n\n.besogo-container {\n\tmargin:auto;\n    outline: none;\n    display: flex;\n    background: #d0fefe;\n}\n\n.besogo-container * {\n    box-sizing: border-box;\n\t\n}\n\n.besogo-container button {\n    height: 30px;\n    width: 30px;\n    padding: 0px;\n    background: #d8dcd6;\n}\n\n.besogo-container input {\n    font-size: 12pt;\n}\n\n.besogo-container input[type='button'] {\n    background: #d8dcd6;\n}\n\n.besogo-container input[type='text'] {\n    width: 30px;\n}\n\n.besogo-container svg { /* Prevent text selection within SVG */\n    -webkit-touch-callout: none; /* iOS Safari */\n    -webkit-user-select: none;   /* Chrome/Safari/Opera */\n    -moz-user-select: none;      /* Firefox */\n    -ms-user-select: none;       /* Internet Explorer/Edge */\n     user-select: none;\n}\n\n\n.besogo-panels {\n    flex-direction: column;\n    align-items: center;\n    padding: 0px 5px;\n}\n\n.besogo-panels > * {\n    margin: 3px 0px;\n}\n\n.besogo-control {\n    display: flex;\n    align-items: center;\n    flex-wrap: wrap;\n    justify-content: space-around;\n    width: 100%;\n\n    flex: 0 0 auto;\n}\n\n.besogo-names {\n    flex: 0 0 auto;\n    width: 100%;\n}\n\n.besogo-playerInfo {\n    display: flex;\n    font-family: Tahoma, Geneva, sans-serif;\n    white-space: pre-wrap;\n}\n\n.besogo-blackInfo {\n    flex: 50%;\n    color: white;\n    background: black;\n    text-align: right;\n    padding: 5px;\n}\n\n.besogo-whiteInfo {\n    flex: 50%;\n    color: black;\n    background: white;\n    text-align: left;\n    padding: 5px;\n}\n\n.besogo-blackCaps {\n    float: left;\n}\n\n.besogo-whiteCaps {\n    float: right;\n}\n\n.besogo-comment {\n    font-family: Georgia, serif;\n    font-size: 12pt;\n    white-space: pre-wrap;\n\n\n    overflow: auto;\n    flex: 1 1 60%;\n    width: 100%;\n}\n\n.besogo-comment input[type='button'] {\n    float: right;\n}\n\n.besogo-comment textarea {\n    height: 100%;\n    width: 100%;\n}\n\n.besogo-gameInfo {\n    padding: 5px;\n    border-collapse: collapse;\n}\n\n.besogo-gameInfo td, tr {\n    border: 1px solid black;\n    padding: 3px;\n}\n\n.besogo-tool {\n    display: flex;\n    align-items: center;\n    flex-wrap: wrap;\n    justify-content: space-around;\n    width: 100%;\n\n    flex: 0 0 auto;\n}\n\n.besogo-tree {\n    overflow: auto;\n    flex: 1 1 40%;\n    width: 100%;\n}\n\n.besogo-file {\n\tdisplay:none;\n    flex: 0 0 auto;\n}\n\n\n/* Kaya board theme */\n\n.besogo-svg-board {\n    fill: none;\n}\n.besogo-svg-backer {\n    fill: #fcbc5b;\n}\n.besogo-board {\n    background: url(\"_shinkaya4.jpg\");\n    background-size: cover;\n}\n\n.besogo-svg-lines {\n    stroke: #151515;\n    stroke-width: 2.5;\n    fill: none;\n}\n\n.besogo-svg-hoshi {\n    stroke: #151515;\n    stroke-width: 12;\n}\n\n.besogo-svg-blackStone {\n    fill: #252525;\n    stroke: #252525;\n    stroke-width: 4;\n}\n\n.besogo-svg-whiteStone {\n    fill: #f5f5f5;\n    stroke: #f5f5f5;\n    stroke-width: 4;\n}\n\n.besogo-svg-greyStone {\n    fill: #929591;\n    stroke: #929591;\n    stroke-width: 4;\n}\n",
            "flds": [
                {
                    "font": "MS Shell Dlg 2",
                    "media": [],
                    "meta": null,
                    "name": "SGF",
                    "ord": 0,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Go",
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [
                "Go::test"
            ],
            "tmpls": [
                {
                    "afmt": "\n<div class=\"besogo-editor\" maxwidth=1200 transwidth=700>{{SGF}}</div>\n\n<script>\n(function() {\n'use strict';\nvar besogo = window.besogo = window.besogo || {}; // Establish our namespace\nbesogo.VERSION = '0.0.2-alpha';\n\nbesogo.create = function(container, options) {\n    var editor, // Core editor object\n        resizer, // Auto-resizing function\n        boardDiv, // Board display container\n        panelsDiv, // Parent container of panel divs\n        makers = { // Map to panel creators\n            control: besogo.makeControlPanel,\n            names: besogo.makeNamesPanel,\n            comment: besogo.makeCommentPanel,\n            tool: besogo.makeToolPanel,\n            tree: besogo.makeTreePanel,\n            file: besogo.makeFilePanel\n        },\n        insideText = container.textContent || container.innerText || '',\n        i, panelName; // Scratch iteration variables\n\n    container.className += ' besogo-container'; // Marks this div as initialized\n\n    // Process options and set defaults\n    options = options || {}; // Makes option checking simpler\n    options.size = besogo.parseSize(options.size || 19);\n    options.coord = options.coord || 'none';\n    options.tool = options.tool || 'auto';\n    if (options.panels === '') {\n        options.panels = [];\n    }\n    options.panels = options.panels || 'control+names+comment+tool+tree+file';\n    if (typeof options.panels === 'string') {\n        options.panels = options.panels.split('+');\n    }\n    options.path = options.path || '';\n    if (options.shadows === undefined) {\n        options.shadows = 'auto';\n    } else if (options.shadows === 'off') {\n        options.shadows = false;\n    }\n\n    // Make the core editor object\n    editor = besogo.makeEditor(options.size.x, options.size.y);\n    editor.setTool(options.tool);\n    editor.setCoordStyle(options.coord);\n    if (options.realstones) { // Using realistic stones\n        editor.REAL_STONES = true;\n        editor.SHADOWS = options.shadows;\n    } else { // SVG stones\n        editor.SHADOWS = (options.shadows && options.shadows !== 'auto');\n    }\n\n    if (!options.nokeys) { // Add keypress handler unless nokeys option is truthy\n        addKeypressHandler(container, editor);\n    }\n\n    if (options.sgf) { // Load SGF file from URL\n        try {\n            fetchParseLoad(options.sgf, editor, options.path);\n        } catch(e) {\n            // Silently fail on network error\n        }\n    } else if (insideText.match(/\\s*\\(\\s*;/)) { // Text content looks like an SGF file\n        parseAndLoad(insideText, editor);\n        navigatePath(editor, options.path); // Navigate editor along path\n    }\n\n    if (typeof options.variants === 'number' || typeof options.variants === 'string') {\n        editor.setVariantStyle(+options.variants); // Converts to number\n    }\n\n    while (container.firstChild) { // Remove all children of container\n        container.removeChild(container.firstChild);\n    }\n\n    boardDiv = makeDiv('besogo-board'); // Create div for board display\n    besogo.makeBoardDisplay(boardDiv, editor); // Create board display\n\n    if (!options.nowheel) { // Add mousewheel handler unless nowheel option is truthy\n        addWheelHandler(boardDiv, editor);\n    }\n\n    if (options.panels.length > 0) { // Only create if there are panels to add\n        panelsDiv = makeDiv('besogo-panels');\n        for (i = 0; i < options.panels.length; i++) {\n            panelName = options.panels[i];\n            if (makers[panelName]) { // Only add if creator function exists\n                makers[panelName](makeDiv('besogo-' + panelName, panelsDiv), editor);\n            }\n        }\n        if (!panelsDiv.firstChild) { // If no panels were added\n            container.removeChild(panelsDiv); // Remove the panels div\n            panelsDiv = false; // Flags panels div as removed\n        }\n    }\n\n    options.resize = options.resize || 'auto';\n    if (options.resize === 'auto') { // Add auto-resizing unless resize option is truthy\n        resizer = function() {\n            var windowHeight = window.innerHeight, // Viewport height\n                // Calculated width of parent element\n                parentWidth = parseFloat(getComputedStyle(container).width),\n                maxWidth = +(options.maxwidth || -1),\n                orientation = options.orient || 'auto',\n\n                portraitRatio = +(options.portratio || 200) / 100,\n                landscapeRatio = +(options.landratio || 200) / 100,\n                minPanelsWidth = +(options.minpanelswidth || 350),\n                minPanelsHeight = +(options.minpanelsheight || 400),\n                minLandscapeWidth = +(options.transwidth || 600),\n\n                // Initial width parent\n                width = (maxWidth > 0 && maxWidth < parentWidth) ? maxWidth : parentWidth,\n                height; // Initial height is undefined\n\n            // Determine orientation if 'auto' or 'view'\n            if (orientation !== 'portrait' && orientation !== 'landscape') {\n                if (width < minLandscapeWidth || (orientation === 'view' && width < windowHeight)) {\n                    orientation = 'portrait';\n                } else {\n                    orientation = 'landscape';\n                }\n            }\n\n            if (orientation === 'portrait') { // Portrait mode\n                if (!isNaN(portraitRatio)) {\n                    height = portraitRatio * width;\n                    if (panelsDiv) {\n                        height = (height - width < minPanelsHeight) ? width + minPanelsHeight : height;\n                    }\n                } // Otherwise, leave height undefined\n            } else if (orientation === 'landscape') { // Landscape mode\n                if (!panelsDiv) { // No panels div\n                    height = width; // Square overall\n                } else if (isNaN(landscapeRatio)) {\n                    height = windowHeight;\n                } else { // Otherwise use ratio\n                    height = width / landscapeRatio;\n                }\n\n                if (panelsDiv) {\n                    // Reduce height to ensure minimum width of panels div\n                    height = (width < height + minPanelsWidth) ? (width - minPanelsWidth) : height;\n                }\n            }\n\n            setDimensions(width, height);\n            container.style.width = width + 'px';\n        };\n        window.addEventListener(\"resize\", resizer);\n        resizer(); // Initial div sizing\n    } else if (options.resize === 'fixed') {\n        setDimensions(container.clientWidth, container.clientHeight);\n    }\n\n    // Sets dimensions with optional height param\n    function setDimensions(width, height) {\n        if (height && width > height) { // Landscape mode\n            container.style['flex-direction'] = 'row';\n            boardDiv.style.height = height + 'px';\n            boardDiv.style.width = height + 'px';\n            if (panelsDiv) {\n                panelsDiv.style.height = height + 'px';\n                panelsDiv.style.width = (width - height) + 'px';\n            }\n        } else { // Portrait mode (implied if height is missing)\n            container.style['flex-direction'] = 'column';\n            boardDiv.style.height = width + 'px';\n            boardDiv.style.width = width + 'px';\n            if (panelsDiv) {\n                if (height) { // Only set height if param present\n                    panelsDiv.style.height = (height - width) + 'px';\n                }\n                panelsDiv.style.width = width + 'px';\n            }\n        }\n    }\n\n    // Creates and adds divs to specified parent or container\n    function makeDiv(className, parent) {\n        var div = document.createElement(\"div\");\n        if (className) {\n            div.className = className;\n        }\n        parent = parent || container;\n        parent.appendChild(div);\n        return div;\n    }\n}; // END function besogo.create\n\n// Parses size parameter from SGF format\nbesogo.parseSize = function(input) {\n    var matches,\n        sizeX,\n        sizeY;\n\n    input = (input + '').replace(/\\s/g, ''); // Convert to string and remove whitespace\n\n    matches = input.match(/^(\\d+):(\\d+)$/); // Check for #:# pattern\n    if (matches) { // Composed value pattern found\n        sizeX = +matches[1]; // Convert to numbers\n        sizeY = +matches[2];\n    } else if (input.match(/^\\d+$/)) { // Check for # pattern\n        sizeX = +input; // Convert to numbers\n        sizeY = +input; // Implied square\n    } else { // Invalid input format\n        sizeX = sizeY = 19; // Default size value\n    }\n    if (sizeX > 52 || sizeX < 1 || sizeY > 52 || sizeY < 1) {\n        sizeX = sizeY = 19; // Out of range, set to default\n    }\n\n    return { x: sizeX, y: sizeY };\n};\n\n// Automatically converts document elements into besogo instances\nbesogo.autoInit = function() {\n    var allDivs = document.getElementsByTagName('div'), // Live collection of divs\n        targetDivs = [], // List of divs to auto-initialize\n        options, // Structure to hold options\n        i, j, attrs; // Scratch iteration variables\n\n    for (i = 0; i < allDivs.length; i++) { // Iterate over all divs\n        if ( (hasClass(allDivs[i], 'besogo-editor') || // Has an auto-init class\n              hasClass(allDivs[i], 'besogo-viewer') ||\n              hasClass(allDivs[i], 'besogo-diagram')) &&\n             !hasClass(allDivs[i], 'besogo-container') ) { // Not already initialized\n                targetDivs.push(allDivs[i]);\n        }\n    }\n\n    for (i = 0; i < targetDivs.length; i++) { // Iterate over target divs\n        options = {}; // Clear the options struct\n        if (hasClass(targetDivs[i], 'besogo-editor')) {\n            options.panels = ['control', 'names', 'comment', 'tool', 'tree', 'file'];\n            options.tool = 'auto';\n        } else if (hasClass(targetDivs[i], 'besogo-viewer')) {\n            options.panels = ['control', 'names', 'comment'];\n            options.tool = 'navOnly';\n        } else if (hasClass(targetDivs[i], 'besogo-diagram')) {\n            options.panels = [];\n            options.tool = 'navOnly';\n        }\n\n        attrs = targetDivs[i].attributes;\n        for (j = 0; j < attrs.length; j++) { // Load attributes as options\n            options[attrs[j].name] = attrs[j].value;\n        }\n        besogo.create(targetDivs[i], options);\n    }\n\n    function hasClass(element, str) {\n        return (element.className.split(' ').indexOf(str) !== -1);\n    }\n};\n\n// Sets up keypress handling\nfunction addKeypressHandler(container, editor) {\n    if (!container.getAttribute('tabindex')) {\n        container.setAttribute('tabindex', '0'); // Set tabindex to allow div focusing\n    }\n\n    container.addEventListener('keydown', function(evt) {\n        evt = evt || window.event;\n        switch (evt.keyCode) {\n            case 33: // page up\n                editor.prevNode(10);\n                break;\n            case 34: // page down\n                editor.nextNode(10);\n                break;\n            case 35: // end\n                editor.nextNode(-1);\n                break;\n            case 36: // home\n                editor.prevNode(-1);\n                break;\n            case 37: // left\n                editor.prevNode(1);\n                break;\n            case 38: // up\n                editor.nextSibling(-1);\n                break;\n            case 39: // right\n                editor.nextNode(1);\n                break;\n            case 40: // down\n                editor.nextSibling(1);\n                break;\n            case 46: // delete\n                editor.cutCurrent();\n                break;\n        } // END switch (evt.keyCode)\n        if (evt.keyCode >= 33 && evt.keyCode <= 40) {\n            evt.preventDefault(); // Suppress page nav controls\n        }\n    }); // END func() and addEventListener\n} // END function addKeypressHandler\n\n// Sets up mousewheel handling\nfunction addWheelHandler(boardDiv, editor) {\n    boardDiv.addEventListener('wheel', function(evt) {\n        evt = evt || window.event;\n        if (evt.deltaY > 0) {\n            editor.nextNode(1);\n            evt.preventDefault();\n        } else if (evt.deltaY < 0) {\n            editor.prevNode(1);\n            evt.preventDefault();\n        }\n    });\n}\n\n// Parses SGF string and loads into editor\nfunction parseAndLoad(text, editor) {\n    var sgf;\n    try {\n        sgf = besogo.parseSgf(text);\n    } catch (error) {\n        return; // Silently fail on parse error\n    }\n    besogo.loadSgf(sgf, editor);\n}\n\n// Fetches text file at url from same domain\nfunction fetchParseLoad(url, editor, path) {\n    var http = new XMLHttpRequest();\n\n    http.onreadystatechange = function() {\n        if (http.readyState === 4 && http.status === 200) { // Successful fetch\n            parseAndLoad(http.responseText, editor);\n            navigatePath(editor, path);\n        }\n    };\n    http.overrideMimeType('text/plain'); // Prevents XML parsing and warnings\n    http.open(\"GET\", url, true); // Asynchronous load\n    http.send();\n}\n\nfunction navigatePath(editor, path) {\n    var subPaths,\n        i, j; // Scratch iteration variables\n\n    path = path.split(/[Nn]+/); // Split into parts that start in next mode\n    for (i = 0; i < path.length; i++) {\n        subPaths = path[i].split(/[Bb]+/); // Split on switches into branch mode\n        executeMoves(subPaths[0], false); // Next mode moves\n        for (j = 1; j < subPaths.length; j++) { // Intentionally starting at 1\n            executeMoves(subPaths[j], true); // Branch mode moves\n        }\n    }\n\n    function executeMoves(part, branch) {\n        var i;\n        part = part.split(/\\D+/); // Split on non-digits\n        for (i = 0; i < part.length; i++) {\n            if (part[i]) { // Skip empty strings\n                if (branch) { // Branch mode\n                    if (editor.getCurrent().children.length) {\n                        editor.nextNode(1);\n                        editor.nextSibling(part[i] - 1);\n                    }\n                } else { // Next mode\n                    editor.nextNode(+part[i]); // Converts to number\n                }\n            }\n        }\n    }\n}\n\n})(); // END closure\nbesogo.makeBoardDisplay = function(container, editor) {\n    'use strict';\n    var CELL_SIZE = 88, // Including line width\n        COORD_MARGIN = 75, // Margin for coordinate labels\n        EXTRA_MARGIN = 6, // Extra margin on the edge of board\n        BOARD_MARGIN, // Total board margin\n\n        // Board size parameters\n        sizeX = editor.getCurrent().getSize().x,\n        sizeY = editor.getCurrent().getSize().y,\n\n        svg, // Holds the overall board display SVG element\n        stoneGroup, // Group for stones\n        markupGroup, // Group for markup\n        hoverGroup, // Group for hover layer\n        markupLayer, // Array of markup layer elements\n        hoverLayer, // Array of hover layer elements\n\n        randIndex, // Random index for stone images\n\n        TOUCH_FLAG = false; // Flag for touch interfaces\n\n    initializeBoard(editor.getCoordStyle()); // Initialize SVG element and draw the board\n    container.appendChild(svg); // Add the SVG element to the document\n    editor.addListener(update); // Register listener to handle editor/game state updates\n    redrawAll(editor.getCurrent()); // Draw stones, markup and hover layer\n\n    // Set listener to detect touch interfaces\n    container.addEventListener('touchstart', setTouchFlag);\n\n    // Function for setting the flag for touch interfaces\n    function setTouchFlag () {\n        TOUCH_FLAG = true; // Set flag to prevent needless function calls\n        hoverLayer = []; // Drop hover layer references, kills events\n        svg.removeChild(hoverGroup); // Remove hover group from SVG\n        // Remove self when done\n        container.removeEventListener('touchstart', setTouchFlag);\n    }\n\n    // Initializes the SVG and draws the board\n    function initializeBoard(coord) {\n        drawBoard(coord); // Initialize the SVG element and draw the board\n\n        stoneGroup = besogo.svgEl(\"g\");\n        markupGroup = besogo.svgEl(\"g\");\n\n        svg.appendChild(stoneGroup); // Add placeholder group for stone layer\n        svg.appendChild(markupGroup); // Add placeholder group for markup layer\n\n        if (!TOUCH_FLAG) {\n            hoverGroup = besogo.svgEl(\"g\");\n            svg.appendChild(hoverGroup);\n        }\n\n        addEventTargets(); // Add mouse event listener layer\n\n        if (editor.REAL_STONES) { // Generate index for realistic stone images\n            randomizeIndex();\n        }\n    }\n\n    // Callback for board display redraws\n    function update(msg) {\n        var current = editor.getCurrent(),\n            currentSize = current.getSize(),\n            reinit = false, // Board redraw flag\n            oldSvg = svg;\n\n        // Check if board size has changed\n        if (currentSize.x !== sizeX || currentSize.y !== sizeY || msg.coord) {\n            sizeX = currentSize.x;\n            sizeY = currentSize.y;\n            initializeBoard(msg.coord || editor.getCoordStyle()); // Reinitialize board\n            container.replaceChild(svg, oldSvg);\n            reinit = true; // Flag board redrawn\n        }\n\n        // Redraw stones only if needed\n        if (reinit || msg.navChange || msg.stoneChange) {\n            redrawStones(current);\n            redrawMarkup(current);\n            redrawHover(current);\n        } else if (msg.markupChange) {\n            redrawMarkup(current);\n            redrawHover(current);\n        } else if (msg.tool || msg.label) {\n            redrawHover(current);\n        }\n    }\n\n    function redrawAll(current) {\n        redrawStones(current);\n        redrawMarkup(current);\n        redrawHover(current);\n    }\n\n    // Initializes the SVG element and draws the board\n    function drawBoard(coord) {\n        var boardWidth,\n            boardHeight,\n            string = \"\", // Path string for inner board lines\n            i; // Scratch iteration variable\n\n        BOARD_MARGIN = (coord === 'none' ? 0 : COORD_MARGIN) + EXTRA_MARGIN;\n        boardWidth = 2*BOARD_MARGIN + sizeX*CELL_SIZE;\n        boardHeight = 2*BOARD_MARGIN + sizeY*CELL_SIZE;\n\n        svg = besogo.svgEl(\"svg\", { // Initialize the SVG element\n            width: \"100%\",\n            height: \"100%\",\n            viewBox: \"0 0 \" + boardWidth + \" \" + boardHeight\n        });\n\n        svg.appendChild(besogo.svgEl(\"rect\", { // Fill background color\n            width: boardWidth,\n            height: boardHeight,\n            'class': 'besogo-svg-board'\n        }) );\n\n        svg.appendChild(besogo.svgEl(\"rect\", { // Draw outer square of board\n            width: CELL_SIZE*(sizeX - 1),\n            height: CELL_SIZE*(sizeY - 1),\n            x: svgPos(1),\n            y: svgPos(1),\n            'class': 'besogo-svg-lines'\n        }) );\n\n        for (i = 2; i <= (sizeY - 1); i++) { // Horizontal inner lines\n            string += \"M\" + svgPos(1) + \",\" + svgPos(i) + \"h\" + CELL_SIZE*(sizeX - 1);\n        }\n        for (i = 2; i <= (sizeX - 1); i++) { // Vertical inner lines\n            string += \"M\" + svgPos(i) + \",\" + svgPos(1) + \"v\" + CELL_SIZE*(sizeY - 1);\n        }\n        svg.appendChild( besogo.svgEl(\"path\", { // Draw inner lines of board\n            d: string,\n            'class': 'besogo-svg-lines'\n        }) );\n\n        drawHoshi(); // Draw the hoshi points\n        if (coord !== 'none') {\n            drawCoords(coord); // Draw the coordinate labels\n        }\n    }\n\n    // Draws coordinate labels on the board\n    function drawCoords(coord) {\n        var labels = besogo.coord[coord](sizeX, sizeY),\n            shift = COORD_MARGIN + 10,\n            i, x, y; // Scratch iteration variable\n\n        for (i = 1; i <= sizeX; i++) { // Draw column coordinate labels\n            x = svgPos(i);\n            drawCoordLabel(x, svgPos(1) - shift, labels.x[i]);\n            drawCoordLabel(x, svgPos(sizeY) + shift, labels.x[i]);\n        }\n\n        for (i = 1; i <= sizeY; i++) { // Draw row coordinate labels\n            y = svgPos(i);\n            drawCoordLabel(svgPos(1) - shift, y, labels.y[i]);\n            drawCoordLabel(svgPos(sizeX) + shift, y, labels.y[i]);\n        }\n\n        function drawCoordLabel(x, y, label) {\n            var element = besogo.svgEl(\"text\", {\n                x: x,\n                y: y,\n                dy: \".65ex\", // Seems to work for vertically centering these fonts\n                \"font-size\": 32,\n                \"text-anchor\": \"middle\", // Horizontal centering\n                \"font-family\": \"Helvetica, Arial, sans-serif\",\n                fill: 'black'\n            });\n            element.appendChild( document.createTextNode(label) );\n            svg.appendChild(element);\n        }\n    }\n\n    // Draws hoshi onto the board at procedurally generated locations\n    function drawHoshi() {\n        var cx, cy, // Center point calculation\n            pathStr = \"\"; // Path string for drawing star points\n\n        if (sizeX % 2 && sizeY % 2) { // Draw center hoshi if both dimensions are odd\n            cx = (sizeX - 1)/2 + 1; // Calculate the center of the board\n            cy = (sizeY - 1)/2 + 1;\n            drawStar(cx, cy);\n\n            if (sizeX >= 17 && sizeY >= 17) { // Draw side hoshi if at least 17x17 and odd\n                drawStar(4, cy);\n                drawStar(sizeX - 3, cy);\n                drawStar(cx, 4);\n                drawStar(cx, sizeY - 3);\n            }\n        }\n\n        if (sizeX >= 11 && sizeY >= 11) { // Corner hoshi at (4, 4) for larger sizes\n            drawStar(4, 4);\n            drawStar(4, sizeY - 3);\n            drawStar(sizeX - 3, 4);\n            drawStar(sizeX - 3, sizeY - 3);\n        } else if (sizeX >= 8 && sizeY >= 8) { // Corner hoshi at (3, 3) for medium sizes\n            drawStar(3, 3);\n            drawStar(3, sizeY - 2);\n            drawStar(sizeX - 2, 3);\n            drawStar(sizeX - 2, sizeY - 2);\n        } // No corner hoshi for smaller sizes\n\n        if (pathStr) { // Only need to add if hoshi drawn\n            svg.appendChild( besogo.svgEl('path', { // Drawing circles via path points\n                d: pathStr, // Hack to allow radius adjustment via stroke-width\n                'stroke-linecap': 'round', // Makes the points round\n                'class': 'besogo-svg-hoshi'\n            }) );\n        }\n\n        function drawStar(i, j) { // Extend path string to draw star point\n            pathStr += \"M\" + svgPos(i) + ',' + svgPos(j) + 'l0,0'; // Draws a point\n        }\n    }\n\n    // Remakes the randomized index for stone images\n    function randomizeIndex() {\n        var maxIndex = besogo.BLACK_STONES * besogo.WHITE_STONES,\n            i, j;\n\n        randIndex = [];\n        for (i = 1; i <= sizeX; i++) {\n            for (j = 1; j <= sizeY; j++) {\n                randIndex[fromXY(i, j)] = Math.floor(Math.random() * maxIndex);\n            }\n        }\n    }\n\n    // Adds a grid of squares to register mouse events\n    function addEventTargets() {\n        var element,\n            i, j;\n\n        for (i = 1; i <= sizeX; i++) {\n            for (j = 1; j <= sizeY; j++) {\n                element = besogo.svgEl(\"rect\", { // Make a transparent event target\n                    x: svgPos(i) - CELL_SIZE/2,\n                    y: svgPos(j) - CELL_SIZE/2,\n                    width: CELL_SIZE,\n                    height: CELL_SIZE,\n                    opacity: 0\n                });\n\n                // Add event listeners, using closures to decouple (i, j)\n                element.addEventListener(\"click\", handleClick(i, j));\n\n                if (!TOUCH_FLAG) { // Skip hover listeners for touch interfaces\n                    element.addEventListener(\"mouseover\", handleOver(i, j));\n                    element.addEventListener(\"mouseout\", handleOut(i, j));\n                }\n\n                svg.appendChild(element);\n            }\n        }\n    }\n\n    function handleClick(i, j) { // Returns function for click handling\n        return function(event) {\n            // Call click handler in editor\n            editor.click(i, j, event.ctrlKey, event.shiftKey);\n            if(!TOUCH_FLAG) {\n                (handleOver(i, j))(); // Ensures that any updated tool is visible\n            }\n        };\n    }\n    function handleOver(i, j) { // Returns function for mouse over\n        return function() {\n            var element = hoverLayer[ fromXY(i, j) ];\n            if (element) { // Make tool action visible on hover over\n                element.setAttribute('visibility', 'visible');\n            }\n        };\n    }\n    function handleOut(i, j) { // Returns function for mouse off\n        return function() {\n            var element = hoverLayer[ fromXY(i, j) ];\n            if (element) { // Make tool action invisible on hover off\n                element.setAttribute('visibility', 'hidden');\n            }\n        };\n    }\n\n    // Redraws the stones\n    function redrawStones(current) {\n        var group = besogo.svgEl(\"g\"), // New stone layer group\n            shadowGroup, // Group for shadow layer\n            i, j, x, y, color; // Scratch iteration variables\n\n        if (editor.SHADOWS) { // Add group for shawdows\n            shadowGroup = besogo.svgShadowGroup();\n            group.appendChild(shadowGroup);\n        }\n\n        for (i = 1; i <= sizeX; i++) {\n            for (j = 1; j <= sizeY; j++) {\n                color = current.getStone(i, j);\n                if (color) {\n                    x = svgPos(i);\n                    y = svgPos(j);\n\n                    if (editor.REAL_STONES) { // Realistic stone\n                        group.appendChild(besogo.realStone(x, y, color, randIndex[fromXY(i, j)]));\n                    } else { // SVG stone\n                        group.appendChild(besogo.svgStone(x, y, color));\n                    }\n\n                    if (editor.SHADOWS) { // Draw shadows\n                        shadowGroup.appendChild(besogo.svgShadow(x - 2, y - 4));\n                        shadowGroup.appendChild(besogo.svgShadow(x + 2, y + 4));\n                    }\n                }\n            }\n        }\n\n        svg.replaceChild(group, stoneGroup); // Replace the stone group\n        stoneGroup = group;\n    }\n\n    // Redraws the markup\n    function redrawMarkup(current) {\n        var element, i, j, x, y, // Scratch iteration variables\n            group = besogo.svgEl(\"g\"), // Group holding markup layer elements\n            lastMove = current.move,\n            variants = editor.getVariants(),\n            mark, // Scratch mark state {0, 1, 2, 3, 4, 5}\n            stone, // Scratch stone state {0, -1, 1}\n            color; // Scratch color string\n\n        markupLayer = []; // Clear the references to the old layer\n\n        for (i = 1; i <= sizeX; i++) {\n            for (j = 1; j <= sizeY; j++) {\n                mark = current.getMarkup(i, j);\n                if (mark) {\n                    x = svgPos(i);\n                    y = svgPos(j);\n                    stone = current.getStone(i, j);\n                    color = (stone === -1) ? \"white\" : \"black\"; // White on black\n                    if (lastMove && lastMove.x === i && lastMove.y === j) {\n                        // Mark last move blue or violet if also a variant\n                        color = checkVariants(variants, current, i, j) ?\n                            besogo.PURP : besogo.BLUE;\n                    } else if (checkVariants(variants, current, i, j)) {\n                        color = besogo.RED; // Natural variant marks are red\n                    }\n                    if (typeof mark === 'number') { // Markup is a basic shape\n                        switch(mark) {\n                            case 1:\n                                element = besogo.svgCircle(x, y, color);\n                                break;\n                            case 2:\n                                element = besogo.svgSquare(x, y, color);\n                                break;\n                            case 3:\n                                element = besogo.svgTriangle(x, y, color);\n                                break;\n                            case 4:\n                                element = besogo.svgCross(x, y, color);\n                                break;\n                            case 5:\n                                element = besogo.svgBlock(x, y, color);\n                                break;\n                        }\n                    } else { // Markup is a label\n                        if (!stone) { // If placing label on empty spot\n                            element = makeBacker(x, y);\n                            group.appendChild(element);\n                        }\n                        element = besogo.svgLabel(x, y, color, mark);\n                    }\n                    group.appendChild(element);\n                    markupLayer[ fromXY(i, j) ] = element;\n                } // END if (mark)\n            } // END for j\n        } // END for i\n\n        // Mark last move with plus if not already marked\n        if (lastMove && lastMove.x !== 0 && lastMove.y !== 0) {\n            i = lastMove.x;\n            j = lastMove.y;\n            if (!markupLayer[ fromXY(i, j) ]) { // Last move not marked\n                color = checkVariants(variants, current, i, j) ? besogo.PURP : besogo.BLUE;\n                element = besogo.svgPlus(svgPos(i), svgPos(j), color);\n                group.appendChild(element);\n                markupLayer[ fromXY(i, j) ] = element;\n            }\n        }\n\n        // Mark variants that have not already been marked above\n        markRemainingVariants(variants, current, group);\n\n        svg.replaceChild(group, markupGroup); // Replace the markup group\n        markupGroup = group;\n    } // END function redrawMarkup\n\n    function makeBacker(x, y) { // Makes a label markup backer at (x, y)\n        return besogo.svgEl(\"rect\", {\n            x: x - CELL_SIZE/2,\n            y: y - CELL_SIZE/2,\n            height: CELL_SIZE,\n            width: CELL_SIZE,\n            opacity: 0.85,\n            stroke: \"none\",\n            'class': 'besogo-svg-board'\n        });\n    }\n\n    // Checks if (x, y) is in variants\n    function checkVariants(variants, current, x, y) {\n        var i, move;\n        for (i = 0; i < variants.length; i++) {\n            if (variants[i] !== current) { // Skip current (within siblings)\n                move = variants[i].move;\n                if (move && move.x === x && move.y === y) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    // Marks variants that have not already been marked\n    function markRemainingVariants(variants, current, group) {\n        var element,\n            move, // Variant move\n            label, // Variant label\n            stone, // Stone state\n            i, x, y; // Scratch iteration variables\n\n        for (i = 0; i < variants.length; i++) {\n            if (variants[i] !== current) { // Skip current (within siblings)\n                move = variants[i].move;\n                // Check if move, not a pass, and no mark yet\n                if (move && move.x !== 0 && !markupLayer[ fromXY(move.x, move.y) ]) {\n                    stone = current.getStone(move.x, move.y);\n                    x = svgPos(move.x); // Get SVG positions\n                    y = svgPos(move.y);\n                    if (!stone) { // If placing label on empty spot\n                        element = makeBacker(x, y);\n                        group.appendChild(element);\n                    }\n                    // Label variants with letters A-Z cyclically\n                    label = String.fromCharCode('A'.charCodeAt(0) + (i % 26));\n                    element = besogo.svgLabel(x, y, besogo.LRED, label);\n                    group.appendChild(element);\n                    markupLayer[ fromXY(move.x, move.y) ] = element;\n                }\n            }\n        }\n    } // END function markRemainingVariants\n\n    // Redraws the hover layer\n    function redrawHover(current) {\n        if (TOUCH_FLAG) {\n            return; // Do nothing for touch interfaces\n        }\n\n        var element, i, j, x, y, // Scratch iteration variables\n            group = besogo.svgEl(\"g\"), // Group holding hover layer elements\n            tool = editor.getTool(),\n            children,\n            stone, // Scratch stone state {0, -1, 1} or move\n            color; // Scratch color string\n\n        hoverLayer = []; // Clear the references to the old layer\n        group.setAttribute('opacity', '0.35');\n\n        if (tool === 'navOnly') { // Render navOnly hover by iterating over children\n            children = current.children;\n            for (i = 0; i < children.length; i++) {\n                stone = children[i].move;\n                if (stone && stone.x !== 0) { // Child node is move and not a pass\n                    x = svgPos(stone.x);\n                    y = svgPos(stone.y);\n                    element = besogo.svgStone(x, y, stone.color);\n                    element.setAttribute('visibility', 'hidden');\n                    group.appendChild(element);\n                    hoverLayer[ fromXY(stone.x, stone.y) ] = element;\n                }\n            }\n        } else { // Render hover for other tools by iterating over grid\n            for (i = 1; i <= sizeX; i++) {\n                for (j = 1; j <= sizeY; j++) {\n                    element = null;\n                    x = svgPos(i);\n                    y = svgPos(j);\n                    stone = current.getStone(i, j);\n                    color = (stone === -1) ? \"white\" : \"black\"; // White on black\n                    switch(tool) {\n                        case 'auto':\n                            element = besogo.svgStone(x, y, current.nextToMove);\n                            break;\n                        case 'playB':\n                            element = besogo.svgStone(x, y, -1);\n                            break;\n                        case 'playW':\n                            element = besogo.svgStone(x, y, 1);\n                            break;\n                        case 'addB':\n                            if (stone === -1) {\n                                element = besogo.svgCross(x, y, besogo.RED);\n                            } else {\n                                element = besogo.svgEl('g');\n                                element.appendChild(besogo.svgStone(x, y, -1));\n                                element.appendChild(besogo.svgPlus(x, y, besogo.RED));\n                            }\n                            break;\n                        case 'addW':\n                            if (stone === 1) {\n                                element = besogo.svgCross(x, y, besogo.RED);\n                            } else {\n                                element = besogo.svgEl('g');\n                                element.appendChild(besogo.svgStone(x, y, 1));\n                                element.appendChild(besogo.svgPlus(x, y, besogo.RED));\n                            }\n                            break;\n                        case 'addE':\n                            if (stone) {\n                                element = besogo.svgCross(x, y, besogo.RED);\n                            }\n                            break;\n                        case 'clrMark':\n                            break; // Nothing\n                        case 'circle':\n                            element = besogo.svgCircle(x, y, color);\n                            break;\n                        case 'square':\n                            element = besogo.svgSquare(x, y, color);\n                            break;\n                        case 'triangle':\n                            element = besogo.svgTriangle(x, y, color);\n                            break;\n                        case 'cross':\n                            element = besogo.svgCross(x, y, color);\n                            break;\n                        case 'block':\n                            element = besogo.svgBlock(x, y, color);\n                            break;\n                        case 'label':\n                            element = besogo.svgLabel(x, y, color, editor.getLabel());\n                            break;\n                    } // END switch (tool)\n                    if (element) {\n                        element.setAttribute('visibility', 'hidden');\n                        group.appendChild(element);\n                        hoverLayer[ fromXY(i, j) ] = element;\n                    }\n                } // END for j\n            } // END for i\n        } // END else\n\n        svg.replaceChild(group, hoverGroup); // Replace the hover layer group\n        hoverGroup = group;\n    } // END function redrawHover\n\n    function svgPos(x) {  // Converts (x, y) coordinates to SVG position\n        return BOARD_MARGIN + CELL_SIZE/2 + (x-1) * CELL_SIZE;\n    }\n\n    function fromXY(x, y) { // Converts (x, y) coordinates to linear index\n        return (x - 1)*sizeY + (y - 1);\n    }\n};\nbesogo.makeCommentPanel = function(container, editor) {\n    'use strict';\n    var infoTexts = {}, // Holds text nodes for game info properties\n        gameInfoTable = document.createElement('table'),\n        gameInfoEdit = document.createElement('table'),\n        commentBox = document.createElement('div'),\n        commentEdit = document.createElement('textarea'),\n        playerInfoOrder = 'PW WR WT PB BR BT'.split(' '),\n        infoOrder = 'HA KM RU TM OT GN EV PC RO DT RE ON GC AN US SO CP'.split(' '),\n        infoIds = {\n            PW: 'White Player',\n            WR: 'White Rank',\n            WT: 'White Team',\n            PB: 'Black Player',\n            BR: 'Black Rank',\n            BT: 'Black Team',\n\n            HA: 'Handicap',\n            KM: 'Komi',\n            RU: 'Rules',\n            TM: 'Timing',\n            OT: 'Overtime',\n\n            GN: 'Game Name',\n            EV: 'Event',\n            PC: 'Place',\n            RO: 'Round',\n            DT: 'Date',\n\n            RE: 'Result',\n            ON: 'Opening',\n            GC: 'Comments',\n\n            AN: 'Annotator',\n            US: 'Recorder',\n            SO: 'Source',\n            CP: 'Copyright'\n        };\n\n    container.appendChild(makeInfoButton());\n    container.appendChild(makeInfoEditButton());\n    container.appendChild(makeCommentButton());\n    container.appendChild(gameInfoTable);\n    container.appendChild(gameInfoEdit);\n    infoTexts.C = document.createTextNode('');\n    container.appendChild(commentBox);\n    commentBox.appendChild(infoTexts.C);\n    container.appendChild(commentEdit);\n\n    commentEdit.onblur = function() {\n        editor.setComment(commentEdit.value);\n    };\n    commentEdit.addEventListener('keydown', function(evt) {\n        evt = evt || window.event;\n        evt.stopPropagation(); // Stop keydown propagation when in focus\n    });\n\n    editor.addListener(update);\n    update({ navChange: true, gameInfo: editor.getGameInfo() });\n    gameInfoEdit.style.display = 'none'; // Hide game info editting table initially\n\n    function update(msg) {\n        var temp; // Scratch for strings\n\n        if (msg.navChange) {\n            temp = editor.getCurrent().comment || '';\n            updateText(commentBox, temp, 'C');\n            if (editor.getCurrent() === editor.getRoot() &&\n                gameInfoTable.firstChild &&\n                gameInfoEdit.style.display === 'none') {\n                    gameInfoTable.style.display = 'table';\n            } else {\n                gameInfoTable.style.display = 'none';\n            }\n            commentEdit.style.display = 'none';\n            commentBox.style.display = 'block';\n        } else if (msg.comment !== undefined) {\n            updateText(commentBox, msg.comment, 'C');\n            commentEdit.value = msg.comment;\n        }\n\n        if (msg.gameInfo) { // Update game info\n            updateGameInfoTable(msg.gameInfo);\n            updateGameInfoEdit(msg.gameInfo);\n        }\n    } // END function update\n\n    function updateGameInfoTable(gameInfo) {\n        var table = document.createElement('table'),\n            i, id, row, cell, text; // Scratch iteration variable\n\n        table.className = 'besogo-gameInfo';\n        for (i = 0; i < infoOrder.length ; i++) { // Iterate in specified order\n            id = infoOrder[i];\n\n            if (gameInfo[id]) { // Only add row if property exists\n                row = document.createElement('tr');\n                table.appendChild(row);\n\n                cell = document.createElement('td');\n                cell.appendChild(document.createTextNode(infoIds[id]));\n                row.appendChild(cell);\n\n                cell = document.createElement('td');\n                text = document.createTextNode(gameInfo[id]);\n                cell.appendChild(text);\n                row.appendChild(cell);\n            }\n        }\n        if (!table.firstChild || gameInfoTable.style.display === 'none') {\n            table.style.display = 'none'; // Do not display empty table or if already hidden\n        }\n        container.replaceChild(table, gameInfoTable);\n        gameInfoTable = table;\n    }\n    \n    function updateGameInfoEdit(gameInfo) {\n        var table = document.createElement('table'),\n            infoTableOrder = playerInfoOrder.concat(infoOrder),\n            i, id, row, cell, text;\n\n        table.className = 'besogo-gameInfo';\n        for (i = 0; i < infoTableOrder.length ; i++) { // Iterate in specified order\n            id = infoTableOrder[i];\n            row = document.createElement('tr');\n            table.appendChild(row);\n            \n            cell = document.createElement('td');\n            cell.appendChild(document.createTextNode(infoIds[id]));\n            row.appendChild(cell);\n\n            cell = document.createElement('td');\n            text = document.createElement('input');\n            if (gameInfo[id]) {\n                text.value = gameInfo[id];\n            }\n            text.onblur = function(t, id) {\n                return function() { // Commit change on blur\n                    editor.setGameInfo(t.value, id);\n                };\n            }(text, id);\n            text.addEventListener('keydown', function(evt) {\n                evt = evt || window.event;\n                evt.stopPropagation(); // Stop keydown propagation when in focus\n            });\n            cell.appendChild(text);\n            row.appendChild(cell);\n        }\n        if (gameInfoEdit.style.display === 'none') {\n            table.style.display = 'none'; // Hide if already hidden\n        }\n        container.replaceChild(table, gameInfoEdit);\n        gameInfoEdit = table;\n    }\n\n    function updateText(parent, text, id) {\n        var textNode = document.createTextNode(text);\n        parent.replaceChild(textNode, infoTexts[id]);\n        infoTexts[id] = textNode;\n    }\n\n    function makeInfoButton() {\n        var button = document.createElement('input');\n        button.type = 'button';\n        button.value = 'Info';\n        button.title = 'Show/hide game info';\n\n        button.onclick = function() {\n            if (gameInfoTable.style.display === 'none' && gameInfoTable.firstChild) {\n                gameInfoTable.style.display = 'table';\n            } else {\n                gameInfoTable.style.display = 'none';\n            }\n            gameInfoEdit.style.display = 'none';\n        };\n        return button;\n    }\n\n    function makeInfoEditButton() {\n        var button = document.createElement('input');\n        button.type = 'button';\n        button.value = 'Edit Info';\n        button.title = 'Edit game info';\n\n        button.onclick = function() {\n            if (gameInfoEdit.style.display === 'none') {\n                gameInfoEdit.style.display = 'table';\n            } else {\n                gameInfoEdit.style.display = 'none';\n            }\n            gameInfoTable.style.display = 'none';\n        };\n        return button;\n    }\n\n    function makeCommentButton() {\n        var button = document.createElement('input');\n        button.type = 'button';\n        button.value = 'Comment';\n        button.title = 'Edit comment';\n\n        button.onclick = function() {\n            if (commentEdit.style.display === 'none') { // Comment edit box hidden\n                commentBox.style.display = 'none'; // Hide static comment display\n                gameInfoTable.style.display = 'none'; // Hide game info table\n                commentEdit.value = editor.getCurrent().comment;\n                commentEdit.style.display = 'block'; // Show comment edit box\n            } else { // Comment edit box open\n                commentEdit.style.display = 'none'; // Hide comment edit box\n                commentBox.style.display = 'block'; // Show static comment display\n            }\n        };\n        return button;\n    }\n\n};\nbesogo.makeControlPanel = function(container, editor) {\n    'use strict';\n    var leftElements = [], // SVG elements for previous node buttons\n        rightElements = [], // SVG elements for next node buttons\n        siblingElements = [], // SVG elements for sibling buttons\n        variantStyleButton, // Button for changing variant style\n        hideVariantButton, // Button for toggling show/hide variants\n        childVariantElement, // SVG element for child style variants\n        siblingVariantElement, // SVG element for sibling style variants\n        hideVariantElement; // SVG element for hiding variants\n\n    drawNavButtons();\n    drawStyleButtons();\n\n    editor.addListener(update);\n    update({ navChange: true, variantStyle: editor.getVariantStyle() }); // Initialize\n\n    // Callback for variant style and nav state changes\n    function update(msg) {\n        var current;\n\n        if (msg.variantStyle !== undefined) {\n            updateStyleButtons(msg.variantStyle);\n        }\n\n        if (msg.navChange || msg.treeChange) { // Update the navigation buttons\n            current = editor.getCurrent();\n            if (current.parent) { // Has parent\n                arraySetColor(leftElements, 'black');\n                if (current.parent.children.length > 1) { // Has siblings\n                    arraySetColor(siblingElements, 'black');\n                } else { // No siblings\n                    arraySetColor(siblingElements, besogo.GREY);\n                }\n            } else { // No parent\n                arraySetColor(leftElements, besogo.GREY);\n                arraySetColor(siblingElements, besogo.GREY);\n            }\n            if (current.children.length) { // Has children\n                arraySetColor(rightElements, 'black');\n            } else { // No children\n                arraySetColor(rightElements, besogo.GREY);\n            }\n        }\n\n        function updateStyleButtons(style) { // Updates the variant style buttons\n            if (style % 2) { // Sibling style variants\n                childVariantElement.setAttribute('fill', 'black');\n                siblingVariantElement.setAttribute('fill', besogo.BLUE);\n                variantStyleButton.title = 'Variants: child/[sibling]';\n            } else { // Child style variants\n                childVariantElement.setAttribute('fill', besogo.BLUE);\n                siblingVariantElement.setAttribute('fill', besogo.RED);\n                variantStyleButton.title = 'Variants: [child]/sibling';\n            }\n            if (style >= 2) { // Hide auto-markup for variants\n                hideVariantElement.setAttribute('visibility', 'visible');\n                hideVariantButton.title = 'Variants: show/[hide]';\n            } else { // Show auto-markup for variants\n                hideVariantElement.setAttribute('visibility', 'hidden');\n                hideVariantButton.title = 'Variants: [show]/hide';\n            }\n        }\n\n        function arraySetColor(list, color) { // Changes fill color of list of svg elements\n            var i;\n            for (i = 0; i < list.length; i++) {\n                list[i].setAttribute('fill', color);\n            }\n        }\n    } // END function update\n\n    // Draws the navigation buttons\n    function drawNavButtons() {\n        leftElements.push(makeNavButton('First node',\n            '5,10 5,90 25,90 25,50 95,90 95,10 25,50 25,10',\n            function() {\n                editor.prevNode(-1);\n            })\n        );\n        leftElements.push(makeNavButton('Jump back',\n            '95,10 50,50 50,10 5,50 50,90 50,50 95,90',\n            function() {\n                editor.prevNode(10);\n            })\n        );\n        leftElements.push(makeNavButton('Previous node', '85,10 85,90 15,50', function() {\n            editor.prevNode(1);\n        }));\n\n        rightElements.push(makeNavButton('Next node', '15,10 15,90 85,50', function() {\n            editor.nextNode(1);\n        }));\n        rightElements.push(makeNavButton('Jump forward',\n            '5,10 50,50 50,10 95,50 50,90 50,50 5,90',\n            function() {\n                editor.nextNode(10);\n            })\n        );\n        rightElements.push(makeNavButton('Last node',\n            '95,10 95,90 75,90 75,50 5,90 5,10 75,50 75,10',\n            function() {\n                editor.nextNode(-1);\n            })\n        );\n\n        siblingElements.push(makeNavButton('Previous sibling', '10,85 90,85 50,15', function() {\n            editor.nextSibling(-1);\n        }));\n        siblingElements.push(makeNavButton('Next sibling', '10,15 90,15 50,85', function() {\n            editor.nextSibling(1);\n        }));\n\n        function makeNavButton(tooltip, pointString, action) { // Creates a navigation button\n            var button = document.createElement('button'),\n                svg = makeButtonContainer(),\n                element = besogo.svgEl(\"polygon\", {\n                    points: pointString,\n                    stroke: 'none',\n                    fill: 'black'\n                });\n\n            button.title = tooltip;\n            button.onclick = action;\n            button.appendChild(svg);\n            svg.appendChild(element);\n            container.appendChild(button);\n\n            return element;\n        } // END function makeNavButton\n    } // END function drawNavButtons\n\n    // Draws the variant style buttons\n    function drawStyleButtons() {\n        var svg, element, coordStyleButton;\n\n        variantStyleButton = document.createElement('button');\n        variantStyleButton.onclick = function() {\n            editor.toggleVariantStyle(false); // Toggles child/sibling variants\n        };\n        container.appendChild(variantStyleButton);\n        svg = makeButtonContainer();\n        variantStyleButton.appendChild(svg);\n        element = besogo.svgEl(\"path\", {\n            d: 'm75,25h-50l50,50',\n            stroke: 'black',\n            \"stroke-width\": 5,\n            fill: 'none'\n        });\n        svg.appendChild(element);\n        childVariantElement = besogo.svgEl('circle', {\n            cx: 25,\n            cy: 25,\n            r: 20,\n            stroke: 'none'\n        });\n        svg.appendChild(childVariantElement);\n        siblingVariantElement = besogo.svgEl('circle', {\n            cx: 75,\n            cy: 25,\n            r: 20,\n            stroke: 'none'});\n        svg.appendChild(siblingVariantElement);\n        element = besogo.svgEl('circle', {\n            cx: 75,\n            cy: 75,\n            r: 20,\n            fill: besogo.RED,\n            stroke: 'none'\n        });\n        svg.appendChild(element);\n\n        hideVariantButton = document.createElement('button');\n        hideVariantButton.onclick = function() {\n            editor.toggleVariantStyle(true); // Toggles show/hide variants\n        };\n        container.appendChild(hideVariantButton);\n        svg = makeButtonContainer();\n        hideVariantButton.appendChild(svg);\n        svg.appendChild(besogo.svgLabel(50, 50, besogo.RED, 'A'));\n        hideVariantElement = besogo.svgCross(50, 50, 'black');\n        svg.appendChild(hideVariantElement);\n\n        coordStyleButton = document.createElement('button');\n        coordStyleButton.onclick = function() {\n            editor.toggleCoordStyle(); // Toggles coordinate style\n        };\n        coordStyleButton.title = 'Toggle coordinates';\n        container.appendChild(coordStyleButton);\n        svg = makeButtonContainer();\n        coordStyleButton.appendChild(svg);\n        svg.appendChild(besogo.svgLabel(50, 50, 'black', '四4'));\n    } // END function drawStyleButtons\n\n    // Makes an SVG container for the button graphics\n    function makeButtonContainer() {\n        return besogo.svgEl('svg', {\n            width: '100%',\n            height: '100%',\n            viewBox: \"0 0 100 100\"\n        });\n    }\n};\n(function() {\n'use strict';\n\n// Parent object to hold coordinate system helper functions\nbesogo.coord = {};\n\n// Null function for no coordinate system\nbesogo.coord.none = function(sizeX, sizeY) {\n    return false;\n};\n\n// Western, chess-like, \"A1\" coordinate system\nbesogo.coord.western = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        labels.x[i] = numberToLetter(i);\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = (sizeY - i + 1) + '';\n    }\n    return labels;\n};\n\n// Simple purely numeric coordinate system\nbesogo.coord.numeric = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        labels.x[i] = i + '';\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = i + '';\n    }\n    return labels;\n};\n\n// Corner-relative, alpha-numeric, coordinate system\nbesogo.coord.corner = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        if (i < (sizeX / 2) + 1) {\n            labels.x[i] = numberToLetter(i);\n        } else {\n            labels.x[i] = (sizeX - i + 1) + '';\n        }\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = (sizeY - i + 1) + '';\n        if (i > (sizeY / 2)) {\n            labels.y[i] = numberToLetter(sizeY - i + 1);\n        } else {\n            labels.y[i] = i + '';\n        }\n    }\n    return labels;\n};\n\n// Corner-relative, numeric and CJK, coordinate system\nbesogo.coord.eastcor = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        if (i < (sizeX / 2) + 1) {\n            labels.x[i] = numberToCJK(i);\n        } else {\n            labels.x[i] = (sizeX - i + 1) + '';\n        }\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = (sizeY - i + 1) + '';\n        if (i > (sizeY / 2)) {\n            labels.y[i] = numberToCJK(sizeY - i + 1);\n        } else {\n            labels.y[i] = i + '';\n        }\n    }\n    return labels;\n};\n\n// Eastern, numeric and CJK, coordinate system\nbesogo.coord.eastern = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        labels.x[i] = i + ''; // Columns are numeric\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = numberToCJK(i);\n    }\n\n    return labels;\n};\n\n// Helper for converting numeric coord to letter (skipping I)\nfunction numberToLetter(number) {\n    return 'ABCDEFGHJKLMNOPQRSTUVWXYZ'.charAt((number - 1) % 25);\n}\n\n// Helper for converting numeric coord to CJK symbol\nfunction numberToCJK(number) {\n    var label = '',\n        cjk = '一二三四五六七八九';\n    \n    if (number >= 20) { // 20 and larger\n        label = cjk.charAt(number / 10 - 1) + '十';\n    } else if (number >= 10) { // 10 through 19\n        label = '十';\n    }\n    if (number % 10) { // Ones digit if non-zero\n        label = label + cjk.charAt((number - 1) % 10);\n    }\n    return label;\n}\n\n})(); // END closure\nbesogo.makeEditor = function(sizeX, sizeY) {\n    'use strict';\n    // Creates an associated game state tree\n    var root = besogo.makeGameRoot(sizeX, sizeY),\n        current = root, // Navigation cursor\n\n        listeners = [], // Listeners of general game/editor state changes\n\n        // Enumeration of editor tools/modes\n        TOOLS = ['navOnly', // read-only navigate mode\n            'auto', // auto-mode: navigate or auto-play color\n            'playB', // play black stone\n            'playW', // play white stone\n            'addB', // setup black stone\n            'addW', // setup white stone\n            'addE', // setup empty stone\n            'clrMark', // remove markup\n            'circle', // circle markup\n            'square', // square markup\n            'triangle', // triangle markup\n            'cross', // \"X\" cross markup\n            'block', // filled square markup\n            'label'], // label markup\n        tool = 'auto', // Currently active tool (default: auto-mode)\n        label = \"1\", // Next label that will be applied\n\n        navHistory = [], // Navigation history\n\n        gameInfo = {}, // Game info properties\n\n        // Order of coordinate systems\n        COORDS = 'none numeric western eastern corner eastcor'.split(' '),\n        coord = 'none', // Selected coordinate system\n\n        // Variant style: even/odd - children/siblings, <2 - show auto markup for variants\n        variantStyle = 0; // 0-3, 0 is default\n\n    return {\n        addListener: addListener,\n        click: click,\n        nextNode: nextNode,\n        prevNode: prevNode,\n        nextSibling: nextSibling,\n        toggleCoordStyle: toggleCoordStyle,\n        getCoordStyle: getCoordStyle,\n        setCoordStyle: setCoordStyle,\n        toggleVariantStyle: toggleVariantStyle,\n        getVariantStyle: getVariantStyle,\n        setVariantStyle: setVariantStyle,\n        getGameInfo: getGameInfo,\n        setGameInfo: setGameInfo,\n        setComment: setComment,\n        getTool: getTool,\n        setTool: setTool,\n        getLabel: getLabel,\n        setLabel: setLabel,\n        getVariants: getVariants, // Returns variants of current node\n        getCurrent: getCurrent,\n        setCurrent: setCurrent,\n        cutCurrent: cutCurrent,\n        getRoot: getRoot,\n        loadRoot: loadRoot // Loads new game state\n    };\n\n    // Returns the active tool\n    function getTool() {\n        return tool;\n    }\n\n    // Sets the active tool, returns false if failed\n    function setTool(set) {\n        // Toggle label mode if already label tool already selected\n        if (set === 'label' && set === tool) {\n            if ( /^-?\\d+$/.test(label) ) { // If current label is integer\n                setLabel('A'); // Toggle to characters\n            } else {\n                setLabel('1'); // Toggle back to numbers\n            }\n            return true; // Notification already handled by setLabel\n        }\n        // Set the tool only if in list and actually changed\n        if (TOOLS.indexOf(set) !== -1 && tool !== set) {\n            tool = set;\n            notifyListeners({ tool: tool, label: label }); // Notify tool change\n            return true;\n        }\n        return false;\n    }\n\n    // Gets the next label to apply\n    function getLabel() {\n        return label;\n    }\n\n    // Sets the next label to apply and sets active tool to label\n    function setLabel(set) {\n        if (typeof set === 'string') {\n            set = set.replace(/\\s/g, ' ').trim(); // Convert all whitespace to space and trim\n            label = set || \"1\"; // Default to \"1\" if empty string\n            tool = 'label'; // Also change current tool to label\n            notifyListeners({ tool: tool, label: label }); // Notify tool/label change\n        }\n    }\n\n    // Toggle the coordinate style\n    function toggleCoordStyle() {\n        coord = COORDS[(COORDS.indexOf(coord) + 1) % COORDS.length];\n        notifyListeners({ coord: coord });\n    }\n\n    // Gets the current coordinate style\n    function getCoordStyle() {\n        return coord;\n    }\n\n    // Sets the coordinate system style\n    function setCoordStyle(setCoord) {\n        if (besogo.coord[setCoord]) {\n            coord = setCoord;\n            notifyListeners({ coord: setCoord });\n        }\n    }\n\n    // Toggles the style for showing variants\n    function toggleVariantStyle(toggleShow) {\n        var childStyle = variantStyle % 2, // 0: children, 1: siblings\n            showStyle = variantStyle - childStyle; // 0: show auto-markup, 2: hide\n        if (toggleShow) { // Truthy input toggles showing of auto-markup\n            showStyle = (showStyle + 2) % 4; // 0 => 2 or 2 => 0\n        } else { // Falsy input toggles child vs sibling style\n            childStyle = (childStyle + 1) % 2; // 0 => 1 or 1 => 0\n        }\n        variantStyle = childStyle + showStyle;\n        notifyListeners({ variantStyle: variantStyle, markupChange: true });\n    }\n\n    // Returns the variant style\n    function getVariantStyle() {\n        return variantStyle;\n    }\n\n    // Directly sets the variant style\n    function setVariantStyle(style) {\n        if (style === 0 || style === 1 || style === 2 || style === 3) {\n            variantStyle = style;\n            notifyListeners({ variantStyle: variantStyle, markupChange: true });\n        }\n    }\n\n    function getGameInfo() {\n        return gameInfo;\n    }\n\n    function setGameInfo(info, id) {\n        if (id) {\n            gameInfo[id] = info;\n        } else {\n            gameInfo = info;\n        }\n        notifyListeners({ gameInfo: gameInfo });\n    }\n\n    function setComment(text) {\n        text = text.trim(); // Trim whitespace and standardize line breaks\n        text = text.replace(/\\r\\n/g,'\\n').replace(/\\n\\r/g,'\\n').replace(/\\r/g,'\\n');\n        text.replace(/\\f\\t\\v\\u0085\\u00a0/g,' '); // Convert other whitespace to space\n        current.comment = text;\n        notifyListeners({ comment: text });\n    }\n\n    // Returns variants of the current node according to the set style\n    function getVariants() {\n        if (variantStyle >= 2) { // Do not show variants if style >= 2\n            return [];\n        }\n        if (variantStyle === 1) { // Display sibling variants\n            // Root node does not have parent nor siblings\n            return current.parent ? current.parent.children : [];\n        }\n        return current.children; // Otherwise, style must be 0, display child variants\n    }\n\n    // Returns the currently active node in the game state tree\n    function getCurrent() {\n        return current;\n    }\n\n    // Returns the root of the game state tree\n    function getRoot() {\n        return root;\n    }\n\n    function loadRoot(load) {\n        root = load;\n        current = load;\n        notifyListeners({ treeChange: true, navChange: true, stoneChange: true });\n    }\n\n    // Navigates forward num nodes (to the end if num === -1)\n    function nextNode(num) {\n        if (current.children.length === 0) { // Check if no children\n            return false; // Do nothing if no children (avoid notification)\n        }\n        while (current.children.length > 0 && num !== 0) {\n            if (navHistory.length) { // Non-empty navigation history\n                current = navHistory.pop();\n            } else { // Empty navigation history\n                current = current.children[0]; // Go to first child\n            }\n            num--;\n        }\n        // Notify listeners of navigation (with no tree edits)\n        notifyListeners({ navChange: true }, true); // Preserve history\n    }\n\n    // Navigates backward num nodes (to the root if num === -1)\n    function prevNode(num) {\n        if (current.parent === null) { // Check if root\n            return false; // Do nothing if already at root (avoid notification)\n        }\n        while (current.parent && num !== 0) {\n            navHistory.push(current); // Save current into navigation history\n            current = current.parent;\n            num--;\n        }\n        // Notify listeners of navigation (with no tree edits)\n        notifyListeners({ navChange: true }, true); // Preserve history\n    }\n\n    // Cyclically switches through siblings\n    function nextSibling(change) {\n        var siblings,\n            i = 0;\n\n        if (current.parent) {\n            siblings = current.parent.children;\n\n            // Exit early if only child\n            if (siblings.length === 1) {\n                return;\n            }\n\n            // Find index of current amongst siblings\n            i = siblings.indexOf(current);\n\n            // Apply change cyclically\n            i = (i + change) % siblings.length;\n            if (i < 0) {\n                i += siblings.length;\n            }\n\n            current = siblings[i];\n            // Notify listeners of navigation (with no tree edits)\n            notifyListeners({ navChange: true });\n        }\n    }\n\n    // Sets the current node\n    function setCurrent(node) {\n        if (current !== node) {\n            current = node;\n            // Notify listeners of navigation (with no tree edits)\n            notifyListeners({ navChange: true });\n        }\n    }\n\n    // Removes current branch from the tree\n    function cutCurrent() {\n        var parent = current.parent;\n        if (tool === 'navOnly') {\n            return; // Tree editing disabled in navOnly mode\n        }\n        if (parent) {\n            if (confirm(\"Delete this branch?\") === true) {\n                parent.removeChild(current);\n                current = parent;\n                // Notify navigation and tree edited\n                notifyListeners({ treeChange: true, navChange: true });\n            }\n        }\n    }\n\n    // Handle click with application of selected tool\n    function click(i, j, ctrlKey, shiftKey) {\n        switch(tool) {\n            case 'navOnly':\n                navigate(i, j, shiftKey);\n                break;\n            case 'auto':\n                if (!navigate(i, j, shiftKey) && !shiftKey) { // Try to navigate to (i, j)\n                    playMove(i, j, 0, ctrlKey); // Play auto-color move if navigate fails\n                }\n                break;\n            case 'playB':\n                playMove(i, j, -1, ctrlKey); // Black move\n                break;\n            case 'playW':\n                playMove(i, j, 1, ctrlKey); // White move\n                break;\n            case 'addB':\n                placeSetup(i, j, -1);\n                break;\n            case 'addW':\n                placeSetup(i, j, 1);\n                break;\n            case 'addE':\n                placeSetup(i, j, 0);\n                break;\n            case 'clrMark':\n                setMarkup(i, j, 0);\n                break;\n            case 'circle':\n                setMarkup(i, j, 1);\n                break;\n            case 'square':\n                setMarkup(i, j, 2);\n                break;\n            case 'triangle':\n                setMarkup(i, j, 3);\n                break;\n            case 'cross':\n                setMarkup(i, j, 4);\n                break;\n            case 'block':\n                setMarkup(i, j, 5);\n                break;\n            case 'label':\n                setMarkup(i, j, label);\n                break;\n        }\n    }\n\n    // Navigates to child with move at (x, y), searching tree if shiftKey pressed\n    // Returns true is successful, false if not\n    function navigate(x, y, shiftKey) {\n        var i, move,\n            children = current.children;\n\n        // Look for move at same location in children\n        for (i = 0; i < children.length; i++) {\n            move = children[i].move;\n            if (move && move.x === x && move.y === y) {\n                current = children[i]; // Navigate to child if found\n                // Notify navigation (with no tree edits)\n                notifyListeners({ navChange: true });\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Plays a move at the given color and location\n    // Set allowAll to truthy to allow illegal moves\n    function playMove(i, j, color, allowAll) {\n        var next;\n        // Check if current node is immutable or root\n        if ( !current.isMutable('move') || !current.parent ) {\n            next = current.makeChild(); // Create a new child node\n            if (next.playMove(i, j, color, allowAll)) { // Play in new node\n                // Keep (add to game state tree) only if move succeeds\n                current.addChild(next);\n                current = next;\n                // Notify tree change, navigation, and stone change\n                notifyListeners({ treeChange: true, navChange: true, stoneChange: true });\n            }\n        // Current node is mutable and not root\n        } else if(current.playMove(i, j, color, allowAll)) { // Play in current\n            // Only need to update if move succeeds\n            notifyListeners({ stoneChange: true }); // Stones changed\n        }\n    }\n\n    // Places a setup stone at the given color and location\n    function placeSetup(i, j, color) {\n        var next;\n        if (color === current.getStone(i, j)) { // Compare setup to current\n            if (color !== 0) {\n                color = 0; // Same as current indicates removal desired\n            } else { // Color and current are both empty\n                return; // No change if attempting to set empty to empty\n            }\n        }\n        // Check if current node can accept setup stones\n        if (!current.isMutable('setup')) {\n            next = current.makeChild(); // Create a new child node\n            if (next.placeSetup(i, j, color)) { // Place setup stone in new node\n                // Keep (add to game state tree) only if change occurs\n                current.addChild(next);\n                current = next;\n                // Notify tree change, navigation, and stone change\n                notifyListeners({ treeChange: true, navChange: true, stoneChange: true });\n            }\n        } else if(current.placeSetup(i, j, color)) { // Try setup in current\n            // Only need to update if change occurs\n            notifyListeners({ stoneChange: true }); // Stones changed\n        }\n    }\n\n    // Sets the markup at the given location and place\n    function setMarkup(i, j, mark) {\n        var temp; // For label incrementing\n        if (mark === current.getMarkup(i, j)) { // Compare mark to current\n            if (mark !== 0) {\n                mark = 0; // Same as current indicates removal desired\n            } else { // Mark and current are both empty\n                return; // No change if attempting to set empty to empty\n            }\n        }\n        if (current.addMarkup(i, j, mark)) { // Try to add the markup\n            if (typeof mark === 'string') { // If markup is a label, increment the label\n                if (/^-?\\d+$/.test(mark)) { // Integer number label\n                    temp = +mark; // Convert to number\n                    // Increment and convert back to string\n                    setLabel( \"\" + (temp + 1) );\n                } else if ( /[A-Za-z]$/.test(mark) ) { // Ends with [A-Za-z]\n                    // Get the last character in the label\n                    temp = mark.charAt(mark.length - 1);\n                    if (temp === 'z') { // Cyclical increment\n                        temp = 'A'; // Move onto uppercase letters\n                    } else if (temp === 'Z') {\n                        temp = 'a'; // Move onto lowercase letters\n                    } else {\n                        temp = String.fromCharCode(temp.charCodeAt() + 1);\n                    }\n                    // Replace last character of label with incremented char\n                    setLabel( mark.slice(0, mark.length - 1) + temp );\n                }\n            }\n            notifyListeners({ markupChange: true }); // Notify markup change\n        }\n    }\n\n    // Adds a listener (by call back func) that will be notified on game/editor state changes\n    function addListener(listener) {\n        listeners.push(listener);\n    }\n\n    // Notify listeners with the given message object\n    //  Data sent to listeners:\n    //    tool: changed tool selection\n    //    label: changed next label\n    //    coord: changed coordinate system \n    //    variantStyle: changed variant style\n    //    gameInfo: changed game info\n    //    comment: changed comment in current node\n    //  Flags sent to listeners:\n    //    treeChange: nodes added or removed from tree\n    //    navChange: current switched to different node\n    //    stoneChange: stones modified in current node\n    //    markupChange: markup modified in current node\n    function notifyListeners(msg, keepHistory) {\n        var i;\n        if (!keepHistory && msg.navChange) {\n            navHistory = []; // Clear navigation history\n        }\n        for (i = 0; i < listeners.length; i++) {\n            listeners[i](msg);\n        }\n    }\n};\nbesogo.makeFilePanel = function(container, editor) {\n    'use strict';\n    var fileChooser, // Reference to the file chooser element\n        element, // Scratch variable for creating elements\n        WARNING = \"Everything not saved will be lost\";\n\n    makeNewBoardButton(9); // New 9x9 board button\n    makeNewBoardButton(13); // New 13x13 board button\n    makeNewBoardButton(19); // New 19x19 board button\n    makeNewBoardButton('?'); // New custom board button\n\n    // Hidden file chooser element\n    fileChooser = makeFileChooser();\n    container.appendChild(fileChooser);\n\n    // Load file button\n    element = document.createElement('input');\n    element.type = 'button';\n    element.value = 'Open';\n    element.title = 'Import SGF';\n    element.onclick = function() { // Bind click to the hidden file chooser\n        fileChooser.click();\n    };\n    container.appendChild(element);\n\n    // Save file button\n    element = document.createElement('input');\n    element.type = 'button';\n    element.value = 'Save';\n    element.title = 'Export SGF';\n    element.onclick = function() {\n        var fileName = prompt('Save file as', 'export.sgf');\n        if (fileName) { // Canceled or empty string does nothing\n            saveFile(fileName, besogo.composeSgf(editor));\n        }\n    };\n    container.appendChild(element);\n\n\n    // Makes a new board button\n    function makeNewBoardButton(size) {\n        var button = document.createElement('input');\n        button.type = 'button';\n        button.value = size + \"x\" + size;\n        if (size === '?') { // Make button for custom sized board\n            button.title = \"New custom size board\";\n            button.onclick = function() {\n                var input = prompt(\"Enter custom size for new board\" + \"\\n\" + WARNING, \"19:19\"),\n                    size;\n                if (input) { // Canceled or empty string does nothing\n                    size = besogo.parseSize(input);\n                    editor.loadRoot(besogo.makeGameRoot(size.x, size.y));\n                    editor.setGameInfo({});\n                }\n            };\n        } else { // Make button for fixed size board\n            button.title = \"New \" + size + \"x\" + size + \" board\";\n            button.onclick = function() {\n                if (confirm(button.title + \"?\\n\" + WARNING)) {\n                    editor.loadRoot(besogo.makeGameRoot(size, size));\n                    editor.setGameInfo({});\n                }\n            };\n        }\n        container.appendChild(button);\n    }\n\n    // Creates the file selector\n    function makeFileChooser() {\n        var chooser = document.createElement('input');\n        chooser.type = 'file';\n        chooser.style.display = 'none'; // Keep hidden\n        chooser.onchange = readFile; // Read, parse and load on file select\n        return chooser;\n    }\n\n    // Reads, parses and loads an SGF file\n    function readFile(evt) {\n        var file = evt.target.files[0], // Selected file\n            reader = new FileReader(),\n            newChooser = makeFileChooser(); // Create new file input to reset selection\n\n        container.replaceChild(newChooser, fileChooser); // Replace with the reset selector\n        fileChooser = newChooser;\n\n        reader.onload = function(e){ // Parse and load game tree\n            var sgf;\n            try {\n                sgf = besogo.parseSgf(e.target.result);\n            } catch (error) {\n                alert('SGF parse error at ' + error.at + ':\\n' + error.message);\n                return;\n            }\n            besogo.loadSgf(sgf, editor);\n        };\n        if (confirm(\"Load '\" + file.name + \"'?\\n\" + WARNING)) {\n            reader.readAsText(file); // Initiate file read\n        }\n    }\n\n    // Composes SGF file and initializes download\n    function saveFile(fileName, text) {\n        var link = document.createElement('a'),\n            blob = new Blob([text], { encoding:\"UTF-8\", type:\"text/plain;charset=UTF-8\" });\n\n        link.download = fileName; // Set download file name\n        link.href = URL.createObjectURL(blob);\n        link.style.display = 'none'; // Make link hidden\n        container.appendChild(link); // Add link to ensure that clicking works\n        link.click(); // Click on link to initiate download\n        container.removeChild(link); // Immediately remove the link\n    }\n};\nbesogo.makeGameRoot = function(sizeX, sizeY) {\n    'use strict';\n    var BLACK = -1, // Stone state constants\n        WHITE = 1, // Equal to -BLACK\n        EMPTY = 0, // Any falsy (e.g., undefined) value is also empty\n\n        root = { // Inherited attributes of root node\n            nextToMove: BLACK,\n            blackCaps: 0,\n            whiteCaps: 0,\n            moveNumber: 0\n        };\n\n    // Initializes non-inherited attributes\n    function initNode(node, parent) {\n        node.parent = parent;\n        node.children = [];\n\n        node.move = null;\n        node.setupStones = [];\n        node.markup = [];\n        node.comment = ''; // Comment on this node\n    }\n    initNode(root, null); // Initialize root node with null parent\n\n\n    // Plays a move, returns true if successful\n    // Set allow to truthy to allow overwrite, suicide and ko\n    root.playMove = function(x, y, color, allow) {\n        var captures = 0, // Number of captures made by this move\n            overwrite = false, // Flags whether move overwrites a stone\n            prevMove, // Previous move for ko check\n            testBoard, // Copy of board state to test captures, ko, and suicide\n            pending, // Pending capture locations\n            i; // Scratch iteration variable\n\n        if (!this.isMutable('move')) {\n            return false; // Move fails if node is immutable\n        }\n\n        if (!color) { // Falsy color indicates auto-color\n            color = this.nextToMove;\n        }\n\n        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n            this.move = { // Register as pass move if out of bounds\n                x: 0, y: 0, // Log pass as position (0, 0)\n                color: color,\n                captures: 0, // Pass never captures\n                overwrite: false // Pass is never an overwrite\n            };\n            this.nextToMove = -color; // Update next to move\n            this.moveNumber++; // Increment move number\n            return true; // Pass move successful\n        }\n\n        if (this.getStone(x, y)) { // Check for overwrite\n            if (!allow) {\n                return false; // Reject overwrite move if not allowed\n            }\n            overwrite = true; // Otherwise, flag overwrite and proceed\n        }\n\n        testBoard = Object.create(this); // Copy board state (no need to initialize)\n        pending = []; // Initialize pending capture array\n\n        setStone(testBoard, x, y, color); // Place the move stone\n\n        // Check for captures of surrounding chains\n        captureStones(testBoard, x - 1, y, color, pending);\n        captureStones(testBoard, x + 1, y, color, pending);\n        captureStones(testBoard, x, y - 1, color, pending);\n        captureStones(testBoard, x, y + 1, color, pending);\n\n        captures = pending.length; // Capture count\n\n        prevMove = this.parent ? this.parent.move : null; // Previous move played\n        if (!allow && prevMove && // If previous move exists, ...\n            prevMove.color === -color && // was of the opposite color, ...\n            prevMove.overwrite === false && // not an overwrite, ...\n            prevMove.captures === 1 && // captured exactly one stone, and if ...\n            captures === 1 && // this move captured exactly one stone at the location ...\n            !testBoard.getStone(prevMove.x, prevMove.y) ) { // of the previous move\n                return false; // Reject ko move if not allowed\n        }\n\n        if (captures === 0) { // Check for suicide if nothing was captured\n            captureStones(testBoard, x, y, -color, pending); // Invert color for suicide check\n            captures = -pending.length; // Count suicide as negative captures\n            if (captures < 0 && !allow) {\n                return false; // Reject suicidal move if not allowed\n            }\n        }\n\n        if (color * captures < 0) { // Capture by black or suicide by white\n            this.blackCaps += Math.abs(captures); // Tally captures for black\n        } else { // Capture by white or suicide by black\n            this.whiteCaps += Math.abs(captures); // Tally captures for white\n        }\n\n        setStone(this, x, y, color); // Place the stone\n        for (i = 0; i < pending.length; i++) { // Remove the captures\n            setStone(this, pending[i].x, pending[i].y, EMPTY);\n        }\n\n        this.move = { // Log the move\n            x: x, y: y,\n            color: color,\n            captures: captures,\n            overwrite: overwrite\n        };\n        this.nextToMove = -color; // Update next to move\n        this.moveNumber++; // Increment move number\n        return true;\n    }; // END func root.playMove\n\n    // Check for and perform capture of opposite color chain at (x, y)\n    function captureStones(board, x, y, color, captures) {\n        var pending = [],\n            i; // Scratch iteration variable\n\n        if ( !recursiveCapture(board, x, y, color, pending) ) { // Captured chain found\n            for (i = 0; i < pending.length; i++) { // Remove captured stones\n                setStone(board, pending[i].x, pending[i].y, EMPTY);\n                captures.push(pending[i]);\n            }\n        }\n    }\n\n    // Recursively builds a chain of pending captures starting from (x, y)\n    // Stops and returns true if chain has liberties\n    function recursiveCapture(board, x, y, color, pending) {\n        var i; // Scratch iteration variable\n\n        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n            return false; // Stop if out of bounds\n        }\n        if (board.getStone(x, y) === color) {\n            return false; // Stop if other color found\n        }\n        if (!board.getStone(x, y)) {\n            return true; // Stop and signal that liberty was found\n        }\n        for (i = 0; i < pending.length; i++) {\n            if (pending[i].x === x && pending[i].y === y) {\n                return false; // Stop if already in pending captures\n            }\n        }\n\n        pending.push({ x: x, y: y }); // Add new stone into chain of pending captures\n\n        // Recursively check for liberties and expand chain\n        if (recursiveCapture(board, x - 1, y, color, pending) ||\n            recursiveCapture(board, x + 1, y, color, pending) ||\n            recursiveCapture(board, x, y - 1, color, pending) ||\n            recursiveCapture(board, x, y + 1, color, pending)) {\n                return true; // Stop and signal liberty found in subchain\n        }\n        return false; // Otherwise, no liberties found\n    }\n\n    // Places a setup stone, returns true if successful\n    root.placeSetup = function(x, y, color) {\n        var prevColor = (this.parent && this.parent.getStone(x, y)) || EMPTY;\n\n        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n            return false; // Do not allow out of bounds setup\n        }\n        if (!this.isMutable('setup') || this.getStone(x, y) === color) {\n            // Prevent setup changes in immutable node or quit early if no change\n            return false;\n        }\n\n        setStone(this, x, y, color); // Place the setup stone\n        this.setupStones[ fromXY(x, y) ] = color - prevColor; // Record the necessary change\n        return true;\n    };\n\n    // Adds markup, returns true if successful\n    root.addMarkup = function(x, y, mark) {\n        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n            return false; // Do not allow out of bounds markup\n        }\n        if (this.getMarkup(x, y) === mark) { // Quit early if no change to make\n            return false;\n        }\n        this.markup[ fromXY(x, y) ] = mark;\n        return true;\n    };\n\n    // Returns the stone status of the given position\n    root.getStone = function(x, y) {\n        return this['board' + x + '-' + y] || EMPTY;\n    };\n\n    // Directly sets the stone state for the given game node\n    function setStone(node, x, y, color) {\n        node['board' + x + '-' + y] = color;\n    }\n\n    // Gets the setup stone placed at (x, y), returns false if none\n    root.getSetup = function(x, y) {\n        if (!this.setupStones[ fromXY(x, y) ]) { // No setup stone placed\n            return false;\n        } else { // Determine net effect of setup stone\n            switch(this.getStone(x, y)) {\n                case EMPTY:\n                    return 'AE';\n                case BLACK:\n                    return 'AB';\n                case WHITE:\n                    return 'AW';\n            }\n        }\n    };\n\n    // Gets the markup at (x, y)\n    root.getMarkup = function(x, y) {\n        return this.markup[ fromXY(x, y) ] || EMPTY;\n    };\n\n    // Determines the type of this node\n    root.getType = function() {\n        var i;\n\n        if (this.move) { // Logged move implies move node\n            return 'move';\n        }\n\n        for (i = 0; i < this.setupStones.length; i++) {\n            if (this.setupStones[i]) { // Any setup stones implies setup node\n                return 'setup';\n            }\n        }\n\n        return 'empty'; // Otherwise, \"empty\" (neither move nor setup)\n    };\n\n    // Checks if this node can be modified by a 'type' action\n    root.isMutable = function(type) {\n        // Can only add a move to an empty node with no children\n        if (type === 'move' && this.getType() === 'empty' && this.children.length === 0) {\n            return true;\n        }\n        // Can only add setup stones to a non-move node with no children\n        if (type === 'setup' && this.getType() !== 'move' && this.children.length === 0) {\n            return true;\n        }\n        return false;\n    };\n\n    // Gets siblings of this node\n    root.getSiblings = function() {\n        return (this.parent && this.parent.children) || [];\n    };\n\n    // Makes a child node of this node, but does NOT add it to children\n    root.makeChild = function() {\n        var child = Object.create(this); // Child inherits properties\n        initNode(child, this); // Initialize other properties\n\n        return child;\n    };\n\n    // Adds a child to this node\n    root.addChild = function(child) {\n        this.children.push(child);\n    };\n\n    // Remove child node from this node, returning false if failed\n    root.removeChild = function(child) {\n        var i = this.children.indexOf(child);\n        if (i !== -1) {\n            this.children.splice(i, 1);\n            return true;\n        }\n        return false;\n    };\n\n    // Gets board size\n    root.getSize = function() {\n        return { x: sizeX, y: sizeY };\n    };\n\n    return root;\n\n    // Convert (x, y) coordinates to linear index\n    function fromXY(x, y) {\n        return (x - 1) * sizeY + (y - 1);\n    }\n};\n// Load a parsed SGF object into a game state tree\nbesogo.loadSgf = function(sgf, editor) {\n    'use strict';\n    var size = { x: 19, y: 19 }, // Default size (may be changed by load)\n        root;\n\n    loadRootProps(sgf); // Load size, variants style and game info\n    root = besogo.makeGameRoot(size.x, size.y);\n\n    loadNodeTree(sgf, root); // Load the rest of game tree\n    editor.loadRoot(root); // Load root into the editor\n\n\n    // Loads the game tree\n    function loadNodeTree(sgfNode, gameNode) {\n        var i, nextGameNode;\n\n        // Load properties from the SGF node into the game state node\n        for (i = 0; i < sgfNode.props.length; i++) {\n            loadProp(gameNode, sgfNode.props[i]);\n        }\n\n        // Recursively load the rest of the tree\n        for (i = 0; i < sgfNode.children.length; i++) {\n            nextGameNode = gameNode.makeChild();\n            gameNode.addChild(nextGameNode);\n            loadNodeTree(sgfNode.children[i], nextGameNode);\n        }\n    }\n\n    // Loads property into node\n    function loadProp(node, prop) {\n        var setupFunc = 'placeSetup',\n            markupFunc = 'addMarkup',\n            move;\n\n        switch(prop.id) {\n            case 'B': // Play a black move\n                move = lettersToCoords(prop.values[0]);\n                node.playMove(move.x, move.y, -1, true);\n                break;\n            case 'W': // Play a white move\n                move = lettersToCoords(prop.values[0]);\n                node.playMove(move.x, move.y, 1, true);\n                break;\n            case 'AB': // Setup black stones\n                applyPointList(prop.values, node, setupFunc, -1);\n                break;\n            case 'AW': // Setup white stones\n                applyPointList(prop.values, node, setupFunc, 1);\n                break;\n            case 'AE': // Setup empty stones\n                applyPointList(prop.values, node, setupFunc, 0);\n                break;\n            case 'CR': // Add circle markup\n                applyPointList(prop.values, node, markupFunc, 1);\n                break;\n            case 'SQ': // Add square markup\n                applyPointList(prop.values, node, markupFunc, 2);\n                break;\n            case 'TR': // Add triangle markup\n                applyPointList(prop.values, node, markupFunc, 3);\n                break;\n            case 'M': // Intentional fallthrough treats 'M' as 'MA'\n            case 'MA': // Add 'X' cross markup\n                applyPointList(prop.values, node, markupFunc, 4);\n                break;\n            case 'SL': // Add 'selected' (small filled square) markup\n                applyPointList(prop.values, node, markupFunc, 5);\n                break;\n            case 'L': // Intentional fallthrough treats 'L' as 'LB'\n            case 'LB': // Add label markup\n                applyPointList(prop.values, node, markupFunc, 'label');\n                break;\n            case 'C': // Comment placed on node\n                if (node.comment) {\n                    node.comment += '\\n' + prop.values.join().trim();\n                } else {\n                    node.comment = prop.values.join().trim();\n                }\n                break;\n        }\n    } // END function loadProp\n\n    // Extracts point list and calls func on each\n    // Set param to 'label' to signal handling of label markup property\n    function applyPointList(values, node, func, param) {\n        var i, x, y, // Scratch iteration variables\n            point, // Current point in iteration\n            otherPoint, // Bottom-right point of compressed point lists\n            label; // Label extracted from value\n        for (i = 0; i < values.length; i++) {\n            point = lettersToCoords(values[i].slice(0, 2));\n            if (param === 'label') { // Label markup property\n                label = values[i].slice(3).replace(/\\n/g, ' ');\n                node[func](point.x, point.y, label); // Apply with extracted label\n            } else { // Not a label markup property\n                if (values[i].charAt(2) === ':') { // Expand compressed point list\n                    otherPoint = lettersToCoords(values[i].slice(3));\n                    if (otherPoint.x === point.x && otherPoint.y === point.y) {\n                        // Redundant compressed pointlist\n                        node[func](point.x, point.y, param);\n                    } else if (otherPoint.x < point.x || otherPoint.y < point.y) {\n                        // Only apply to corners if not arranged properly\n                        node[func](point.x, point.y, param);\n                        node[func](otherPoint.x, otherPoint.y, param);\n                    } else { // Iterate over the compressed points\n                        for (x = point.x; x <= otherPoint.x; x++) {\n                            for (y = point.y; y <= otherPoint.y; y++) {\n                                node[func](x, y, param);\n                            }\n                        }\n                    }\n                } else { // Apply on single point\n                    node[func](point.x, point.y, param);\n                }\n            }\n        }\n    } // END function applyPointList\n\n    // Loads root properties (size, variant style and game info)\n    function loadRootProps(node) {\n        var gameInfoIds = ['PB', 'BR', 'BT', 'PW', 'WR', 'WT', // Player info\n                'HA', 'KM', 'RU', 'TM', 'OT', // Game parameters\n                'DT', 'EV', 'GN', 'PC', 'RO', // Event info\n                'GC', 'ON', 'RE', // General comments\n                'AN', 'CP', 'SO', 'US' ], // IP credits\n            gameInfo = {}, // Structure for game info properties\n            i, id, value; // Scratch iteration variables\n\n        for (i = 0; i < node.props.length; i++) {\n            id = node.props[i].id; // Property ID\n            value = node.props[i].values.join().trim(); // Join the values array\n            if (id === 'SZ') { // Size property\n                size = besogo.parseSize(value);\n            } else if (id === 'ST') { // Style property\n                editor.setVariantStyle( +value ); // Converts value to number\n            } else if (gameInfoIds.indexOf(id) !== -1) { // Game info property\n                if (id !== 'GC') { // Treat all but GC as simpletext\n                    value = value.replace(/\\n/g, ' '); // Convert line breaks to spaces\n                }\n                if (value) { // Skip load of empty game info strings\n                    gameInfo[id] = value;\n                }\n            }\n        }\n        editor.setGameInfo(gameInfo);\n    }\n\n    // Converts letters to numerical coordinates\n    function lettersToCoords(letters) {\n        if (letters.match(/^[A-Za-z]{2}$/)) { // Verify input is two letters\n            return {\n                x: charToNum(letters.charAt(0)),\n                y: charToNum(letters.charAt(1)) };\n        } else { // Anything but two letters\n            return { x: 0, y: 0 }; // Return (0, 0) coordinates\n        }\n    }\n\n    function charToNum(c) { // Helper for lettersToCoords\n        if ( c.match(/[A-Z]/) ) { // Letters A-Z to 27-52\n            return c.charCodeAt(0) - 'A'.charCodeAt(0) + 27;\n        } else { // Letters a-z to 1-26\n            return c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n        }\n    }\n};\nbesogo.makeNamesPanel = function(container, editor) {\n    'use strict';\n    var playerBox = document.createElement('div'),\n        whiteBox = document.createElement('div'),\n        blackBox = document.createElement('div'),\n        whiteInfo = document.createTextNode(''),\n        blackInfo = document.createTextNode(''),\n        whiteCaps = document.createElement('span'),\n        blackCaps = document.createElement('span');\n\n    playerBox.className = 'besogo-playerInfo';\n    whiteBox.className = 'besogo-whiteInfo';\n    blackBox.className = 'besogo-blackInfo';\n    whiteCaps.className = 'besogo-whiteCaps';\n    whiteCaps.title = 'White captures';\n    blackCaps.className = 'besogo-blackCaps';\n    blackCaps.title = 'Black captures';\n    whiteBox.appendChild(whiteInfo);\n    whiteBox.appendChild(whiteCaps);\n    blackBox.appendChild(blackInfo);\n    blackBox.appendChild(blackCaps);\n    playerBox.appendChild(whiteBox);\n    playerBox.appendChild(blackBox);\n    container.appendChild(playerBox);\n\n    editor.addListener(update);\n    update({ navChange: true, gameInfo: editor.getGameInfo() });\n\n    function update(msg) {\n        var infoString, // Scratch string\n            textNode,\n            current,\n            passFlag = 0;\n\n        if (msg.gameInfo) {\n            infoString = (msg.gameInfo.PW || 'White') + // White name\n                ' (' + (msg.gameInfo.WR || '?') + ')' + // White rank\n                (msg.gameInfo.WT ? ' ' + msg.gameInfo.WT : ''); // White team\n            textNode = document.createTextNode(infoString);\n            whiteBox.replaceChild(textNode, whiteInfo);\n            whiteInfo = textNode;\n\n            infoString = (msg.gameInfo.PB || 'Black') + // Black name\n                ' (' + (msg.gameInfo.BR || '?') + ')' + // Black rank\n                (msg.gameInfo.BT ? ' ' + msg.gameInfo.BT : ''); // Black team\n            textNode = document.createTextNode(infoString);\n            blackBox.replaceChild(textNode, blackInfo);\n            blackInfo = textNode;\n        }\n\n        if (msg.navChange || msg.stoneChange) {\n            current = editor.getCurrent();\n            if (current.move && current.move.x === 0 && current.move.y === 0) {\n                passFlag = current.move.color;\n            }\n            updateText(whiteCaps, (passFlag === 1 ? 'Passed  ' : '') + current.whiteCaps);\n            updateText(blackCaps, current.blackCaps + (passFlag === -1 ? '  Passed' : ''));\n        }\n    }\n\n    function updateText(parent, text) {\n        var textNode = document.createTextNode(text);\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n        parent.appendChild(textNode);\n    }\n};besogo.parseSgf = function(text) {\n    'use strict';\n    var at = 0, // Current position\n        ch = text.charAt(at); // Current character at position\n\n    findOpenParens(); // Find beginning of game tree\n    return parseTree(); // Parse game tree\n\n    // Builds and throws an error\n    function error(msg) {\n        throw {\n            name: \"Syntax Error\",\n            message: msg,\n            at: at,\n            text: text\n        };\n    }\n\n    // Advances text position by one\n    function next(check) {\n        if (check && check !== ch) { // Verify current character if param given\n            error( \"Expected '\" + check + \"' instead of '\" + ch + \"'\");\n        }\n        at++;\n        ch = text.charAt(at);\n        return ch;\n    }\n\n    // Skips over whitespace until non-whitespace found\n    function white() {\n        while (ch && ch <= ' ') {\n            next();\n        }\n    }\n\n    // Skips all chars until '(' or end found\n    function findOpenParens() {\n        while (ch && ch !== '(') {\n            next();\n        }\n    }\n\n    // Returns true if line break (CR, LF, CR+LF, LF+CR) found\n    // Advances the cursor ONCE for double character (CR+LF, LF+CR) line breaks\n    function lineBreak() {\n        if (ch === '\\n') { // Line Feed (LF)\n            if (text.charAt(at + 1) === '\\r') { // LF+CR, double character line break\n                next(); // Advance cursor only once (pointing at second character)\n            }\n            return true;\n        } else if (ch === '\\r') { // Carriage Return (CR)\n            if (text.charAt(at + 1) === '\\n') { // CR+LF, double character line break\n                next(); // Advance cursor only once (pointing at second character)\n            }\n            return true;\n        }\n        return false; // Did not find a line break or advance\n    }\n\n    // Parses a sub-tree of the game record\n    function parseTree() {\n        var rootNode, // Root of this sub-tree\n            currentNode, // Pointer to parent of the next node\n            nextNode; // Scratch for parsing the next node or sub-tree\n\n        next('('); // Double-check opening parens at start of sub-tree\n        white(); // Skip whitespace before root node\n\n        if (ch !== \";\") { // Error on sub-tree missing root node\n            error(\"Sub-tree missing root\");\n        }\n        rootNode = parseNode(); // Get the first node of this sub-tree\n        white(); // Skip whitespace before parsing next node\n\n        currentNode = rootNode; // Parent of the next node parsed\n        while (ch === ';') { // Get sequence of nodes within this sub-tree\n            nextNode = parseNode(); // Parse the next node\n            // Add next node as child of current\n            currentNode.children.push(nextNode);\n            currentNode = nextNode; // Advance current pointer to this child\n            white(); // Skip whitespace between/after sequence nodes\n        }\n\n        // Look for sub-trees of this sub-tree\n        while (ch === \"(\") {\n            nextNode = parseTree(); // Parse the next sub-tree\n            // Add sub-tree as child of last sequence node\n            currentNode.children.push(nextNode); // Do NOT advance current\n            white(); // Skip whitespace between/after sub-trees\n        }\n        next(')'); // Expect closing parenthesis at end of this sub-tree\n\n        return rootNode;\n    }\n\n    // Parses a node and its properties\n    function parseNode() {\n        var property, // Scratch for parsing properties\n            node = { props: [], children: [] }; // Node to construct\n\n        next(';'); // Double-check semi-colon at start of node\n        white(); // Skip whitespace before properties\n        // Parse properties until end of node detected\n        while ( ch && ch !== ';' && ch !== '(' && ch !== ')') {\n            property = parseProperty(); // Parse the property and values\n            node.props.push(property); // Add property to node\n            white(); // Skip whitespace between/after properties\n        }\n\n        return node;\n    }\n\n    // Parses a property and its values\n    function parseProperty() {\n        var property = { id: '', values: [] }; // Property to construct\n\n        // Look for property ID within letters\n        while ( ch && /[A-Za-z]/.test(ch) ) {\n            if (/[A-Z]/.test(ch)) { // Ignores lower case letters\n                property.id += ch; // Only adds upper case letters\n            }\n            next();\n        }\n        if (!property.id) { // Error if id empty\n            error('Missing property ID');\n        }\n\n        white(); // Skip whitespace before values\n        while(ch === '[') { // Look for values of this property\n            property.values.push( parseValue() );\n            white(); // Skip whitespace between/after values\n        }\n        if (property.values.length === 0) { // Error on empty list of values\n            error('Missing property values');\n        }\n\n        return property;\n    }\n\n    // Parses a value\n    function parseValue() {\n        var value = '';\n        next('['); // Double-check opening bracket at start of value\n\n        // Read until end of value (unescaped closing bracket)\n        while ( ch && ch !== ']' ) {\n            if ( ch === '\\\\' ) { // Backslash escape handling\n                next('\\\\');\n                if (lineBreak()) { // Soft (escaped) line break\n                    // Nothing, soft line breaks are removed\n                } else if (ch <= ' ') { // Other whitespace\n                    value += ' '; // Convert to space\n                } else {\n                    value += ch; // Pass other escaped characters verbatim\n                }\n            } else { // Non-escaped character\n                if (lineBreak()) { // Hard (non-escaped) line break\n                    value += '\\n'; // Convert all new lines to just LF\n                } else if (ch <= ' ') { // Other whitespace\n                    value += ' '; // Convert to space\n                } else {\n                    value += ch; // Other characters\n                }\n            }\n            next();\n        }\n        next(']'); // Expect closing bracket at end of value\n\n        return value;\n    }\n};\n// Convert game state tree into SGF string\nbesogo.composeSgf = function(editor) {\n    'use strict';\n    return '(' + composeNode(editor.getRoot()) + ')';\n\n    // Recursively composes game node tree\n    function composeNode(tree) {\n        var string = ';', // Node starts with semi-colon\n            children = tree.children,\n            i; // Scratch iteration variable\n\n        if (!tree.parent) { // Null parent means node is root\n            // Compose root-specific properties\n            string += composeRootProps(tree);\n        }\n        string += composeNodeProps(tree); // Compose general properties\n\n        // Recurse composition on child nodes\n        if (children.length === 1) { // Continue sequence if only one child\n            string += '\\n' + composeNode(children[0]);\n        } else if (children.length > 1) {\n            for (i = 0; i < children.length; i++) {\n                string += '\\n(' + composeNode(children[i]) + ')';\n            }\n        }\n\n        return string;\n    }\n\n    // Composes root specific properties\n    function composeRootProps(tree) {\n        var string = 'FF[4]GM[1]CA[UTF-8]AP[besogo:' + besogo.VERSION + ']',\n            x = tree.getSize().x,\n            y = tree.getSize().y,\n            gameInfo = editor.getGameInfo(), // Game info structure\n            hasGameInfo = false, // Flag for existence of game info\n            id; // Scratch iteration variable\n\n        if (x === y) { // Square board size\n            string += 'SZ[' + x + ']';\n        } else { // Non-square board size\n            string += 'SZ[' + x + ':' + y + ']';\n        }\n        string += 'ST[' + editor.getVariantStyle() + ']\\n'; // Line break after header\n\n        for ( id in gameInfo ) { // Compose game info properties\n            if (gameInfo.hasOwnProperty(id) && gameInfo[id]) { // Skip empty strings\n                string += id + '[' + escapeText(gameInfo[id]) + ']';\n                hasGameInfo = true;\n            }\n        }\n        string += (hasGameInfo ? '\\n' : ''); // Line break if game info exists\n\n        return string;\n    }\n\n    // Composes other properties\n    function composeNodeProps(node) {\n        var string = '',\n            props, // Scratch variable for property structures\n            stone, i, j; // Scratch iteration variables\n\n        // Compose either move or setup properties depending on type of node\n        if (node.getType() === 'move') { // Compose move properties\n            stone = node.move;\n            string += (stone.color === 1) ? 'W' : 'B';\n            string += '[' + coordsToLetters(stone.x, stone.y) + ']';\n        } else if (node.getType() === 'setup') { // Compose setup properties\n            props = { AB: [], AW: [], AE: [] };\n            for (i = 1; i <= node.getSize().x; i++) {\n                for (j = 1; j <= node.getSize().y; j++) {\n                    stone = node.getSetup(i, j);\n                    if (stone) { // If setup stone placed, add to structure\n                        props[ stone ].push({ x: i, y: j });\n                    }\n                }\n            }\n            string += composePointLists(props);\n        }\n\n        // Compose markup properties\n        props = { CR: [], SQ: [], TR: [], MA: [], SL: [], LB: [] };\n        for (i = 1; i <= node.getSize().x; i++) {\n            for (j = 1; j <= node.getSize().y; j++) {\n                stone = node.getMarkup(i, j);\n                if (stone) { // If markup placed\n                    if (typeof stone === 'string') { // String is label mark\n                        props.LB.push({ x: i, y: j, label: stone });\n                    } else { // Numerical code for markup\n                        // Convert numerical code to property ID\n                        stone = (['CR', 'SQ', 'TR', 'MA', 'SL'])[stone - 1];\n                        props[stone].push({ x: i, y: j });\n                    }\n                }\n            }\n        }\n        string += composePointLists(props);\n\n        if (node.comment) { // Compose comment property\n            string += (string ? '\\n' : ''); // Add line break if other properties exist\n            string += 'C[' + escapeText(node.comment) + ']';\n        }\n\n        return string;\n    } // END function composeNodeProps\n\n    // Composes properties from structure of point lists\n    // Each member should be an array of points for property ID = key\n    // Each point should specify point with (x, y) and may have optional label\n    function composePointLists(lists) {\n        var string = '',\n            id, points, i; // Scratch iteration variables\n\n        for (id in lists) { // Object own keys specifies property IDs\n            if (lists.hasOwnProperty(id)) {\n                points = lists[id]; // Corresponding members are point lists\n                if (points.length > 0) { // Only add property if list non-empty\n                    string += id;\n                    for (i = 0; i < points.length; i++) {\n                        string += '[' + coordsToLetters(points[i].x, points[i].y);\n                        if (points[i].label) { // Add optional composed label\n                            string += ':' + escapeText(points[i].label);\n                        }\n                        string += ']';\n                    }\n                }\n            }\n        }\n        return string;\n    }\n\n    // Escapes backslash and close bracket for text output\n    function escapeText(input) {\n        input = input.replace(/\\\\/g, '\\\\\\\\'); // Escape backslash\n        return input.replace(/\\]/g, '\\\\]'); // Escape close bracket\n    }\n\n    // Converts numerical coordinates to letters\n    function coordsToLetters(x, y) {\n        if (x === 0 || y === 0) {\n            return '';\n        } else {\n            return numToChar(x) + numToChar(y);\n        }\n    }\n\n    function numToChar(num) { // Helper for coordsToLetters\n        if (num > 26) { // Numbers 27-52 to A-Z\n            return String.fromCharCode('A'.charCodeAt(0) + num - 27);\n        } else { // Numbers 1-26 to a-z\n            return String.fromCharCode('a'.charCodeAt(0) + num - 1);\n        }\n    }\n};\n(function() {\n'use strict';\n\n// Color palette\nbesogo.RED  = '#be0119'; // Darker red (marked variant)\nbesogo.LRED = '#ff474c'; // Lighter red (auto-marked variant)\nbesogo.BLUE = '#0165fc'; // Bright blue (last move)\nbesogo.PURP = '#9a0eea'; // Red + blue (variant + last move)\nbesogo.GREY = '#929591'; // Between white and black\nbesogo.GOLD = '#dbb40c'; // Tool selection\nbesogo.TURQ = '#06c2ac'; // Turqoise (nav selection)\n\nbesogo.BLACK_STONES = 4; // Number of black stone images\nbesogo.WHITE_STONES = 11; // Number of white stone images\n\n// Makes an SVG element with given name and attributes\nbesogo.svgEl = function(name, attributes) {\n    var attr, // Scratch iteration variable\n        element = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n\n    for ( attr in (attributes || {}) ) { // Add attributes if supplied\n        if (attributes.hasOwnProperty(attr)) {\n            element.setAttribute(attr, attributes[attr]);\n        }\n    }\n    return element;\n};\n\n// Makes an SVG group for containing the shadow layer\nbesogo.svgShadowGroup = function() {\n    var group = besogo.svgEl('g'),\n        filter = besogo.svgEl('filter', { id: 'blur' }),\n        blur = besogo.svgEl('feGaussianBlur', {\n            in: 'SourceGraphic',\n            stdDeviation: '2'\n        });\n\n    filter.appendChild(blur);\n    group.appendChild(filter);\n    return group;\n};\n\n// Makes a stone shadow\nbesogo.svgShadow = function(x, y) {\n    return besogo.svgEl(\"circle\", {\n        cx: x,\n        cy: y,\n        r: 43,\n        stroke: 'none',\n        fill: 'black',\n        opacity: 0.32,\n        filter: 'url(#blur)'\n    });\n};\n\n// Makes a photo realistic stone element\nbesogo.realStone = function(x, y, color, index) {\n    var element;\n\n    if (color < 0) {\n        color = 'black' + (index % besogo.BLACK_STONES);\n    } else {\n        color = 'white' + (index % besogo.WHITE_STONES);\n    }\n    color = 'img/' + color + '.png';\n\n    element =  besogo.svgEl(\"image\", {\n        x: (x - 44),\n        y: (y - 44),\n        height: 88,\n        width: 88\n    });\n    element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', color);\n\n    return element;\n};\n\n// Makes a stone element\nbesogo.svgStone = function(x, y, color) {\n    var className = \"besogo-svg-greyStone\"; // Grey stone by default\n\n    if (color === -1) { // Black stone\n        className = \"besogo-svg-blackStone\";\n    } else if (color === 1) { // White stone\n        className = \"besogo-svg-whiteStone\";\n    }\n\n    return besogo.svgEl(\"circle\", {\n        cx: x,\n        cy: y,\n        r: 42,\n        'class': className\n    });\n};\n\n// Makes a circle at (x, y)\nbesogo.svgCircle = function(x, y, color) {\n    return besogo.svgEl(\"circle\", {\n        cx: x,\n        cy: y,\n        r: 27,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes a square at (x, y)\nbesogo.svgSquare = function(x, y, color) {\n    return besogo.svgEl(\"rect\", {\n        x: (x - 23),\n        y: (y - 23),\n        width: 46,\n        height: 46,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes an equilateral triangle at (x, y)\nbesogo.svgTriangle = function(x, y, color) {\n    // Approximates an equilateral triangle centered on (x, y)\n    var pointString = \"\" + x + \",\" + (y - 30) + \" \" +\n        (x - 26) + \",\" + (y + 15) + \" \" +\n        (x + 26) + \",\" + (y + 15);\n\n    return besogo.svgEl(\"polygon\", {\n        points: pointString,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes an \"X\" cross at (x, y)\nbesogo.svgCross = function(x, y, color) {\n    var path = \"m\" + (x - 24) + \",\" + (y - 24) + \"l48,48m0,-48l-48,48\";\n\n    return besogo.svgEl(\"path\", {\n        d: path,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes an \"+\" plus sign at (x, y)\nbesogo.svgPlus = function(x, y, color) {\n    var path = \"m\" + x + \",\" + (y - 28) + \"v56m-28,-28h56\";\n\n    return besogo.svgEl(\"path\", {\n        d: path,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes a small filled square at (x, y)\nbesogo.svgBlock = function(x, y, color) {\n    return besogo.svgEl(\"rect\", {\n        x: x - 18,\n        y: y - 18,\n        width: 36,\n        height: 36,\n        stroke: \"none\",\n        \"stroke-width\": 8,\n        fill: color\n    });\n};\n\n// Makes a label at (x, y)\nbesogo.svgLabel = function(x, y, color, label) {\n    var element,\n        size;\n\n    // Trims label to 3 characters\n    if (label.length > 3) {\n        label = label.slice(0, 2) + '…';\n    }\n\n    // Set font size according to label length\n    switch(label.length) {\n        case 1:\n            size = 72;\n            break;\n        case 2:\n            size = 56;\n            break;\n        case 3:\n            size = 36;\n            break;\n    }\n\n    element = besogo.svgEl(\"text\", {\n        x: x,\n        y: y,\n        dy: \".65ex\", // Seems to work for vertically centering these fonts\n        \"font-size\": size,\n        \"text-anchor\": \"middle\", // Horizontal centering\n        \"font-family\": \"Helvetica, Arial, sans-serif\",\n        fill: color\n    });\n    element.appendChild( document.createTextNode(label) );\n\n    return element;\n};\n\n})(); // END closure\nbesogo.makeToolPanel = function(container, editor) {\n    'use strict';\n    var element, // Scratch for building SVG images\n        svg, // Scratch for building SVG images\n        labelText, // Text area for next label input\n        selectors = {}, // Holds selection rects\n        passButton = document.createElement('input'),\n        cutButton = document.createElement('input');\n\n    svg = makeButtonSVG('auto', 'Auto-play/nav'); // Auto-play/nav tool button\n    svg.appendChild(makeYinYang(0, 0));\n\n    svg = makeButtonSVG('playB', 'Play black'); // Play black button\n    svg.appendChild(besogo.svgStone(0, 0, -1));\n\n    svg = makeButtonSVG('playW', 'Play white'); // Play white button\n    svg.appendChild(besogo.svgStone(0, 0, 1));\n\n    svg = makeButtonSVG('addB', 'Set black'); // Add black button\n    element = besogo.svgEl('g');\n    element.appendChild(besogo.svgStone(0, 0, -1)); // Black stone\n    element.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n    svg.appendChild(element);\n\n    svg = makeButtonSVG('addW', 'Set white'); // Add white button\n    element = besogo.svgEl('g');\n    element.appendChild(besogo.svgStone(0, 0, 1)); // White stone\n    element.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n    svg.appendChild(element);\n\n    svg = makeButtonSVG('addE', 'Set empty'); // Add empty button\n    element = besogo.svgEl('g');\n    element.appendChild(besogo.svgStone(0, 0)); // Grey stone\n    element.appendChild(besogo.svgCross(0, 0, besogo.RED)); // Red cross\n    svg.appendChild(element);\n\n    svg = makeButtonSVG('circle', 'Circle'); // Circle markup button\n    svg.appendChild(besogo.svgCircle(0, 0, 'black'));\n\n    svg = makeButtonSVG('square', 'Square'); // Square markup button\n    svg.appendChild(besogo.svgSquare(0, 0, 'black'));\n\n    svg = makeButtonSVG('triangle', 'Triangle'); // Triangle markup button\n    svg.appendChild(besogo.svgTriangle(0, 0, 'black'));\n\n    svg = makeButtonSVG('cross', 'Cross'); // Cross markup button\n    svg.appendChild(besogo.svgCross(0, 0, 'black'));\n\n    svg = makeButtonSVG('block', 'Block'); // Block markup button\n    svg.appendChild(besogo.svgBlock(0, 0, 'black'));\n\n    svg = makeButtonSVG('clrMark', 'Clear mark'); // Clear markup button\n    element = besogo.svgEl('g');\n    element.appendChild(besogo.svgTriangle(0, 0, besogo.GREY));\n    element.appendChild(besogo.svgCross(0, 0, besogo.RED));\n    svg.appendChild(element);\n\n    svg = makeButtonSVG('label', 'Label'); // Label markup button\n    svg.appendChild(besogo.svgLabel(0, 0, 'black', 'A1'));\n\n    labelText = document.createElement(\"input\"); // Label entry text field\n    labelText.type = \"text\";\n    labelText.title = 'Next label';\n    labelText.onblur = function() {\n        editor.setLabel(labelText.value);\n    };\n    labelText.addEventListener('keydown', function(evt) {\n        evt = evt || window.event;\n        evt.stopPropagation(); // Stop keydown propagation when in focus\n    });\n    container.appendChild(labelText);\n\n    passButton.type = 'button';\n    passButton.value = 'Pass';\n    passButton.title = 'Pass move';\n    passButton.onclick = function() {\n        var tool = editor.getTool();\n        if (tool !== 'navOnly' && tool !== 'auto' && tool !== 'playB' && tool !== 'playW') {\n            editor.setTool('auto'); // Ensures that a move tool is selected\n        }\n        editor.click(0, 0, false); // Clicking off the board signals a pass\n    };\n    container.appendChild(passButton);\n\n    cutButton.type = 'button';\n    cutButton.value = 'Cut';\n    cutButton.title = 'Remove branch';\n    cutButton.onclick = function() {\n        editor.cutCurrent();\n    };\n    container.appendChild(cutButton);\n\n    editor.addListener(toolStateUpdate); // Set up listener for tool state updates\n    toolStateUpdate({ label: editor.getLabel(), tool: editor.getTool() }); // Initialize\n\n\n    // Creates a button holding an SVG image\n    function makeButtonSVG(tool, tooltip) {\n        var button = document.createElement('button'),\n            svg = besogo.svgEl('svg', { // Icon container\n                width: '100%',\n                height: '100%',\n                viewBox: '-55 -55 110 110' }), // Centered on (0, 0)\n            selected = besogo.svgEl(\"rect\", { // Selection rectangle\n                x: -50, // Center on (0, 0)\n                y: -50,\n                width: 100,\n                height: 100,\n                fill: 'none',\n                'stroke-width': 8,\n                stroke: besogo.GOLD,\n                rx: 20, // Rounded rectangle\n                ry: 20, // Thanks, Steve\n                visibility: 'hidden'\n            });\n\n        container.appendChild(button);\n        button.appendChild(svg);\n        button.onclick = function() {\n            editor.setTool(tool);\n        };\n        button.title = tooltip;\n        selectors[tool] = selected;\n        svg.appendChild(selected);\n        return svg; // Returns reference to the icon container\n    }\n\n    // Callback for updating tool state and label\n    function toolStateUpdate(msg) {\n        var tool;\n        if (msg.label) {\n            labelText.value = msg.label;\n        }\n        if (msg.tool) {\n            for (tool in selectors) { // Update which tool is selected\n                if (selectors.hasOwnProperty(tool)) {\n                    if (msg.tool === tool) {\n                        selectors[tool].setAttribute('visibility', 'visible');\n                    } else {\n                        selectors[tool].setAttribute('visibility', 'hidden');\n                    }\n                }\n            }\n        }\n    }\n\n    // Draws a yin yang\n    function makeYinYang(x, y) {\n        var element = besogo.svgEl('g');\n\n        // Draw black half circle on right side\n        element.appendChild( besogo.svgEl(\"path\", {\n            d: \"m\" + x + \",\" + (y - 44) + \" a44 44 0 0 1 0,88z\",\n            stroke: \"none\",\n            fill: \"black\"\n        }));\n\n        // Draw white part of ying yang on left side\n        element.appendChild( besogo.svgEl(\"path\", {\n            d: \"m\" + x + \",\" + (y + 44) + \"a44 44 0 0 1 0,-88a22 22 0 0 1 0,44z\",\n            stroke: \"none\",\n            fill: \"white\"\n        }));\n\n        // Draw round part of black half of ying yang\n        element.appendChild( besogo.svgEl(\"circle\", {\n            cx: x,\n            cy: y + 22,\n            r: 22,\n            stroke: \"none\",\n            fill: \"black\"\n        }));\n\n        return element;\n    }\n};\nbesogo.makeTreePanel = function(container, editor) {\n    'use strict';\n    var svg,\n        pathGroup,\n        bottomLayer,\n        currentMarker,\n        SCALE = 0.25; // Tree size scaling factor\n\n    rebuildNavTree();\n    editor.addListener(treeUpdate);\n\n\n    // Callback for handling tree changes\n    function treeUpdate(msg) {\n        if (msg.treeChange) { // Tree structure changed\n            rebuildNavTree(); // Rebuild entire tree\n        } else if (msg.navChange) { // Only navigation changed\n            updateCurrentMarker(); // Update current location marker\n        } else if (msg.stoneChange) { // Only stones in current changed\n            updateCurrentNodeIcon();\n        }\n    }\n\n    // Updates the current marker in the tree\n    function updateCurrentMarker() {\n        var current = editor.getCurrent();\n\n        setSelectionMarker(currentMarker);\n        setCurrentMarker(current.navTreeMarker);\n    }\n\n    // Sets marker element to indicate the current node\n    function setCurrentMarker(marker) {\n        var width = container.clientWidth,\n            height = container.clientHeight,\n            top = container.scrollTop,\n            left = container.scrollLeft,\n            markX = (marker.getAttribute('x') - 5) * SCALE, // Computed position of marker\n            markY = (marker.getAttribute('y') - 5) * SCALE,\n            GRIDSIZE = 120 * SCALE; // Size of the square grid\n\n        if (markX < left) { // Ensure horizontal visibility of current marker\n            container.scrollLeft = markX;\n        } else if (markX + GRIDSIZE > left + width) {\n            container.scrollLeft = markX + GRIDSIZE - width;\n        }\n        if (markY < top) { // Ensure vertical visibility of current marker\n            container.scrollTop = markY;\n        } else if (markY + GRIDSIZE > top + height) {\n            container.scrollTop = markY + GRIDSIZE - height;\n        }\n\n        marker.setAttribute('opacity', 1); // Always visible\n        marker.onmouseover = null; // Clear hover over action\n        marker.onmouseout = null; // Clear hover off action\n        bottomLayer.appendChild(marker); // Moves marker to the background\n        currentMarker = marker;\n    }\n\n    // Sets marker\n    function setSelectionMarker(marker) {\n        marker.setAttribute('opacity', 0); // Normally invisible\n        marker.onmouseover = function() { // Show on hover over\n            marker.setAttribute('opacity', 0.5);\n        };\n        marker.onmouseout = function() { // Hide on hover off\n            marker.setAttribute('opacity', 0);\n        };\n        svg.appendChild(marker); // Move marker to foreground\n    }\n\n    // Rebuilds the entire navigation tree\n    function rebuildNavTree() {\n        var current = editor.getCurrent(), // Current location in game state tree\n            root = editor.getRoot(), // Root node of game state\n            nextOpen = [], // Tracks occupied grid positions\n            oldSvg = svg, // Store the old SVG root\n            background = besogo.svgEl(\"rect\", { // Background color for tree\n                height: '100%',\n                width: '100%',\n                'class': 'besogo-svg-board'\n            }),\n            path, // Root path\n            width, // Calculated dimensions of the SVG\n            height;\n\n        svg = besogo.svgEl(\"svg\");\n        bottomLayer = besogo.svgEl(\"g\"); // Holder for the current marker\n        pathGroup = besogo.svgEl(\"g\"); // Holder for path elements\n\n        svg.appendChild(background); // Background color first\n        svg.appendChild(bottomLayer); // Bottom layer (for current marker) second\n        svg.appendChild(pathGroup); // Navigation path third\n\n        path = recursiveTreeBuild(root, 0, 0, nextOpen); // Build the tree\n        pathGroup.appendChild(finishPath(path, 'black')); // Finish and add root path\n\n        width = 120 * nextOpen.length; // Compute height and width of nav tree\n        height = 120 * Math.max.apply(Math, nextOpen);\n        svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);\n        svg.setAttribute('height', height * SCALE); // Scale down the actual SVG size\n        svg.setAttribute('width', width * SCALE);\n\n        if (oldSvg) { // Replace SVG in container\n            container.replaceChild(svg, oldSvg);\n        } else { // SVG not yet added to container\n            container.appendChild(svg);\n        }\n\n        setCurrentMarker(current.navTreeMarker); // Set current marker and ensure visible\n    } // END function rebuildNavTree\n\n    // Recursively builds the tree\n    function recursiveTreeBuild(node, x, y, nextOpen) {\n        var children = node.children,\n            position,\n            path,\n            childPath,\n            i; // Scratch iteration variable\n\n        if (children.length === 0) { // Reached end of branch\n            path = 'm' + svgPos(x) + ',' + svgPos(y); // Start path at end of branch\n        } else { // Current node has children\n            position = (nextOpen[x + 1] || 0); // First open spot in next column\n            position = (position < y) ? y : position; // Bring level with current y\n\n            if (y < position - 1) { // Check if first child natural drop > 1\n                y = position - 1; // Bring current y within 1 of first child drop\n            }\n            // Place first child and extend path\n            path = recursiveTreeBuild(children[0], x + 1, position, nextOpen) +\n                extendPath(x, y, nextOpen);\n\n            // Place other children (intentionally starting at i = 1)\n            for (i = 1; i < children.length; i++) {\n                position = nextOpen[x + 1];\n                childPath = recursiveTreeBuild(children[i], x + 1, position, nextOpen) +\n                    extendPath(x, y, nextOpen, position - 1);\n                // End path at beginning of branch\n                pathGroup.appendChild(finishPath(childPath, 'black'));\n            }\n        }\n        svg.appendChild(makeNodeIcon(node, x, y));\n        addSelectionMarker(node, x, y);\n\n        nextOpen[x] = y + 1; // Claims (x, y)\n        return path;\n    } // END function recursiveTreeBuild\n\n    function makeNodeIcon(node, x, y) { // Makes a node icon for the tree\n        var element,\n            color;\n\n        switch(node.getType()){\n            case 'move': // Move node\n                color = node.move.color;\n                element = besogo.svgEl(\"g\");\n                element.appendChild( besogo.svgStone(svgPos(x), svgPos(y), color) );\n                color = (color === -1) ? \"white\" : \"black\";\n                element.appendChild( besogo.svgLabel(svgPos(x), svgPos(y), color,\n                    '' + node.moveNumber) );\n                break;\n            case 'setup': // Setup node\n                element = besogo.svgEl(\"g\");\n                element.appendChild(besogo.svgStone(svgPos(x), svgPos(y))); // Grey stone\n                element.appendChild(besogo.svgPlus(svgPos(x), svgPos(y), besogo.RED));\n                break;\n            default: // Empty node\n                element = besogo.svgStone(svgPos(x), svgPos(y)); // Grey stone\n        }\n        node.navTreeIcon = element; // Save icon reference in game state tree\n        node.navTreeX = x; // Save position of the icon\n        node.navTreeY = y;\n\n        return element;\n    } // END function makeNodeIcon\n\n    function updateCurrentNodeIcon() { // Updates the current node icon\n        var current = editor.getCurrent(), // Current location in game state tree\n            oldIcon = current.navTreeIcon,\n            newIcon = makeNodeIcon(current, current.navTreeX, current.navTreeY);\n        svg.replaceChild(newIcon, oldIcon);\n    }\n\n    function addSelectionMarker(node, x, y) {\n        var element = besogo.svgEl(\"rect\", { // Create selection marker\n            x: svgPos(x) - 55,\n            y: svgPos(y) - 55,\n            width: 110,\n            height: 110,\n            fill: besogo.TURQ\n        });\n        element.onclick = function() {\n            editor.setCurrent(node);\n        };\n\n        node.navTreeMarker = element; // Save selection marker in node\n        setSelectionMarker(element); // Add as and set selection marker properties\n    }\n\n    function extendPath(x, y, nextOpen, prevChildPos) { // Extends path from child to current\n        var childPos = nextOpen[x + 1] - 1; // Position of child\n        if (childPos === y) { // Child is horizontally level with current\n            return 'h-120'; // Horizontal line back to current\n        } else if (childPos === y + 1) { // Child is one drop from current\n            return 'l-120,-120'; // Diagonal drop line back to current\n        } else if (prevChildPos && prevChildPos !== y) {\n            // Previous is already dropped, extend back to previous child drop line\n            return 'l-60,-60v-' + (120 * (childPos - prevChildPos));\n        } else { // Extend double-bend drop line back to parent\n            return 'l-60,-60v-' + (120 * (childPos - y - 1)) + 'l-60,-60';\n        }\n    }\n\n    function finishPath(path, color) { // Finishes path element\n        var element = besogo.svgEl(\"path\", {\n            d: path,\n            stroke: color,\n            \"stroke-width\": 8,\n            fill: \"none\"\n        });\n        return element;\n    }\n\n    function svgPos(x) { // Converts (x, y) coordinates to SVG position\n        return (x * 120) + 60;\n    }\n};\n\nbesogo.autoInit()\n</script>\n\n\n\n\n\n\n",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "\n<div class=\"besogo-diagram\" nokeys=1 nowheel=1 maxwidth=700 realstones=1 transwidth=0>{{text:SGF}}</div>\n\n<script>\n\nvar playerColor = \"black\";\n\nif (`{{text:SGF}}`.indexOf(';W') < `{{text:SGF}}`.indexOf(';B') && `{{text:SGF}}`.indexOf(';W') !== -1) {\nplayerColor = \"white\";\n}\n\n\n(function() {\n'use strict';\nvar besogo = window.besogo = window.besogo || {}; // Establish our namespace\nbesogo.VERSION = '0.0.2-alpha';\n\nbesogo.create = function(container, options) {\n    var editor, // Core editor object\n        resizer, // Auto-resizing function\n        boardDiv, // Board display container\n        panelsDiv, // Parent container of panel divs\n        makers = { // Map to panel creators\n            control: besogo.makeControlPanel,\n            names: besogo.makeNamesPanel,\n            comment: besogo.makeCommentPanel,\n            tool: besogo.makeToolPanel,\n            tree: besogo.makeTreePanel,\n            file: besogo.makeFilePanel\n        },\n        insideText = container.textContent || container.innerText || '',\n        i, panelName; // Scratch iteration variables\n\n    container.className += ' besogo-container'; // Marks this div as initialized\n\n    // Process options and set defaults\n    options = options || {}; // Makes option checking simpler\n    options.size = besogo.parseSize(options.size || 19);\n    options.coord = options.coord || 'none';\n    options.tool = options.tool || 'auto';\n    if (options.panels === '') {\n        options.panels = [];\n    }\n    options.panels = options.panels || 'control+names+comment+tool+tree+file';\n    if (typeof options.panels === 'string') {\n        options.panels = options.panels.split('+');\n    }\n    options.path = options.path || '';\n    if (options.shadows === undefined) {\n        options.shadows = 'auto';\n    } else if (options.shadows === 'off') {\n        options.shadows = false;\n    }\n\n    // Make the core editor object\n    editor = besogo.makeEditor(options.size.x, options.size.y);\n    editor.setTool(options.tool);\n    editor.setCoordStyle(options.coord);\n    if (options.realstones) { // Using realistic stones\n        editor.REAL_STONES = true;\n        editor.SHADOWS = options.shadows;\n    } else { // SVG stones\n        editor.SHADOWS = (options.shadows && options.shadows !== 'auto');\n    }\n\n    if (!options.nokeys) { // Add keypress handler unless nokeys option is truthy\n        addKeypressHandler(container, editor);\n    }\n\n    if (options.sgf) { // Load SGF file from URL\n        try {\n            fetchParseLoad(options.sgf, editor, options.path);\n        } catch(e) {\n            // Silently fail on network error\n        }\n    } else if (insideText.match(/\\s*\\(\\s*;/)) { // Text content looks like an SGF file\n        parseAndLoad(insideText, editor);\n        navigatePath(editor, options.path); // Navigate editor along path\n    }\n\n    if (typeof options.variants === 'number' || typeof options.variants === 'string') {\n        editor.setVariantStyle(+options.variants); // Converts to number\n    }\n\n    while (container.firstChild) { // Remove all children of container\n        container.removeChild(container.firstChild);\n    }\n\n    boardDiv = makeDiv('besogo-board'); // Create div for board display\n    besogo.makeBoardDisplay(boardDiv, editor); // Create board display\n\n    if (!options.nowheel) { // Add mousewheel handler unless nowheel option is truthy\n        addWheelHandler(boardDiv, editor);\n    }\n\n    if (options.panels.length > 0) { // Only create if there are panels to add\n        panelsDiv = makeDiv('besogo-panels');\n        for (i = 0; i < options.panels.length; i++) {\n            panelName = options.panels[i];\n            if (makers[panelName]) { // Only add if creator function exists\n                makers[panelName](makeDiv('besogo-' + panelName, panelsDiv), editor);\n            }\n        }\n        if (!panelsDiv.firstChild) { // If no panels were added\n            container.removeChild(panelsDiv); // Remove the panels div\n            panelsDiv = false; // Flags panels div as removed\n        }\n    }\n\n    options.resize = options.resize || 'auto';\n    if (options.resize === 'auto') { // Add auto-resizing unless resize option is truthy\n        resizer = function() {\n            var windowHeight = window.innerHeight, // Viewport height\n                // Calculated width of parent element\n                parentWidth = parseFloat(getComputedStyle(container).width),\n                maxWidth = +(options.maxwidth || -1),\n                orientation = options.orient || 'auto',\n\n                portraitRatio = +(options.portratio || 200) / 100,\n                landscapeRatio = +(options.landratio || 200) / 100,\n                minPanelsWidth = +(options.minpanelswidth || 350),\n                minPanelsHeight = +(options.minpanelsheight || 400),\n                minLandscapeWidth = +(options.transwidth || 600),\n\n                // Initial width parent\n                width = (maxWidth > 0 && maxWidth < parentWidth) ? maxWidth : parentWidth,\n                height; // Initial height is undefined\n\n            // Determine orientation if 'auto' or 'view'\n            if (orientation !== 'portrait' && orientation !== 'landscape') {\n                if (width < minLandscapeWidth || (orientation === 'view' && width < windowHeight)) {\n                    orientation = 'portrait';\n                } else {\n                    orientation = 'landscape';\n                }\n            }\n\n            if (orientation === 'portrait') { // Portrait mode\n                if (!isNaN(portraitRatio)) {\n                    height = portraitRatio * width;\n                    if (panelsDiv) {\n                        height = (height - width < minPanelsHeight) ? width + minPanelsHeight : height;\n                    }\n                } // Otherwise, leave height undefined\n            } else if (orientation === 'landscape') { // Landscape mode\n                if (!panelsDiv) { // No panels div\n                    height = width; // Square overall\n                } else if (isNaN(landscapeRatio)) {\n                    height = windowHeight;\n                } else { // Otherwise use ratio\n                    height = width / landscapeRatio;\n                }\n\n                if (panelsDiv) {\n                    // Reduce height to ensure minimum width of panels div\n                    height = width;\n                }\n            }\n\n            setDimensions(width, height);\n            container.style.width = width + 'px';\n        };\n        window.addEventListener(\"resize\", resizer);\n        resizer(); // Initial div sizing\n    } else if (options.resize === 'fixed') {\n        setDimensions(container.clientWidth, container.clientHeight);\n    }\n\n    // Sets dimensions with optional height param\n    function setDimensions(width, height) {\n        if (height && width > height) { // Landscape mode\n            container.style['flex-direction'] = 'row';\n            boardDiv.style.height = height + 'px';\n            boardDiv.style.width = height + 'px';\n            if (panelsDiv) {\n                panelsDiv.style.height = height + 'px';\n                panelsDiv.style.width = (width - height) + 'px';\n            }\n        } else { // Portrait mode (implied if height is missing)\n            container.style['flex-direction'] = 'column';\n            boardDiv.style.height = width + 'px';\n            boardDiv.style.width = width + 'px';\n            if (panelsDiv) {\n                if (height) { // Only set height if param present\n                    panelsDiv.style.height = (height - width) + 'px';\n                }\n                panelsDiv.style.width = width + 'px';\n            }\n        }\n    }\n\n    // Creates and adds divs to specified parent or container\n    function makeDiv(className, parent) {\n        var div = document.createElement(\"div\");\n        if (className) {\n            div.className = className;\n        }\n        parent = parent || container;\n        parent.appendChild(div);\n        return div;\n    }\n}; // END function besogo.create\n\n// Parses size parameter from SGF format\nbesogo.parseSize = function(input) {\n    var matches,\n        sizeX,\n        sizeY;\n\n    input = (input + '').replace(/\\s/g, ''); // Convert to string and remove whitespace\n\n    matches = input.match(/^(\\d+):(\\d+)$/); // Check for #:# pattern\n    if (matches) { // Composed value pattern found\n        sizeX = +matches[1]; // Convert to numbers\n        sizeY = +matches[2];\n    } else if (input.match(/^\\d+$/)) { // Check for # pattern\n        sizeX = +input; // Convert to numbers\n        sizeY = +input; // Implied square\n    } else { // Invalid input format\n        sizeX = sizeY = 19; // Default size value\n    }\n    if (sizeX > 52 || sizeX < 1 || sizeY > 52 || sizeY < 1) {\n        sizeX = sizeY = 19; // Out of range, set to default\n    }\n\n    return { x: sizeX, y: sizeY };\n};\n\n// Automatically converts document elements into besogo instances\nbesogo.autoInit = function() {\n    var allDivs = document.getElementsByTagName('div'), // Live collection of divs\n        targetDivs = [], // List of divs to auto-initialize\n        options, // Structure to hold options\n        i, j, attrs; // Scratch iteration variables\n\n    for (i = 0; i < allDivs.length; i++) { // Iterate over all divs\n        if ( (hasClass(allDivs[i], 'besogo-editor') || // Has an auto-init class\n              hasClass(allDivs[i], 'besogo-viewer') ||\n              hasClass(allDivs[i], 'besogo-diagram')) &&\n             !hasClass(allDivs[i], 'besogo-container') ) { // Not already initialized\n                targetDivs.push(allDivs[i]);\n        }\n    }\n\n    for (i = 0; i < targetDivs.length; i++) { // Iterate over target divs\n        options = {}; // Clear the options struct\n        if (hasClass(targetDivs[i], 'besogo-editor')) {\n            options.panels = ['control', 'names', 'comment', 'tool', 'tree', 'file'];\n            options.tool = 'auto';\n        } else if (hasClass(targetDivs[i], 'besogo-viewer')) {\n            options.panels = ['control', 'names', 'comment'];\n            options.tool = 'navOnly';\n        } else if (hasClass(targetDivs[i], 'besogo-diagram')) {\n            options.panels = ['control', 'comment'];\n            options.tool = 'navOnly';\n        }\n\n        attrs = targetDivs[i].attributes;\n        for (j = 0; j < attrs.length; j++) { // Load attributes as options\n            options[attrs[j].name] = attrs[j].value;\n        }\n        besogo.create(targetDivs[i], options);\n    }\n\n    function hasClass(element, str) {\n        return (element.className.split(' ').indexOf(str) !== -1);\n    }\n};\n\n// Sets up keypress handling\nfunction addKeypressHandler(container, editor) {\n    if (!container.getAttribute('tabindex')) {\n        container.setAttribute('tabindex', '0'); // Set tabindex to allow div focusing\n    }\n\n    container.addEventListener('keydown', function(evt) {\n        evt = evt || window.event;\n        switch (evt.keyCode) {\n            case 33: // page up\n                editor.prevNode(10);\n                break;\n            case 34: // page down\n                editor.nextNode(10);\n                break;\n            case 35: // end\n                editor.nextNode(-1);\n                break;\n            case 36: // home\n                editor.prevNode(-1);\n                break;\n            case 37: // left\n                editor.prevNode(1);\n                break;\n            case 38: // up\n                editor.nextSibling(-1);\n                break;\n            case 39: // right\n                editor.nextNode(1);\n                break;\n            case 40: // down\n                editor.nextSibling(1);\n                break;\n            case 46: // delete\n                editor.cutCurrent();\n                break;\n        } // END switch (evt.keyCode)\n        if (evt.keyCode >= 33 && evt.keyCode <= 40) {\n            evt.preventDefault(); // Suppress page nav controls\n        }\n    }); // END func() and addEventListener\n} // END function addKeypressHandler\n\n// Sets up mousewheel handling\nfunction addWheelHandler(boardDiv, editor) {\n    boardDiv.addEventListener('wheel', function(evt) {\n        evt = evt || window.event;\n        if (evt.deltaY > 0) {\n            editor.nextNode(1);\n            evt.preventDefault();\n        } else if (evt.deltaY < 0) {\n            editor.prevNode(1);\n            evt.preventDefault();\n        }\n    });\n}\n\n// Parses SGF string and loads into editor\nfunction parseAndLoad(text, editor) {\n    var sgf;\n    try {\n        sgf = besogo.parseSgf(text);\n    } catch (error) {\n        return; // Silently fail on parse error\n    }\n    besogo.loadSgf(sgf, editor);\n}\n\n// Fetches text file at url from same domain\nfunction fetchParseLoad(url, editor, path) {\n    var http = new XMLHttpRequest();\n\n    http.onreadystatechange = function() {\n        if (http.readyState === 4 && http.status === 200) { // Successful fetch\n            parseAndLoad(http.responseText, editor);\n            navigatePath(editor, path);\n        }\n    };\n    http.overrideMimeType('text/plain'); // Prevents XML parsing and warnings\n    http.open(\"GET\", url, true); // Asynchronous load\n    http.send();\n}\n\nfunction navigatePath(editor, path) {\n    var subPaths,\n        i, j; // Scratch iteration variables\n\n    path = path.split(/[Nn]+/); // Split into parts that start in next mode\n    for (i = 0; i < path.length; i++) {\n        subPaths = path[i].split(/[Bb]+/); // Split on switches into branch mode\n        executeMoves(subPaths[0], false); // Next mode moves\n        for (j = 1; j < subPaths.length; j++) { // Intentionally starting at 1\n            executeMoves(subPaths[j], true); // Branch mode moves\n        }\n    }\n\n    function executeMoves(part, branch) {\n        var i;\n        part = part.split(/\\D+/); // Split on non-digits\n        for (i = 0; i < part.length; i++) {\n            if (part[i]) { // Skip empty strings\n                if (branch) { // Branch mode\n                    if (editor.getCurrent().children.length) {\n                        editor.nextNode(1);\n                        editor.nextSibling(part[i] - 1);\n                    }\n                } else { // Next mode\n                    editor.nextNode(+part[i]); // Converts to number\n                }\n            }\n        }\n    }\n}\n\n})(); // END closure\nbesogo.makeBoardDisplay = function(container, editor) {\n    'use strict';\n    var CELL_SIZE = 88, // Including line width\n        COORD_MARGIN = 75, // Margin for coordinate labels\n        EXTRA_MARGIN = 6, // Extra margin on the edge of board\n        BOARD_MARGIN, // Total board margin\n\n        // Board size parameters\n        sizeX = editor.getCurrent().getSize().x,\n        sizeY = editor.getCurrent().getSize().y,\n\n        svg, // Holds the overall board display SVG element\n        stoneGroup, // Group for stones\n        markupGroup, // Group for markup\n        hoverGroup, // Group for hover layer\n        markupLayer, // Array of markup layer elements\n        hoverLayer, // Array of hover layer elements\n\n        randIndex, // Random index for stone images\n\n        TOUCH_FLAG = false; // Flag for touch interfaces\n\n    initializeBoard(editor.getCoordStyle()); // Initialize SVG element and draw the board\n    container.appendChild(svg); // Add the SVG element to the document\n    editor.addListener(update); // Register listener to handle editor/game state updates\n    redrawAll(editor.getCurrent()); // Draw stones, markup and hover layer\n\n    // Set listener to detect touch interfaces\n    container.addEventListener('touchstart', setTouchFlag);\n\n    // Function for setting the flag for touch interfaces\n    function setTouchFlag () {\n        TOUCH_FLAG = true; // Set flag to prevent needless function calls\n        hoverLayer = []; // Drop hover layer references, kills events\n        svg.removeChild(hoverGroup); // Remove hover group from SVG\n        // Remove self when done\n        container.removeEventListener('touchstart', setTouchFlag);\n    }\n\n    // Initializes the SVG and draws the board\n    function initializeBoard(coord) {\n        drawBoard(coord); // Initialize the SVG element and draw the board\n\n        stoneGroup = besogo.svgEl(\"g\");\n        markupGroup = besogo.svgEl(\"g\");\n\n        svg.appendChild(stoneGroup); // Add placeholder group for stone layer\n        svg.appendChild(markupGroup); // Add placeholder group for markup layer\n\n        if (!TOUCH_FLAG) {\n            hoverGroup = besogo.svgEl(\"g\");\n            svg.appendChild(hoverGroup);\n        }\n\n        addEventTargets(); // Add mouse event listener layer\n\n        if (editor.REAL_STONES) { // Generate index for realistic stone images\n            randomizeIndex();\n        }\n    }\n\n    // Callback for board display redraws\n    function update(msg) {\n        var current = editor.getCurrent(),\n            currentSize = current.getSize(),\n            reinit = false, // Board redraw flag\n            oldSvg = svg;\n\n        // Check if board size has changed\n        if (currentSize.x !== sizeX || currentSize.y !== sizeY || msg.coord) {\n            sizeX = currentSize.x;\n            sizeY = currentSize.y;\n            initializeBoard(msg.coord || editor.getCoordStyle()); // Reinitialize board\n            container.replaceChild(svg, oldSvg);\n            reinit = true; // Flag board redrawn\n        }\n\n        // Redraw stones only if needed\n        if (reinit || msg.navChange || msg.stoneChange) {\n            redrawStones(current);\n            redrawMarkup(current);\n            redrawHover(current);\n        } else if (msg.markupChange) {\n            redrawMarkup(current);\n            redrawHover(current);\n        } else if (msg.tool || msg.label) {\n            redrawHover(current);\n        }\n    }\n\n    function redrawAll(current) {\n        redrawStones(current);\n        redrawMarkup(current);\n        redrawHover(current);\n    }\n\n    // Initializes the SVG element and draws the board\n    function drawBoard(coord) {\n        var boardWidth,\n            boardHeight,\n            string = \"\", // Path string for inner board lines\n            i; // Scratch iteration variable\n\n        BOARD_MARGIN = (coord === 'none' ? 0 : COORD_MARGIN) + EXTRA_MARGIN;\n        boardWidth = 2*BOARD_MARGIN + sizeX*CELL_SIZE;\n        boardHeight = 2*BOARD_MARGIN + sizeY*CELL_SIZE;\n\n        svg = besogo.svgEl(\"svg\", { // Initialize the SVG element\n            width: \"100%\",\n            height: \"100%\",\n            viewBox: \"0 0 \" + boardWidth + \" \" + boardHeight\n        });\n\n        svg.appendChild(besogo.svgEl(\"rect\", { // Fill background color\n            width: boardWidth,\n            height: boardHeight,\n            'class': 'besogo-svg-board'\n        }) );\n\n        svg.appendChild(besogo.svgEl(\"rect\", { // Draw outer square of board\n            width: CELL_SIZE*(sizeX - 1),\n            height: CELL_SIZE*(sizeY - 1),\n            x: svgPos(1),\n            y: svgPos(1),\n            'class': 'besogo-svg-lines'\n        }) );\n\n        for (i = 2; i <= (sizeY - 1); i++) { // Horizontal inner lines\n            string += \"M\" + svgPos(1) + \",\" + svgPos(i) + \"h\" + CELL_SIZE*(sizeX - 1);\n        }\n        for (i = 2; i <= (sizeX - 1); i++) { // Vertical inner lines\n            string += \"M\" + svgPos(i) + \",\" + svgPos(1) + \"v\" + CELL_SIZE*(sizeY - 1);\n        }\n        svg.appendChild( besogo.svgEl(\"path\", { // Draw inner lines of board\n            d: string,\n            'class': 'besogo-svg-lines'\n        }) );\n\n        drawHoshi(); // Draw the hoshi points\n        if (coord !== 'none') {\n            drawCoords(coord); // Draw the coordinate labels\n        }\n    }\n\n    // Draws coordinate labels on the board\n    function drawCoords(coord) {\n        var labels = besogo.coord[coord](sizeX, sizeY),\n            shift = COORD_MARGIN + 10,\n            i, x, y; // Scratch iteration variable\n\n        for (i = 1; i <= sizeX; i++) { // Draw column coordinate labels\n            x = svgPos(i);\n            drawCoordLabel(x, svgPos(1) - shift, labels.x[i]);\n            drawCoordLabel(x, svgPos(sizeY) + shift, labels.x[i]);\n        }\n\n        for (i = 1; i <= sizeY; i++) { // Draw row coordinate labels\n            y = svgPos(i);\n            drawCoordLabel(svgPos(1) - shift, y, labels.y[i]);\n            drawCoordLabel(svgPos(sizeX) + shift, y, labels.y[i]);\n        }\n\n        function drawCoordLabel(x, y, label) {\n            var element = besogo.svgEl(\"text\", {\n                x: x,\n                y: y,\n                dy: \".65ex\", // Seems to work for vertically centering these fonts\n                \"font-size\": 32,\n                \"text-anchor\": \"middle\", // Horizontal centering\n                \"font-family\": \"Helvetica, Arial, sans-serif\",\n                fill: 'black'\n            });\n            element.appendChild( document.createTextNode(label) );\n            svg.appendChild(element);\n        }\n    }\n\n    // Draws hoshi onto the board at procedurally generated locations\n    function drawHoshi() {\n        var cx, cy, // Center point calculation\n            pathStr = \"\"; // Path string for drawing star points\n\n        if (sizeX % 2 && sizeY % 2) { // Draw center hoshi if both dimensions are odd\n            cx = (sizeX - 1)/2 + 1; // Calculate the center of the board\n            cy = (sizeY - 1)/2 + 1;\n            drawStar(cx, cy);\n\n            if (sizeX >= 17 && sizeY >= 17) { // Draw side hoshi if at least 17x17 and odd\n                drawStar(4, cy);\n                drawStar(sizeX - 3, cy);\n                drawStar(cx, 4);\n                drawStar(cx, sizeY - 3);\n            }\n        }\n\n        if (sizeX >= 11 && sizeY >= 11) { // Corner hoshi at (4, 4) for larger sizes\n            drawStar(4, 4);\n            drawStar(4, sizeY - 3);\n            drawStar(sizeX - 3, 4);\n            drawStar(sizeX - 3, sizeY - 3);\n        } else if (sizeX >= 8 && sizeY >= 8) { // Corner hoshi at (3, 3) for medium sizes\n            drawStar(3, 3);\n            drawStar(3, sizeY - 2);\n            drawStar(sizeX - 2, 3);\n            drawStar(sizeX - 2, sizeY - 2);\n        } // No corner hoshi for smaller sizes\n\n        if (pathStr) { // Only need to add if hoshi drawn\n            svg.appendChild( besogo.svgEl('path', { // Drawing circles via path points\n                d: pathStr, // Hack to allow radius adjustment via stroke-width\n                'stroke-linecap': 'round', // Makes the points round\n                'class': 'besogo-svg-hoshi'\n            }) );\n        }\n\n        function drawStar(i, j) { // Extend path string to draw star point\n            pathStr += \"M\" + svgPos(i) + ',' + svgPos(j) + 'l0,0'; // Draws a point\n        }\n    }\n\n    // Remakes the randomized index for stone images\n    function randomizeIndex() {\n        var maxIndex = besogo.BLACK_STONES * besogo.WHITE_STONES,\n            i, j;\n\n        randIndex = [];\n        for (i = 1; i <= sizeX; i++) {\n            for (j = 1; j <= sizeY; j++) {\n                randIndex[fromXY(i, j)] = Math.floor(Math.random() * maxIndex);\n            }\n        }\n    }\n\n    // Adds a grid of squares to register mouse events\n    function addEventTargets() {\n        var element,\n            i, j;\n\n        for (i = 1; i <= sizeX; i++) {\n            for (j = 1; j <= sizeY; j++) {\n                element = besogo.svgEl(\"rect\", { // Make a transparent event target\n                    x: svgPos(i) - CELL_SIZE/2,\n                    y: svgPos(j) - CELL_SIZE/2,\n                    width: CELL_SIZE,\n                    height: CELL_SIZE,\n                    opacity: 0\n                });\n\n                // Add event listeners, using closures to decouple (i, j)\n                element.addEventListener(\"click\", handleClick(i, j));\n\n                if (!TOUCH_FLAG) { // Skip hover listeners for touch interfaces\n                    element.addEventListener(\"mouseover\", handleOver(i, j));\n                    element.addEventListener(\"mouseout\", handleOut(i, j));\n                }\n\n                svg.appendChild(element);\n            }\n        }\n    }\n\n    function handleClick(i, j) { // Returns function for click handling\n        return function(event) {\n            // Call click handler in editor\n            editor.click(i, j, event.ctrlKey, event.shiftKey);\n            if(!TOUCH_FLAG) {\n                (handleOver(i, j))(); // Ensures that any updated tool is visible\n            }\n        };\n    }\n    function handleOver(i, j) { // Returns function for mouse over\n        return function() {\n            var element = hoverLayer[ fromXY(i, j) ];\n            if (element) { // Make tool action visible on hover over\n                element.setAttribute('visibility', 'visible');\n            }\n        };\n    }\n    function handleOut(i, j) { // Returns function for mouse off\n        return function() {\n            var element = hoverLayer[ fromXY(i, j) ];\n            if (element) { // Make tool action invisible on hover off\n                element.setAttribute('visibility', 'hidden');\n            }\n        };\n    }\n\n    // Redraws the stones\n    function redrawStones(current) {\n        var group = besogo.svgEl(\"g\"), // New stone layer group\n            shadowGroup, // Group for shadow layer\n            i, j, x, y, color; // Scratch iteration variables\n\n        if (editor.SHADOWS) { // Add group for shawdows\n            shadowGroup = besogo.svgShadowGroup();\n            group.appendChild(shadowGroup);\n        }\n\n        for (i = 1; i <= sizeX; i++) {\n            for (j = 1; j <= sizeY; j++) {\n                color = current.getStone(i, j);\n                if (color) {\n                    x = svgPos(i);\n                    y = svgPos(j);\n\n                    if (editor.REAL_STONES) { // Realistic stone\n                        group.appendChild(besogo.realStone(x, y, color, randIndex[fromXY(i, j)]));\n                    } else { // SVG stone\n                        group.appendChild(besogo.svgStone(x, y, color));\n                    }\n\n                    if (editor.SHADOWS) { // Draw shadows\n                        shadowGroup.appendChild(besogo.svgShadow(x - 2, y - 4));\n                        shadowGroup.appendChild(besogo.svgShadow(x + 2, y + 4));\n                    }\n                }\n            }\n        }\n\n        svg.replaceChild(group, stoneGroup); // Replace the stone group\n        stoneGroup = group;\n    }\n\n    // Redraws the markup\n    function redrawMarkup(current) {\n        var element, i, j, x, y, // Scratch iteration variables\n            group = besogo.svgEl(\"g\"), // Group holding markup layer elements\n            lastMove = current.move,\n            variants = editor.getVariants(),\n            mark, // Scratch mark state {0, 1, 2, 3, 4, 5}\n            stone, // Scratch stone state {0, -1, 1}\n            color; // Scratch color string\n\n        markupLayer = []; // Clear the references to the old layer\n\n        for (i = 1; i <= sizeX; i++) {\n            for (j = 1; j <= sizeY; j++) {\n                mark = current.getMarkup(i, j);\n                if (mark) {\n                    x = svgPos(i);\n                    y = svgPos(j);\n                    stone = current.getStone(i, j);\n                    color = (stone === -1) ? \"white\" : \"black\"; // White on black\n                    if (lastMove && lastMove.x === i && lastMove.y === j) {\n                        // Mark last move blue or violet if also a variant\n                        color = checkVariants(variants, current, i, j) ?\n                            besogo.PURP : besogo.BLUE;\n                    } else if (checkVariants(variants, current, i, j)) {\n                        color = besogo.RED; // Natural variant marks are red\n                    }\n                    if (typeof mark === 'number') { // Markup is a basic shape\n                        switch(mark) {\n                            case 1:\n                                element = besogo.svgCircle(x, y, color);\n                                break;\n                            case 2:\n                                element = besogo.svgSquare(x, y, color);\n                                break;\n                            case 3:\n                                element = besogo.svgTriangle(x, y, color);\n                                break;\n                            case 4:\n                                element = besogo.svgCross(x, y, color);\n                                break;\n                            case 5:\n                                element = besogo.svgBlock(x, y, color);\n                                break;\n                        }\n                    } else { // Markup is a label\n                        if (!stone) { // If placing label on empty spot\n                            element = makeBacker(x, y);\n                            group.appendChild(element);\n                        }\n                        element = besogo.svgLabel(x, y, color, mark);\n                    }\n                    group.appendChild(element);\n                    markupLayer[ fromXY(i, j) ] = element;\n                } // END if (mark)\n            } // END for j\n        } // END for i\n\n        // Mark last move with plus if not already marked\n        if (lastMove && lastMove.x !== 0 && lastMove.y !== 0) {\n            i = lastMove.x;\n            j = lastMove.y;\n            if (!markupLayer[ fromXY(i, j) ]) { // Last move not marked\n                color = checkVariants(variants, current, i, j) ? besogo.PURP : besogo.BLUE;\n                element = besogo.svgPlus(svgPos(i), svgPos(j), color);\n                group.appendChild(element);\n                markupLayer[ fromXY(i, j) ] = element;\n            }\n        }\n\n        // Mark variants that have not already been marked above\n        markRemainingVariants(variants, current, group);\n\n        svg.replaceChild(group, markupGroup); // Replace the markup group\n        markupGroup = group;\n    } // END function redrawMarkup\n\n    function makeBacker(x, y) { // Makes a label markup backer at (x, y)\n        return besogo.svgEl(\"rect\", {\n            x: x - CELL_SIZE/2,\n            y: y - CELL_SIZE/2,\n            height: CELL_SIZE,\n            width: CELL_SIZE,\n            opacity: 0.85,\n            stroke: \"none\",\n            'class': 'besogo-svg-board'\n        });\n    }\n\n    // Checks if (x, y) is in variants\n    function checkVariants(variants, current, x, y) {\n        var i, move;\n        for (i = 0; i < variants.length; i++) {\n            if (variants[i] !== current) { // Skip current (within siblings)\n                move = variants[i].move;\n                if (move && move.x === x && move.y === y) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    // Marks variants that have not already been marked\n    function markRemainingVariants(variants, current, group) {\n        var element,\n            move, // Variant move\n            label, // Variant label\n            stone, // Stone state\n            i, x, y; // Scratch iteration variables\n\n        for (i = 0; i < variants.length; i++) {\n            if (variants[i] !== current) { // Skip current (within siblings)\n                move = variants[i].move;\n                // Check if move, not a pass, and no mark yet\n                if (move && move.x !== 0 && !markupLayer[ fromXY(move.x, move.y) ]) {\n                    stone = current.getStone(move.x, move.y);\n                    x = svgPos(move.x); // Get SVG positions\n                    y = svgPos(move.y);\n                    if (!stone) { // If placing label on empty spot\n                        element = makeBacker(x, y);\n                        group.appendChild(element);\n                    }\n                    // Label variants with letters A-Z cyclically\n                    label = String.fromCharCode('A'.charCodeAt(0) + (i % 26));\n                    element = besogo.svgLabel(x, y, besogo.LRED, label);\n                    group.appendChild(element);\n                    markupLayer[ fromXY(move.x, move.y) ] = element;\n                }\n            }\n        }\n    } // END function markRemainingVariants\n\n    // Redraws the hover layer\n    function redrawHover(current) {\n        if (TOUCH_FLAG) {\n            return; // Do nothing for touch interfaces\n        }\n\n        var element, i, j, x, y, // Scratch iteration variables\n            group = besogo.svgEl(\"g\"), // Group holding hover layer elements\n            tool = editor.getTool(),\n            children,\n            stone, // Scratch stone state {0, -1, 1} or move\n            color; // Scratch color string\n\n        hoverLayer = []; // Clear the references to the old layer\n        group.setAttribute('opacity', '0.35');\n\n        if (tool === 'navOnly') { // Render navOnly hover by iterating over children\n            children = current.children;\n            for (i = 0; i < children.length; i++) {\n                stone = children[i].move;\n                if (stone && stone.x !== 0) { // Child node is move and not a pass\n                    x = svgPos(stone.x);\n                    y = svgPos(stone.y);\n                    element = besogo.svgStone(x, y, stone.color);\n                    element.setAttribute('visibility', 'hidden');\n                    group.appendChild(element);\n\n                }\n            }\n        } else { // Render hover for other tools by iterating over grid\n            for (i = 1; i <= sizeX; i++) {\n                for (j = 1; j <= sizeY; j++) {\n                    element = null;\n                    x = svgPos(i);\n                    y = svgPos(j);\n                    stone = current.getStone(i, j);\n                    color = (stone === -1) ? \"white\" : \"black\"; // White on black\n                    switch(tool) {\n                        case 'auto':\n                            element = besogo.svgStone(x, y, current.nextToMove);\n                            break;\n                        case 'playB':\n                            element = besogo.svgStone(x, y, -1);\n                            break;\n                        case 'playW':\n                            element = besogo.svgStone(x, y, 1);\n                            break;\n                        case 'addB':\n                            if (stone === -1) {\n                                element = besogo.svgCross(x, y, besogo.RED);\n                            } else {\n                                element = besogo.svgEl('g');\n                                element.appendChild(besogo.svgStone(x, y, -1));\n                                element.appendChild(besogo.svgPlus(x, y, besogo.RED));\n                            }\n                            break;\n                        case 'addW':\n                            if (stone === 1) {\n                                element = besogo.svgCross(x, y, besogo.RED);\n                            } else {\n                                element = besogo.svgEl('g');\n                                element.appendChild(besogo.svgStone(x, y, 1));\n                                element.appendChild(besogo.svgPlus(x, y, besogo.RED));\n                            }\n                            break;\n                        case 'addE':\n                            if (stone) {\n                                element = besogo.svgCross(x, y, besogo.RED);\n                            }\n                            break;\n                        case 'clrMark':\n                            break; // Nothing\n                        case 'circle':\n                            element = besogo.svgCircle(x, y, color);\n                            break;\n                        case 'square':\n                            element = besogo.svgSquare(x, y, color);\n                            break;\n                        case 'triangle':\n                            element = besogo.svgTriangle(x, y, color);\n                            break;\n                        case 'cross':\n                            element = besogo.svgCross(x, y, color);\n                            break;\n                        case 'block':\n                            element = besogo.svgBlock(x, y, color);\n                            break;\n                        case 'label':\n                            element = besogo.svgLabel(x, y, color, editor.getLabel());\n                            break;\n                    } // END switch (tool)\n                    if (element) {\n                        element.setAttribute('visibility', 'hidden');\n                        group.appendChild(element);\n                        hoverLayer[ fromXY(i, j) ] = element;\n                    }\n                } // END for j\n            } // END for i\n        } // END else\n\n        svg.replaceChild(group, hoverGroup); // Replace the hover layer group\n        hoverGroup = group;\n    } // END function redrawHover\n\n    function svgPos(x) {  // Converts (x, y) coordinates to SVG position\n        return BOARD_MARGIN + CELL_SIZE/2 + (x-1) * CELL_SIZE;\n    }\n\n    function fromXY(x, y) { // Converts (x, y) coordinates to linear index\n        return (x - 1)*sizeY + (y - 1);\n    }\n};\nbesogo.makeCommentPanel = function(container, editor) {\n    'use strict';\n    var infoTexts = {}, // Holds text nodes for game info properties\n        gameInfoTable = document.createElement('table'),\n        gameInfoEdit = document.createElement('table'),\n        commentBox = document.createElement('div'),\n        commentEdit = document.createElement('textarea'),\n        playerInfoOrder = 'PW WR WT PB BR BT'.split(' '),\n        infoOrder = 'HA KM RU TM OT GN EV PC RO DT RE ON GC AN US SO CP'.split(' '),\n        infoIds = {\n            PW: 'White Player',\n            WR: 'White Rank',\n            WT: 'White Team',\n            PB: 'Black Player',\n            BR: 'Black Rank',\n            BT: 'Black Team',\n\n            HA: 'Handicap',\n            KM: 'Komi',\n            RU: 'Rules',\n            TM: 'Timing',\n            OT: 'Overtime',\n\n            GN: 'Game Name',\n            EV: 'Event',\n            PC: 'Place',\n            RO: 'Round',\n            DT: 'Date',\n\n            RE: 'Result',\n            ON: 'Opening',\n            GC: 'Comments',\n\n            AN: 'Annotator',\n            US: 'Recorder',\n            SO: 'Source',\n            CP: 'Copyright'\n        };\n\n    container.appendChild(makeInfoButton());\n    container.appendChild(makeInfoEditButton());\n    container.appendChild(makeCommentButton());\n    container.appendChild(gameInfoTable);\n    container.appendChild(gameInfoEdit);\n    infoTexts.C = document.createTextNode('');\n    container.appendChild(commentBox);\n    commentBox.appendChild(infoTexts.C);\n    container.appendChild(commentEdit);\n\n    commentEdit.onblur = function() {\n        editor.setComment(commentEdit.value);\n    };\n    commentEdit.addEventListener('keydown', function(evt) {\n        evt = evt || window.event;\n        evt.stopPropagation(); // Stop keydown propagation when in focus\n    });\n\n    editor.addListener(update);\n    update({ navChange: true, gameInfo: editor.getGameInfo() });\n    gameInfoEdit.style.display = 'none'; // Hide game info editting table initially\n\n    function update(msg) {\n        var temp; // Scratch for strings\n\n        if (msg.navChange) {\n            temp = editor.getCurrent().comment || '';\n            updateText(commentBox, temp, 'C');\n            if (editor.getCurrent() === editor.getRoot() &&\n                gameInfoTable.firstChild &&\n                gameInfoEdit.style.display === 'none') {\n                    gameInfoTable.style.display = 'table';\n            } else {\n                gameInfoTable.style.display = 'none';\n            }\n            commentEdit.style.display = 'none';\n            commentBox.style.display = 'block';\n        } else if (msg.comment !== undefined) {\n            updateText(commentBox, msg.comment, 'C');\n            commentEdit.value = msg.comment;\n        }\n\n        if (msg.gameInfo) { // Update game info\n            updateGameInfoTable(msg.gameInfo);\n            updateGameInfoEdit(msg.gameInfo);\n        }\n    } // END function update\n\n    function updateGameInfoTable(gameInfo) {\n        var table = document.createElement('table'),\n            i, id, row, cell, text; // Scratch iteration variable\n\n        table.className = 'besogo-gameInfo';\n        for (i = 0; i < infoOrder.length ; i++) { // Iterate in specified order\n            id = infoOrder[i];\n\n            if (gameInfo[id]) { // Only add row if property exists\n                row = document.createElement('tr');\n                table.appendChild(row);\n\n                cell = document.createElement('td');\n                cell.appendChild(document.createTextNode(infoIds[id]));\n                row.appendChild(cell);\n\n                cell = document.createElement('td');\n                text = document.createTextNode(gameInfo[id]);\n                cell.appendChild(text);\n                row.appendChild(cell);\n            }\n        }\n        if (!table.firstChild || gameInfoTable.style.display === 'none') {\n            table.style.display = 'none'; // Do not display empty table or if already hidden\n        }\n        container.replaceChild(table, gameInfoTable);\n        gameInfoTable = table;\n    }\n    \n    function updateGameInfoEdit(gameInfo) {\n        var table = document.createElement('table'),\n            infoTableOrder = playerInfoOrder.concat(infoOrder),\n            i, id, row, cell, text;\n\n        table.className = 'besogo-gameInfo';\n        for (i = 0; i < infoTableOrder.length ; i++) { // Iterate in specified order\n            id = infoTableOrder[i];\n            row = document.createElement('tr');\n            table.appendChild(row);\n            \n            cell = document.createElement('td');\n            cell.appendChild(document.createTextNode(infoIds[id]));\n            row.appendChild(cell);\n\n            cell = document.createElement('td');\n            text = document.createElement('input');\n            if (gameInfo[id]) {\n                text.value = gameInfo[id];\n            }\n            text.onblur = function(t, id) {\n                return function() { // Commit change on blur\n                    editor.setGameInfo(t.value, id);\n                };\n            }(text, id);\n            text.addEventListener('keydown', function(evt) {\n                evt = evt || window.event;\n                evt.stopPropagation(); // Stop keydown propagation when in focus\n            });\n            cell.appendChild(text);\n            row.appendChild(cell);\n        }\n        if (gameInfoEdit.style.display === 'none') {\n            table.style.display = 'none'; // Hide if already hidden\n        }\n        container.replaceChild(table, gameInfoEdit);\n        gameInfoEdit = table;\n    }\n\n    function updateText(parent, text, id) {\n        var textNode = document.createTextNode(text);\n        parent.replaceChild(textNode, infoTexts[id]);\n        infoTexts[id] = textNode;\n    }\n\n    function makeInfoButton() {\n        var button = document.createElement('input');\n        button.type = 'button';\n        button.value = 'Info';\n        button.title = 'Show/hide game info';\n\n        button.onclick = function() {\n            if (gameInfoTable.style.display === 'none' && gameInfoTable.firstChild) {\n                gameInfoTable.style.display = 'table';\n            } else {\n                gameInfoTable.style.display = 'none';\n            }\n            gameInfoEdit.style.display = 'none';\n        };\n        return button;\n    }\n\n    function makeInfoEditButton() {\n        var button = document.createElement('input');\n        button.type = 'button';\n        button.value = 'Edit Info';\n        button.title = 'Edit game info';\n\n        button.onclick = function() {\n            if (gameInfoEdit.style.display === 'none') {\n                gameInfoEdit.style.display = 'table';\n            } else {\n                gameInfoEdit.style.display = 'none';\n            }\n            gameInfoTable.style.display = 'none';\n        };\n        return button;\n    }\n\n    function makeCommentButton() {\n        var button = document.createElement('input');\n        button.type = 'button';\n        button.value = 'Comment';\n        button.title = 'Edit comment';\n\n        button.onclick = function() {\n            if (commentEdit.style.display === 'none') { // Comment edit box hidden\n                commentBox.style.display = 'none'; // Hide static comment display\n                gameInfoTable.style.display = 'none'; // Hide game info table\n                commentEdit.value = editor.getCurrent().comment;\n                commentEdit.style.display = 'block'; // Show comment edit box\n            } else { // Comment edit box open\n                commentEdit.style.display = 'none'; // Hide comment edit box\n                commentBox.style.display = 'block'; // Show static comment display\n            }\n        };\n        return button;\n    }\n\n};\nbesogo.makeControlPanel = function(container, editor) {\n    'use strict';\n    var leftElements = [], // SVG elements for previous node buttons\n        rightElements = [], // SVG elements for next node buttons\n        siblingElements = [], // SVG elements for sibling buttons\n        variantStyleButton, // Button for changing variant style\n        hideVariantButton, // Button for toggling show/hide variants\n        childVariantElement, // SVG element for child style variants\n        siblingVariantElement, // SVG element for sibling style variants\n        hideVariantElement; // SVG element for hiding variants\n\n    drawNavButtons();\n    drawStyleButtons();\n\n    editor.addListener(update);\n    update({ navChange: true, variantStyle: editor.getVariantStyle() }); // Initialize\n\n    // Callback for variant style and nav state changes\n    function update(msg) {\n        var current;\n\n        if (msg.variantStyle !== undefined) {\n            updateStyleButtons(msg.variantStyle);\n        }\n\n        if (msg.navChange || msg.treeChange) { // Update the navigation buttons\n            current = editor.getCurrent();\n            if (current.parent) { // Has parent\n                arraySetColor(leftElements, 'black');\n                if (current.parent.children.length > 1) { // Has siblings\n                    arraySetColor(siblingElements, 'black');\n                } else { // No siblings\n                    arraySetColor(siblingElements, besogo.GREY);\n                }\n            } else { // No parent\n                arraySetColor(leftElements, besogo.GREY);\n                arraySetColor(siblingElements, besogo.GREY);\n            }\n            if (current.children.length) { // Has children\n                arraySetColor(rightElements, 'black');\n\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.borderColor = playerColor;\n            } else { // No children\n                arraySetColor(rightElements, besogo.GREY);\n\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.borderColor = \"limegreen\";\n            }\n        }\n\n        function updateStyleButtons(style) { // Updates the variant style buttons\n            if (style % 2) { // Sibling style variants\n                childVariantElement.setAttribute('fill', 'black');\n                siblingVariantElement.setAttribute('fill', besogo.BLUE);\n                variantStyleButton.title = 'Variants: child/[sibling]';\n            } else { // Child style variants\n                childVariantElement.setAttribute('fill', besogo.BLUE);\n                siblingVariantElement.setAttribute('fill', besogo.RED);\n                variantStyleButton.title = 'Variants: [child]/sibling';\n            }\n            if (style >= 2) { // Hide auto-markup for variants\n                hideVariantElement.setAttribute('visibility', 'visible');\n                hideVariantButton.title = 'Variants: show/[hide]';\n            } else { // Show auto-markup for variants\n                hideVariantElement.setAttribute('visibility', 'hidden');\n                hideVariantButton.title = 'Variants: [show]/hide';\n            }\n        }\n\n        function arraySetColor(list, color) { // Changes fill color of list of svg elements\n            var i;\n            for (i = 0; i < list.length; i++) {\n                list[i].setAttribute('fill', color);\n            }\n        }\n    } // END function update\n\n    // Draws the navigation buttons\n    function drawNavButtons() {\n        leftElements.push(makeNavButton('First node',\n            '5,10 5,90 25,90 25,50 95,90 95,10 25,50 25,10',\n            function() {\n                editor.prevNode(-1);\n            })\n        );\n        leftElements.push(makeNavButton('Jump back',\n            '95,10 50,50 50,10 5,50 50,90 50,50 95,90',\n            function() {\n                editor.prevNode(10);\n            })\n        );\n        leftElements.push(makeNavButton('Previous node', '85,10 85,90 15,50', function() {\n            editor.prevNode(1);\n        }));\n\n        rightElements.push(makeNavButton('Next node', '15,10 15,90 85,50', function() {\n            editor.nextNode(1);\n        }));\n        rightElements.push(makeNavButton('Jump forward',\n            '5,10 50,50 50,10 95,50 50,90 50,50 5,90',\n            function() {\n                editor.nextNode(10);\n            })\n        );\n        rightElements.push(makeNavButton('Last node',\n            '95,10 95,90 75,90 75,50 5,90 5,10 75,50 75,10',\n            function() {\n                editor.nextNode(-1);\n            })\n        );\n\n        siblingElements.push(makeNavButton('Previous sibling', '10,85 90,85 50,15', function() {\n            editor.nextSibling(-1);\n        }));\n        siblingElements.push(makeNavButton('Next sibling', '10,15 90,15 50,85', function() {\n            editor.nextSibling(1);\n        }));\n\n        function makeNavButton(tooltip, pointString, action) { // Creates a navigation button\n            var button = document.createElement('button'),\n                svg = makeButtonContainer(),\n                element = besogo.svgEl(\"polygon\", {\n                    points: pointString,\n                    stroke: 'none',\n                    fill: 'black'\n                });\n\n            button.title = tooltip;\n            button.onclick = action;\n            button.appendChild(svg);\n            svg.appendChild(element);\n            container.appendChild(button);\n\n            return element;\n        } // END function makeNavButton\n    } // END function drawNavButtons\n\n    // Draws the variant style buttons\n    function drawStyleButtons() {\n        var svg, element, coordStyleButton;\n\n        variantStyleButton = document.createElement('button');\n        variantStyleButton.onclick = function() {\n            editor.toggleVariantStyle(false); // Toggles child/sibling variants\n        };\n        container.appendChild(variantStyleButton);\n        svg = makeButtonContainer();\n        variantStyleButton.appendChild(svg);\n        element = besogo.svgEl(\"path\", {\n            d: 'm75,25h-50l50,50',\n            stroke: 'black',\n            \"stroke-width\": 5,\n            fill: 'none'\n        });\n        svg.appendChild(element);\n        childVariantElement = besogo.svgEl('circle', {\n            cx: 25,\n            cy: 25,\n            r: 20,\n            stroke: 'none'\n        });\n        svg.appendChild(childVariantElement);\n        siblingVariantElement = besogo.svgEl('circle', {\n            cx: 75,\n            cy: 25,\n            r: 20,\n            stroke: 'none'});\n        svg.appendChild(siblingVariantElement);\n        element = besogo.svgEl('circle', {\n            cx: 75,\n            cy: 75,\n            r: 20,\n            fill: besogo.RED,\n            stroke: 'none'\n        });\n        svg.appendChild(element);\n\n        hideVariantButton = document.createElement('button');\n        hideVariantButton.onclick = function() {\n            editor.toggleVariantStyle(true); // Toggles show/hide variants\n        };\n        container.appendChild(hideVariantButton);\n        svg = makeButtonContainer();\n        hideVariantButton.appendChild(svg);\n        svg.appendChild(besogo.svgLabel(50, 50, besogo.RED, 'A'));\n        hideVariantElement = besogo.svgCross(50, 50, 'black');\n        svg.appendChild(hideVariantElement);\n\n        coordStyleButton = document.createElement('button');\n        coordStyleButton.onclick = function() {\n            editor.toggleCoordStyle(); // Toggles coordinate style\n        };\n        coordStyleButton.title = 'Toggle coordinates';\n        container.appendChild(coordStyleButton);\n        svg = makeButtonContainer();\n        coordStyleButton.appendChild(svg);\n        svg.appendChild(besogo.svgLabel(50, 50, 'black', '四4'));\n    } // END function drawStyleButtons\n\n    // Makes an SVG container for the button graphics\n    function makeButtonContainer() {\n        return besogo.svgEl('svg', {\n            width: '100%',\n            height: '100%',\n            viewBox: \"0 0 100 100\"\n        });\n    }\n};\n(function() {\n'use strict';\n\n// Parent object to hold coordinate system helper functions\nbesogo.coord = {};\n\n// Null function for no coordinate system\nbesogo.coord.none = function(sizeX, sizeY) {\n    return false;\n};\n\n// Western, chess-like, \"A1\" coordinate system\nbesogo.coord.western = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        labels.x[i] = numberToLetter(i);\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = (sizeY - i + 1) + '';\n    }\n    return labels;\n};\n\n// Simple purely numeric coordinate system\nbesogo.coord.numeric = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        labels.x[i] = i + '';\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = i + '';\n    }\n    return labels;\n};\n\n// Corner-relative, alpha-numeric, coordinate system\nbesogo.coord.corner = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        if (i < (sizeX / 2) + 1) {\n            labels.x[i] = numberToLetter(i);\n        } else {\n            labels.x[i] = (sizeX - i + 1) + '';\n        }\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = (sizeY - i + 1) + '';\n        if (i > (sizeY / 2)) {\n            labels.y[i] = numberToLetter(sizeY - i + 1);\n        } else {\n            labels.y[i] = i + '';\n        }\n    }\n    return labels;\n};\n\n// Corner-relative, numeric and CJK, coordinate system\nbesogo.coord.eastcor = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        if (i < (sizeX / 2) + 1) {\n            labels.x[i] = numberToCJK(i);\n        } else {\n            labels.x[i] = (sizeX - i + 1) + '';\n        }\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = (sizeY - i + 1) + '';\n        if (i > (sizeY / 2)) {\n            labels.y[i] = numberToCJK(sizeY - i + 1);\n        } else {\n            labels.y[i] = i + '';\n        }\n    }\n    return labels;\n};\n\n// Eastern, numeric and CJK, coordinate system\nbesogo.coord.eastern = function(sizeX, sizeY) {\n    var labels = { x: [], y: [] }, i;\n    for (i = 1; i <= sizeX; i++) {\n        labels.x[i] = i + ''; // Columns are numeric\n    }\n    for (i = 1; i <= sizeY; i++) {\n        labels.y[i] = numberToCJK(i);\n    }\n\n    return labels;\n};\n\n// Helper for converting numeric coord to letter (skipping I)\nfunction numberToLetter(number) {\n    return 'ABCDEFGHJKLMNOPQRSTUVWXYZ'.charAt((number - 1) % 25);\n}\n\n// Helper for converting numeric coord to CJK symbol\nfunction numberToCJK(number) {\n    var label = '',\n        cjk = '一二三四五六七八九';\n    \n    if (number >= 20) { // 20 and larger\n        label = cjk.charAt(number / 10 - 1) + '十';\n    } else if (number >= 10) { // 10 through 19\n        label = '十';\n    }\n    if (number % 10) { // Ones digit if non-zero\n        label = label + cjk.charAt((number - 1) % 10);\n    }\n    return label;\n}\n\n})(); // END closure\nbesogo.makeEditor = function(sizeX, sizeY) {\n    'use strict';\n    // Creates an associated game state tree\n    var root = besogo.makeGameRoot(sizeX, sizeY),\n        current = root, // Navigation cursor\n\n        listeners = [], // Listeners of general game/editor state changes\n\n        // Enumeration of editor tools/modes\n        TOOLS = ['navOnly', // read-only navigate mode\n            'auto', // auto-mode: navigate or auto-play color\n            'playB', // play black stone\n            'playW', // play white stone\n            'addB', // setup black stone\n            'addW', // setup white stone\n            'addE', // setup empty stone\n            'clrMark', // remove markup\n            'circle', // circle markup\n            'square', // square markup\n            'triangle', // triangle markup\n            'cross', // \"X\" cross markup\n            'block', // filled square markup\n            'label'], // label markup\n        tool = 'auto', // Currently active tool (default: auto-mode)\n        label = \"1\", // Next label that will be applied\n\n        navHistory = [], // Navigation history\n\n        gameInfo = {}, // Game info properties\n\n        // Order of coordinate systems\n        COORDS = 'none numeric western eastern corner eastcor'.split(' '),\n        coord = 'none', // Selected coordinate system\n\n        // Variant style: even/odd - children/siblings, <2 - show auto markup for variants\n        variantStyle = 2; // 0-3, 0 is default\n\n    return {\n        addListener: addListener,\n        click: click,\n        nextNode: nextNode,\n        prevNode: prevNode,\n        nextSibling: nextSibling,\n        toggleCoordStyle: toggleCoordStyle,\n        getCoordStyle: getCoordStyle,\n        setCoordStyle: setCoordStyle,\n        toggleVariantStyle: toggleVariantStyle,\n        getVariantStyle: getVariantStyle,\n        setVariantStyle: setVariantStyle,\n        getGameInfo: getGameInfo,\n        setGameInfo: setGameInfo,\n        setComment: setComment,\n        getTool: getTool,\n        setTool: setTool,\n        getLabel: getLabel,\n        setLabel: setLabel,\n        getVariants: getVariants, // Returns variants of current node\n        getCurrent: getCurrent,\n        setCurrent: setCurrent,\n        cutCurrent: cutCurrent,\n        getRoot: getRoot,\n        loadRoot: loadRoot // Loads new game state\n    };\n\n    // Returns the active tool\n    function getTool() {\n        return tool;\n    }\n\n    // Sets the active tool, returns false if failed\n    function setTool(set) {\n        // Toggle label mode if already label tool already selected\n        if (set === 'label' && set === tool) {\n            if ( /^-?\\d+$/.test(label) ) { // If current label is integer\n                setLabel('A'); // Toggle to characters\n            } else {\n                setLabel('1'); // Toggle back to numbers\n            }\n            return true; // Notification already handled by setLabel\n        }\n        // Set the tool only if in list and actually changed\n        if (TOOLS.indexOf(set) !== -1 && tool !== set) {\n            tool = set;\n            notifyListeners({ tool: tool, label: label }); // Notify tool change\n            return true;\n        }\n        return false;\n    }\n\n    // Gets the next label to apply\n    function getLabel() {\n        return label;\n    }\n\n    // Sets the next label to apply and sets active tool to label\n    function setLabel(set) {\n        if (typeof set === 'string') {\n            set = set.replace(/\\s/g, ' ').trim(); // Convert all whitespace to space and trim\n            label = set || \"1\"; // Default to \"1\" if empty string\n            tool = 'label'; // Also change current tool to label\n            notifyListeners({ tool: tool, label: label }); // Notify tool/label change\n        }\n    }\n\n    // Toggle the coordinate style\n    function toggleCoordStyle() {\n        coord = COORDS[(COORDS.indexOf(coord) + 1) % COORDS.length];\n        notifyListeners({ coord: coord });\n    }\n\n    // Gets the current coordinate style\n    function getCoordStyle() {\n        return coord;\n    }\n\n    // Sets the coordinate system style\n    function setCoordStyle(setCoord) {\n        if (besogo.coord[setCoord]) {\n            coord = setCoord;\n            notifyListeners({ coord: setCoord });\n        }\n    }\n\n    // Toggles the style for showing variants\n    function toggleVariantStyle(toggleShow) {\n        var childStyle = variantStyle % 2, // 0: children, 1: siblings\n            showStyle = variantStyle - childStyle; // 0: show auto-markup, 2: hide\n        if (toggleShow) { // Truthy input toggles showing of auto-markup\n            showStyle = (showStyle + 2) % 4; // 0 => 2 or 2 => 0\n        } else { // Falsy input toggles child vs sibling style\n            childStyle = (childStyle + 1) % 2; // 0 => 1 or 1 => 0\n        }\n        variantStyle = childStyle + showStyle;\n        notifyListeners({ variantStyle: variantStyle, markupChange: true });\n    }\n\n    // Returns the variant style\n    function getVariantStyle() {\n        return variantStyle;\n    }\n\n    // Directly sets the variant style\n    function setVariantStyle(style) {\n        if (style === 0 || style === 1 || style === 2 || style === 3) {\n            variantStyle = 3;\n            notifyListeners({ variantStyle: variantStyle, markupChange: true });\n        }\n    }\n\n    function getGameInfo() {\n        return gameInfo;\n    }\n\n    function setGameInfo(info, id) {\n        if (id) {\n            gameInfo[id] = info;\n        } else {\n            gameInfo = info;\n        }\n        notifyListeners({ gameInfo: gameInfo });\n    }\n\n    function setComment(text) {\n        text = text.trim(); // Trim whitespace and standardize line breaks\n        text = text.replace(/\\r\\n/g,'\\n').replace(/\\n\\r/g,'\\n').replace(/\\r/g,'\\n');\n        text.replace(/\\f\\t\\v\\u0085\\u00a0/g,' '); // Convert other whitespace to space\n        current.comment = text;\n        notifyListeners({ comment: text });\n    }\n\n    // Returns variants of the current node according to the set style\n    function getVariants() {\n        if (variantStyle >= 2) { // Do not show variants if style >= 2\n            return [];\n        }\n        if (variantStyle === 1) { // Display sibling variants\n            // Root node does not have parent nor siblings\n            return current.parent ? current.parent.children : [];\n        }\n        return current.children; // Otherwise, style must be 0, display child variants\n    }\n\n    // Returns the currently active node in the game state tree\n    function getCurrent() {\n        return current;\n    }\n\n    // Returns the root of the game state tree\n    function getRoot() {\n        return root;\n    }\n\n    function loadRoot(load) {\n        root = load;\n        current = load;\n        notifyListeners({ treeChange: true, navChange: true, stoneChange: true });\n    }\n\n    // Navigates forward num nodes (to the end if num === -1)\n    function nextNode(num) {\n        if (current.children.length === 0) { // Check if no children\n            return false; // Do nothing if no children (avoid notification)\n        }\n        while (current.children.length > 0 && num !== 0) {\n            if (navHistory.length) { // Non-empty navigation history\n                current = navHistory.pop();\n            } else { // Empty navigation history\n                current = current.children[0]; // Go to first child\n            }\n            num--;\n        }\n        // Notify listeners of navigation (with no tree edits)\n        notifyListeners({ navChange: true }, true); // Preserve history\n    }\n\n    // Navigates backward num nodes (to the root if num === -1)\n    function prevNode(num) {\n        if (current.parent === null) { // Check if root\n            return false; // Do nothing if already at root (avoid notification)\n        }\n        while (current.parent && num !== 0) {\n            navHistory.push(current); // Save current into navigation history\n            current = current.parent;\n            num--;\n        }\n        // Notify listeners of navigation (with no tree edits)\n        notifyListeners({ navChange: true }, true); // Preserve history\n    }\n\n    // Cyclically switches through siblings\n    function nextSibling(change) {\n        var siblings,\n            i = 0;\n\n        if (current.parent) {\n            siblings = current.parent.children;\n\n            // Exit early if only child\n            if (siblings.length === 1) {\n                return;\n            }\n\n            // Find index of current amongst siblings\n            i = siblings.indexOf(current);\n\n            // Apply change cyclically\n            i = (i + change) % siblings.length;\n            if (i < 0) {\n                i += siblings.length;\n            }\n\n            current = siblings[i];\n            // Notify listeners of navigation (with no tree edits)\n            notifyListeners({ navChange: true });\n        }\n    }\n\n    // Sets the current node\n    function setCurrent(node) {\n        if (current !== node) {\n            current = node;\n            // Notify listeners of navigation (with no tree edits)\n            notifyListeners({ navChange: true });\n        }\n    }\n\n    // Removes current branch from the tree\n    function cutCurrent() {\n        var parent = current.parent;\n        if (tool === 'navOnly') {\n            return; // Tree editing disabled in navOnly mode\n        }\n        if (parent) {\n            if (confirm(\"Delete this branch?\") === true) {\n                parent.removeChild(current);\n                current = parent;\n                // Notify navigation and tree edited\n                notifyListeners({ treeChange: true, navChange: true });\n            }\n        }\n    }\n\n    // Handle click with application of selected tool\n    function click(i, j, ctrlKey, shiftKey) {\n        switch(tool) {\n            case 'navOnly':\n                navigate(i, j);\n                break;\n            case 'auto':\n                if (!navigate(i, j, shiftKey) && !shiftKey) { // Try to navigate to (i, j)\n                    playMove(i, j, 0, ctrlKey); // Play auto-color move if navigate fails\n                }\n                break;\n            case 'playB':\n                playMove(i, j, -1, ctrlKey); // Black move\n                break;\n            case 'playW':\n                playMove(i, j, 1, ctrlKey); // White move\n                break;\n            case 'addB':\n                placeSetup(i, j, -1);\n                break;\n            case 'addW':\n                placeSetup(i, j, 1);\n                break;\n            case 'addE':\n                placeSetup(i, j, 0);\n                break;\n            case 'clrMark':\n                setMarkup(i, j, 0);\n                break;\n            case 'circle':\n                setMarkup(i, j, 1);\n                break;\n            case 'square':\n                setMarkup(i, j, 2);\n                break;\n            case 'triangle':\n                setMarkup(i, j, 3);\n                break;\n            case 'cross':\n                setMarkup(i, j, 4);\n                break;\n            case 'block':\n                setMarkup(i, j, 5);\n                break;\n            case 'label':\n                setMarkup(i, j, label);\n                break;\n        }\n    }\n\n    // Navigates to child with move at (x, y), searching tree if shiftKey pressed\n    // Returns true is successful, false if not\n    function navigate(x, y, shiftKey) {\n        var i, move,\n            children = current.children;\n\n        // Look for move at same location in children\n        for (i = 0; i < children.length; i++) {\n            move = children[i].move;\n            if (move && move.x === x && move.y === y) {\n                current = children[i]; // Navigate to child if found\n                // Notify navigation (with no tree edits)\n                notifyListeners({ navChange: true });\n\t\t\t\tdocument.getElementsByClassName(\"besogo-diagram\")[0].style.pointerEvents = \"none\";\n\t\t\t\tsetTimeout(function(){ document.querySelector('[title=\"Next node\"]').click(); document.getElementsByClassName(\"besogo-diagram\")[0].style.pointerEvents = \"auto\";}, 400);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Plays a move at the given color and location\n    // Set allowAll to truthy to allow illegal moves\n    function playMove(i, j, color, allowAll) {\n        var next;\n        // Check if current node is immutable or root\n        if ( !current.isMutable('move') || !current.parent ) {\n            next = current.makeChild(); // Create a new child node\n            if (next.playMove(i, j, color, allowAll)) { // Play in new node\n                // Keep (add to game state tree) only if move succeeds\n                current.addChild(next);\n                current = next;\n                // Notify tree change, navigation, and stone change\n                notifyListeners({ treeChange: true, navChange: true, stoneChange: true });\n            }\n        // Current node is mutable and not root\n        } else if(current.playMove(i, j, color, allowAll)) { // Play in current\n            // Only need to update if move succeeds\n            notifyListeners({ stoneChange: true }); // Stones changed\n        }\n    }\n\n    // Places a setup stone at the given color and location\n    function placeSetup(i, j, color) {\n        var next;\n        if (color === current.getStone(i, j)) { // Compare setup to current\n            if (color !== 0) {\n                color = 0; // Same as current indicates removal desired\n            } else { // Color and current are both empty\n                return; // No change if attempting to set empty to empty\n            }\n        }\n        // Check if current node can accept setup stones\n        if (!current.isMutable('setup')) {\n            next = current.makeChild(); // Create a new child node\n            if (next.placeSetup(i, j, color)) { // Place setup stone in new node\n                // Keep (add to game state tree) only if change occurs\n                current.addChild(next);\n                current = next;\n                // Notify tree change, navigation, and stone change\n                notifyListeners({ treeChange: true, navChange: true, stoneChange: true });\n            }\n        } else if(current.placeSetup(i, j, color)) { // Try setup in current\n            // Only need to update if change occurs\n            notifyListeners({ stoneChange: true }); // Stones changed\n        }\n    }\n\n    // Sets the markup at the given location and place\n    function setMarkup(i, j, mark) {\n        var temp; // For label incrementing\n        if (mark === current.getMarkup(i, j)) { // Compare mark to current\n            if (mark !== 0) {\n                mark = 0; // Same as current indicates removal desired\n            } else { // Mark and current are both empty\n                return; // No change if attempting to set empty to empty\n            }\n        }\n        if (current.addMarkup(i, j, mark)) { // Try to add the markup\n            if (typeof mark === 'string') { // If markup is a label, increment the label\n                if (/^-?\\d+$/.test(mark)) { // Integer number label\n                    temp = +mark; // Convert to number\n                    // Increment and convert back to string\n                    setLabel( \"\" + (temp + 1) );\n                } else if ( /[A-Za-z]$/.test(mark) ) { // Ends with [A-Za-z]\n                    // Get the last character in the label\n                    temp = mark.charAt(mark.length - 1);\n                    if (temp === 'z') { // Cyclical increment\n                        temp = 'A'; // Move onto uppercase letters\n                    } else if (temp === 'Z') {\n                        temp = 'a'; // Move onto lowercase letters\n                    } else {\n                        temp = String.fromCharCode(temp.charCodeAt() + 1);\n                    }\n                    // Replace last character of label with incremented char\n                    setLabel( mark.slice(0, mark.length - 1) + temp );\n                }\n            }\n            notifyListeners({ markupChange: true }); // Notify markup change\n        }\n    }\n\n    // Adds a listener (by call back func) that will be notified on game/editor state changes\n    function addListener(listener) {\n        listeners.push(listener);\n    }\n\n    // Notify listeners with the given message object\n    //  Data sent to listeners:\n    //    tool: changed tool selection\n    //    label: changed next label\n    //    coord: changed coordinate system \n    //    variantStyle: changed variant style\n    //    gameInfo: changed game info\n    //    comment: changed comment in current node\n    //  Flags sent to listeners:\n    //    treeChange: nodes added or removed from tree\n    //    navChange: current switched to different node\n    //    stoneChange: stones modified in current node\n    //    markupChange: markup modified in current node\n    function notifyListeners(msg, keepHistory) {\n        var i;\n        if (!keepHistory && msg.navChange) {\n            navHistory = []; // Clear navigation history\n        }\n        for (i = 0; i < listeners.length; i++) {\n            listeners[i](msg);\n        }\n    }\n};\nbesogo.makeFilePanel = function(container, editor) {\n    'use strict';\n    var fileChooser, // Reference to the file chooser element\n        element, // Scratch variable for creating elements\n        WARNING = \"Everything not saved will be lost\";\n\n    makeNewBoardButton(9); // New 9x9 board button\n    makeNewBoardButton(13); // New 13x13 board button\n    makeNewBoardButton(19); // New 19x19 board button\n    makeNewBoardButton('?'); // New custom board button\n\n    // Hidden file chooser element\n    fileChooser = makeFileChooser();\n    container.appendChild(fileChooser);\n\n    // Load file button\n    element = document.createElement('input');\n    element.type = 'button';\n    element.value = 'Open';\n    element.title = 'Import SGF';\n    element.onclick = function() { // Bind click to the hidden file chooser\n        fileChooser.click();\n    };\n    container.appendChild(element);\n\n    // Save file button\n    element = document.createElement('input');\n    element.type = 'button';\n    element.value = 'Save';\n    element.title = 'Export SGF';\n    element.onclick = function() {\n        var fileName = prompt('Save file as', 'export.sgf');\n        if (fileName) { // Canceled or empty string does nothing\n            saveFile(fileName, besogo.composeSgf(editor));\n        }\n    };\n    container.appendChild(element);\n\n\n    // Makes a new board button\n    function makeNewBoardButton(size) {\n        var button = document.createElement('input');\n        button.type = 'button';\n        button.value = size + \"x\" + size;\n        if (size === '?') { // Make button for custom sized board\n            button.title = \"New custom size board\";\n            button.onclick = function() {\n                var input = prompt(\"Enter custom size for new board\" + \"\\n\" + WARNING, \"19:19\"),\n                    size;\n                if (input) { // Canceled or empty string does nothing\n                    size = besogo.parseSize(input);\n                    editor.loadRoot(besogo.makeGameRoot(size.x, size.y));\n                    editor.setGameInfo({});\n                }\n            };\n        } else { // Make button for fixed size board\n            button.title = \"New \" + size + \"x\" + size + \" board\";\n            button.onclick = function() {\n                if (confirm(button.title + \"?\\n\" + WARNING)) {\n                    editor.loadRoot(besogo.makeGameRoot(size, size));\n                    editor.setGameInfo({});\n                }\n            };\n        }\n        container.appendChild(button);\n    }\n\n    // Creates the file selector\n    function makeFileChooser() {\n        var chooser = document.createElement('input');\n        chooser.type = 'file';\n        chooser.style.display = 'none'; // Keep hidden\n        chooser.onchange = readFile; // Read, parse and load on file select\n        return chooser;\n    }\n\n    // Reads, parses and loads an SGF file\n    function readFile(evt) {\n        var file = evt.target.files[0], // Selected file\n            reader = new FileReader(),\n            newChooser = makeFileChooser(); // Create new file input to reset selection\n\n        container.replaceChild(newChooser, fileChooser); // Replace with the reset selector\n        fileChooser = newChooser;\n\n        reader.onload = function(e){ // Parse and load game tree\n            var sgf;\n            try {\n                sgf = besogo.parseSgf(e.target.result);\n            } catch (error) {\n                alert('SGF parse error at ' + error.at + ':\\n' + error.message);\n                return;\n            }\n            besogo.loadSgf(sgf, editor);\n        };\n        if (confirm(\"Load '\" + file.name + \"'?\\n\" + WARNING)) {\n            reader.readAsText(file); // Initiate file read\n        }\n    }\n\n    // Composes SGF file and initializes download\n    function saveFile(fileName, text) {\n        var link = document.createElement('a'),\n            blob = new Blob([text], { encoding:\"UTF-8\", type:\"text/plain;charset=UTF-8\" });\n\n        link.download = fileName; // Set download file name\n        link.href = URL.createObjectURL(blob);\n        link.style.display = 'none'; // Make link hidden\n        container.appendChild(link); // Add link to ensure that clicking works\n        link.click(); // Click on link to initiate download\n        container.removeChild(link); // Immediately remove the link\n    }\n};\nbesogo.makeGameRoot = function(sizeX, sizeY) {\n    'use strict';\n    var BLACK = -1, // Stone state constants\n        WHITE = 1, // Equal to -BLACK\n        EMPTY = 0, // Any falsy (e.g., undefined) value is also empty\n\n        root = { // Inherited attributes of root node\n            nextToMove: BLACK,\n            blackCaps: 0,\n            whiteCaps: 0,\n            moveNumber: 0\n        };\n\n    // Initializes non-inherited attributes\n    function initNode(node, parent) {\n        node.parent = parent;\n        node.children = [];\n\n        node.move = null;\n        node.setupStones = [];\n        node.markup = [];\n        node.comment = ''; // Comment on this node\n    }\n    initNode(root, null); // Initialize root node with null parent\n\n\n    // Plays a move, returns true if successful\n    // Set allow to truthy to allow overwrite, suicide and ko\n    root.playMove = function(x, y, color, allow) {\n        var captures = 0, // Number of captures made by this move\n            overwrite = false, // Flags whether move overwrites a stone\n            prevMove, // Previous move for ko check\n            testBoard, // Copy of board state to test captures, ko, and suicide\n            pending, // Pending capture locations\n            i; // Scratch iteration variable\n\n        if (!this.isMutable('move')) {\n            return false; // Move fails if node is immutable\n        }\n\n        if (!color) { // Falsy color indicates auto-color\n            color = this.nextToMove;\n        }\n\n        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n            this.move = { // Register as pass move if out of bounds\n                x: 0, y: 0, // Log pass as position (0, 0)\n                color: color,\n                captures: 0, // Pass never captures\n                overwrite: false // Pass is never an overwrite\n            };\n            this.nextToMove = -color; // Update next to move\n            this.moveNumber++; // Increment move number\n            return true; // Pass move successful\n        }\n\n        if (this.getStone(x, y)) { // Check for overwrite\n            if (!allow) {\n                return false; // Reject overwrite move if not allowed\n            }\n            overwrite = true; // Otherwise, flag overwrite and proceed\n        }\n\n        testBoard = Object.create(this); // Copy board state (no need to initialize)\n        pending = []; // Initialize pending capture array\n\n        setStone(testBoard, x, y, color); // Place the move stone\n\n        // Check for captures of surrounding chains\n        captureStones(testBoard, x - 1, y, color, pending);\n        captureStones(testBoard, x + 1, y, color, pending);\n        captureStones(testBoard, x, y - 1, color, pending);\n        captureStones(testBoard, x, y + 1, color, pending);\n\n        captures = pending.length; // Capture count\n\n        prevMove = this.parent ? this.parent.move : null; // Previous move played\n        if (!allow && prevMove && // If previous move exists, ...\n            prevMove.color === -color && // was of the opposite color, ...\n            prevMove.overwrite === false && // not an overwrite, ...\n            prevMove.captures === 1 && // captured exactly one stone, and if ...\n            captures === 1 && // this move captured exactly one stone at the location ...\n            !testBoard.getStone(prevMove.x, prevMove.y) ) { // of the previous move\n                return false; // Reject ko move if not allowed\n        }\n\n        if (captures === 0) { // Check for suicide if nothing was captured\n            captureStones(testBoard, x, y, -color, pending); // Invert color for suicide check\n            captures = -pending.length; // Count suicide as negative captures\n            if (captures < 0 && !allow) {\n                return false; // Reject suicidal move if not allowed\n            }\n        }\n\n        if (color * captures < 0) { // Capture by black or suicide by white\n            this.blackCaps += Math.abs(captures); // Tally captures for black\n        } else { // Capture by white or suicide by black\n            this.whiteCaps += Math.abs(captures); // Tally captures for white\n        }\n\n        setStone(this, x, y, color); // Place the stone\n        for (i = 0; i < pending.length; i++) { // Remove the captures\n            setStone(this, pending[i].x, pending[i].y, EMPTY);\n        }\n\n        this.move = { // Log the move\n            x: x, y: y,\n            color: color,\n            captures: captures,\n            overwrite: overwrite\n        };\n        this.nextToMove = -color; // Update next to move\n        this.moveNumber++; // Increment move number\n        return true;\n    }; // END func root.playMove\n\n    // Check for and perform capture of opposite color chain at (x, y)\n    function captureStones(board, x, y, color, captures) {\n        var pending = [],\n            i; // Scratch iteration variable\n\n        if ( !recursiveCapture(board, x, y, color, pending) ) { // Captured chain found\n            for (i = 0; i < pending.length; i++) { // Remove captured stones\n                setStone(board, pending[i].x, pending[i].y, EMPTY);\n                captures.push(pending[i]);\n            }\n        }\n    }\n\n    // Recursively builds a chain of pending captures starting from (x, y)\n    // Stops and returns true if chain has liberties\n    function recursiveCapture(board, x, y, color, pending) {\n        var i; // Scratch iteration variable\n\n        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n            return false; // Stop if out of bounds\n        }\n        if (board.getStone(x, y) === color) {\n            return false; // Stop if other color found\n        }\n        if (!board.getStone(x, y)) {\n            return true; // Stop and signal that liberty was found\n        }\n        for (i = 0; i < pending.length; i++) {\n            if (pending[i].x === x && pending[i].y === y) {\n                return false; // Stop if already in pending captures\n            }\n        }\n\n        pending.push({ x: x, y: y }); // Add new stone into chain of pending captures\n\n        // Recursively check for liberties and expand chain\n        if (recursiveCapture(board, x - 1, y, color, pending) ||\n            recursiveCapture(board, x + 1, y, color, pending) ||\n            recursiveCapture(board, x, y - 1, color, pending) ||\n            recursiveCapture(board, x, y + 1, color, pending)) {\n                return true; // Stop and signal liberty found in subchain\n        }\n        return false; // Otherwise, no liberties found\n    }\n\n    // Places a setup stone, returns true if successful\n    root.placeSetup = function(x, y, color) {\n        var prevColor = (this.parent && this.parent.getStone(x, y)) || EMPTY;\n\n        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n            return false; // Do not allow out of bounds setup\n        }\n        if (!this.isMutable('setup') || this.getStone(x, y) === color) {\n            // Prevent setup changes in immutable node or quit early if no change\n            return false;\n        }\n\n        setStone(this, x, y, color); // Place the setup stone\n        this.setupStones[ fromXY(x, y) ] = color - prevColor; // Record the necessary change\n        return true;\n    };\n\n    // Adds markup, returns true if successful\n    root.addMarkup = function(x, y, mark) {\n        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {\n            return false; // Do not allow out of bounds markup\n        }\n        if (this.getMarkup(x, y) === mark) { // Quit early if no change to make\n            return false;\n        }\n        this.markup[ fromXY(x, y) ] = mark;\n        return true;\n    };\n\n    // Returns the stone status of the given position\n    root.getStone = function(x, y) {\n        return this['board' + x + '-' + y] || EMPTY;\n    };\n\n    // Directly sets the stone state for the given game node\n    function setStone(node, x, y, color) {\n        node['board' + x + '-' + y] = color;\n    }\n\n    // Gets the setup stone placed at (x, y), returns false if none\n    root.getSetup = function(x, y) {\n        if (!this.setupStones[ fromXY(x, y) ]) { // No setup stone placed\n            return false;\n        } else { // Determine net effect of setup stone\n            switch(this.getStone(x, y)) {\n                case EMPTY:\n                    return 'AE';\n                case BLACK:\n                    return 'AB';\n                case WHITE:\n                    return 'AW';\n            }\n        }\n    };\n\n    // Gets the markup at (x, y)\n    root.getMarkup = function(x, y) {\n        return this.markup[ fromXY(x, y) ] || EMPTY;\n    };\n\n    // Determines the type of this node\n    root.getType = function() {\n        var i;\n\n        if (this.move) { // Logged move implies move node\n            return 'move';\n        }\n\n        for (i = 0; i < this.setupStones.length; i++) {\n            if (this.setupStones[i]) { // Any setup stones implies setup node\n                return 'setup';\n            }\n        }\n\n        return 'empty'; // Otherwise, \"empty\" (neither move nor setup)\n    };\n\n    // Checks if this node can be modified by a 'type' action\n    root.isMutable = function(type) {\n        // Can only add a move to an empty node with no children\n        if (type === 'move' && this.getType() === 'empty' && this.children.length === 0) {\n            return true;\n        }\n        // Can only add setup stones to a non-move node with no children\n        if (type === 'setup' && this.getType() !== 'move' && this.children.length === 0) {\n            return true;\n        }\n        return false;\n    };\n\n    // Gets siblings of this node\n    root.getSiblings = function() {\n        return (this.parent && this.parent.children) || [];\n    };\n\n    // Makes a child node of this node, but does NOT add it to children\n    root.makeChild = function() {\n        var child = Object.create(this); // Child inherits properties\n        initNode(child, this); // Initialize other properties\n\n        return child;\n    };\n\n    // Adds a child to this node\n    root.addChild = function(child) {\n        this.children.push(child);\n    };\n\n    // Remove child node from this node, returning false if failed\n    root.removeChild = function(child) {\n        var i = this.children.indexOf(child);\n        if (i !== -1) {\n            this.children.splice(i, 1);\n            return true;\n        }\n        return false;\n    };\n\n    // Gets board size\n    root.getSize = function() {\n        return { x: sizeX, y: sizeY };\n    };\n\n    return root;\n\n    // Convert (x, y) coordinates to linear index\n    function fromXY(x, y) {\n        return (x - 1) * sizeY + (y - 1);\n    }\n};\n// Load a parsed SGF object into a game state tree\nbesogo.loadSgf = function(sgf, editor) {\n    'use strict';\n    var size = { x: 19, y: 19 }, // Default size (may be changed by load)\n        root;\n\n    loadRootProps(sgf); // Load size, variants style and game info\n    root = besogo.makeGameRoot(size.x, size.y);\n\n    loadNodeTree(sgf, root); // Load the rest of game tree\n    editor.loadRoot(root); // Load root into the editor\n\n\n    // Loads the game tree\n    function loadNodeTree(sgfNode, gameNode) {\n        var i, nextGameNode;\n\n        // Load properties from the SGF node into the game state node\n        for (i = 0; i < sgfNode.props.length; i++) {\n            loadProp(gameNode, sgfNode.props[i]);\n        }\n\n        // Recursively load the rest of the tree\n        for (i = 0; i < sgfNode.children.length; i++) {\n            nextGameNode = gameNode.makeChild();\n            gameNode.addChild(nextGameNode);\n            loadNodeTree(sgfNode.children[i], nextGameNode);\n        }\n    }\n\n    // Loads property into node\n    function loadProp(node, prop) {\n        var setupFunc = 'placeSetup',\n            markupFunc = 'addMarkup',\n            move;\n\n        switch(prop.id) {\n            case 'B': // Play a black move\n                move = lettersToCoords(prop.values[0]);\n                node.playMove(move.x, move.y, -1, true);\n                break;\n            case 'W': // Play a white move\n                move = lettersToCoords(prop.values[0]);\n                node.playMove(move.x, move.y, 1, true);\n                break;\n            case 'AB': // Setup black stones\n                applyPointList(prop.values, node, setupFunc, -1);\n                break;\n            case 'AW': // Setup white stones\n                applyPointList(prop.values, node, setupFunc, 1);\n                break;\n            case 'AE': // Setup empty stones\n                applyPointList(prop.values, node, setupFunc, 0);\n                break;\n            case 'CR': // Add circle markup\n                applyPointList(prop.values, node, markupFunc, 1);\n                break;\n            case 'SQ': // Add square markup\n                applyPointList(prop.values, node, markupFunc, 2);\n                break;\n            case 'TR': // Add triangle markup\n                applyPointList(prop.values, node, markupFunc, 3);\n                break;\n            case 'M': // Intentional fallthrough treats 'M' as 'MA'\n            case 'MA': // Add 'X' cross markup\n                applyPointList(prop.values, node, markupFunc, 4);\n                break;\n            case 'SL': // Add 'selected' (small filled square) markup\n                applyPointList(prop.values, node, markupFunc, 5);\n                break;\n            case 'L': // Intentional fallthrough treats 'L' as 'LB'\n            case 'LB': // Add label markup\n                applyPointList(prop.values, node, markupFunc, 'label');\n                break;\n            case 'C': // Comment placed on node\n                if (node.comment) {\n                    node.comment += '\\n' + prop.values.join().trim();\n                } else {\n                    node.comment = prop.values.join().trim();\n                }\n                break;\n        }\n    } // END function loadProp\n\n    // Extracts point list and calls func on each\n    // Set param to 'label' to signal handling of label markup property\n    function applyPointList(values, node, func, param) {\n        var i, x, y, // Scratch iteration variables\n            point, // Current point in iteration\n            otherPoint, // Bottom-right point of compressed point lists\n            label; // Label extracted from value\n        for (i = 0; i < values.length; i++) {\n            point = lettersToCoords(values[i].slice(0, 2));\n            if (param === 'label') { // Label markup property\n                label = values[i].slice(3).replace(/\\n/g, ' ');\n                node[func](point.x, point.y, label); // Apply with extracted label\n            } else { // Not a label markup property\n                if (values[i].charAt(2) === ':') { // Expand compressed point list\n                    otherPoint = lettersToCoords(values[i].slice(3));\n                    if (otherPoint.x === point.x && otherPoint.y === point.y) {\n                        // Redundant compressed pointlist\n                        node[func](point.x, point.y, param);\n                    } else if (otherPoint.x < point.x || otherPoint.y < point.y) {\n                        // Only apply to corners if not arranged properly\n                        node[func](point.x, point.y, param);\n                        node[func](otherPoint.x, otherPoint.y, param);\n                    } else { // Iterate over the compressed points\n                        for (x = point.x; x <= otherPoint.x; x++) {\n                            for (y = point.y; y <= otherPoint.y; y++) {\n                                node[func](x, y, param);\n                            }\n                        }\n                    }\n                } else { // Apply on single point\n                    node[func](point.x, point.y, param);\n                }\n            }\n        }\n    } // END function applyPointList\n\n    // Loads root properties (size, variant style and game info)\n    function loadRootProps(node) {\n        var gameInfoIds = ['PB', 'BR', 'BT', 'PW', 'WR', 'WT', // Player info\n                'HA', 'KM', 'RU', 'TM', 'OT', // Game parameters\n                'DT', 'EV', 'GN', 'PC', 'RO', // Event info\n                'GC', 'ON', 'RE', // General comments\n                'AN', 'CP', 'SO', 'US' ], // IP credits\n            gameInfo = {}, // Structure for game info properties\n            i, id, value; // Scratch iteration variables\n\n        for (i = 0; i < node.props.length; i++) {\n            id = node.props[i].id; // Property ID\n            value = node.props[i].values.join().trim(); // Join the values array\n            if (id === 'SZ') { // Size property\n                size = besogo.parseSize(value);\n            } else if (id === 'ST') { // Style property\n                editor.setVariantStyle( +value ); // Converts value to number\n            } else if (gameInfoIds.indexOf(id) !== -1) { // Game info property\n                if (id !== 'GC') { // Treat all but GC as simpletext\n                    value = value.replace(/\\n/g, ' '); // Convert line breaks to spaces\n                }\n                if (value) { // Skip load of empty game info strings\n                    gameInfo[id] = value;\n                }\n            }\n        }\n        editor.setGameInfo(gameInfo);\n    }\n\n    // Converts letters to numerical coordinates\n    function lettersToCoords(letters) {\n        if (letters.match(/^[A-Za-z]{2}$/)) { // Verify input is two letters\n            return {\n                x: charToNum(letters.charAt(0)),\n                y: charToNum(letters.charAt(1)) };\n        } else { // Anything but two letters\n            return { x: 0, y: 0 }; // Return (0, 0) coordinates\n        }\n    }\n\n    function charToNum(c) { // Helper for lettersToCoords\n        if ( c.match(/[A-Z]/) ) { // Letters A-Z to 27-52\n            return c.charCodeAt(0) - 'A'.charCodeAt(0) + 27;\n        } else { // Letters a-z to 1-26\n            return c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n        }\n    }\n};\nbesogo.makeNamesPanel = function(container, editor) {\n    'use strict';\n    var playerBox = document.createElement('div'),\n        whiteBox = document.createElement('div'),\n        blackBox = document.createElement('div'),\n        whiteInfo = document.createTextNode(''),\n        blackInfo = document.createTextNode(''),\n        whiteCaps = document.createElement('span'),\n        blackCaps = document.createElement('span');\n\n    playerBox.className = 'besogo-playerInfo';\n    whiteBox.className = 'besogo-whiteInfo';\n    blackBox.className = 'besogo-blackInfo';\n    whiteCaps.className = 'besogo-whiteCaps';\n    whiteCaps.title = 'White captures';\n    blackCaps.className = 'besogo-blackCaps';\n    blackCaps.title = 'Black captures';\n    whiteBox.appendChild(whiteInfo);\n    whiteBox.appendChild(whiteCaps);\n    blackBox.appendChild(blackInfo);\n    blackBox.appendChild(blackCaps);\n    playerBox.appendChild(whiteBox);\n    playerBox.appendChild(blackBox);\n    container.appendChild(playerBox);\n\n    editor.addListener(update);\n    update({ navChange: true, gameInfo: editor.getGameInfo() });\n\n    function update(msg) {\n        var infoString, // Scratch string\n            textNode,\n            current,\n            passFlag = 0;\n\n        if (msg.gameInfo) {\n            infoString = (msg.gameInfo.PW || 'White') + // White name\n                ' (' + (msg.gameInfo.WR || '?') + ')' + // White rank\n                (msg.gameInfo.WT ? ' ' + msg.gameInfo.WT : ''); // White team\n            textNode = document.createTextNode(infoString);\n            whiteBox.replaceChild(textNode, whiteInfo);\n            whiteInfo = textNode;\n\n            infoString = (msg.gameInfo.PB || 'Black') + // Black name\n                ' (' + (msg.gameInfo.BR || '?') + ')' + // Black rank\n                (msg.gameInfo.BT ? ' ' + msg.gameInfo.BT : ''); // Black team\n            textNode = document.createTextNode(infoString);\n            blackBox.replaceChild(textNode, blackInfo);\n            blackInfo = textNode;\n        }\n\n        if (msg.navChange || msg.stoneChange) {\n            current = editor.getCurrent();\n            if (current.move && current.move.x === 0 && current.move.y === 0) {\n                passFlag = current.move.color;\n            }\n            updateText(whiteCaps, (passFlag === 1 ? 'Passed  ' : '') + current.whiteCaps);\n            updateText(blackCaps, current.blackCaps + (passFlag === -1 ? '  Passed' : ''));\n        }\n    }\n\n    function updateText(parent, text) {\n        var textNode = document.createTextNode(text);\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n        parent.appendChild(textNode);\n    }\n};besogo.parseSgf = function(text) {\n    'use strict';\n    var at = 0, // Current position\n        ch = text.charAt(at); // Current character at position\n\n    findOpenParens(); // Find beginning of game tree\n    return parseTree(); // Parse game tree\n\n    // Builds and throws an error\n    function error(msg) {\n        throw {\n            name: \"Syntax Error\",\n            message: msg,\n            at: at,\n            text: text\n        };\n    }\n\n    // Advances text position by one\n    function next(check) {\n        if (check && check !== ch) { // Verify current character if param given\n            error( \"Expected '\" + check + \"' instead of '\" + ch + \"'\");\n        }\n        at++;\n        ch = text.charAt(at);\n        return ch;\n    }\n\n    // Skips over whitespace until non-whitespace found\n    function white() {\n        while (ch && ch <= ' ') {\n            next();\n        }\n    }\n\n    // Skips all chars until '(' or end found\n    function findOpenParens() {\n        while (ch && ch !== '(') {\n            next();\n        }\n    }\n\n    // Returns true if line break (CR, LF, CR+LF, LF+CR) found\n    // Advances the cursor ONCE for double character (CR+LF, LF+CR) line breaks\n    function lineBreak() {\n        if (ch === '\\n') { // Line Feed (LF)\n            if (text.charAt(at + 1) === '\\r') { // LF+CR, double character line break\n                next(); // Advance cursor only once (pointing at second character)\n            }\n            return true;\n        } else if (ch === '\\r') { // Carriage Return (CR)\n            if (text.charAt(at + 1) === '\\n') { // CR+LF, double character line break\n                next(); // Advance cursor only once (pointing at second character)\n            }\n            return true;\n        }\n        return false; // Did not find a line break or advance\n    }\n\n    // Parses a sub-tree of the game record\n    function parseTree() {\n        var rootNode, // Root of this sub-tree\n            currentNode, // Pointer to parent of the next node\n            nextNode; // Scratch for parsing the next node or sub-tree\n\n        next('('); // Double-check opening parens at start of sub-tree\n        white(); // Skip whitespace before root node\n\n        if (ch !== \";\") { // Error on sub-tree missing root node\n            error(\"Sub-tree missing root\");\n        }\n        rootNode = parseNode(); // Get the first node of this sub-tree\n        white(); // Skip whitespace before parsing next node\n\n        currentNode = rootNode; // Parent of the next node parsed\n        while (ch === ';') { // Get sequence of nodes within this sub-tree\n            nextNode = parseNode(); // Parse the next node\n            // Add next node as child of current\n            currentNode.children.push(nextNode);\n            currentNode = nextNode; // Advance current pointer to this child\n            white(); // Skip whitespace between/after sequence nodes\n        }\n\n        // Look for sub-trees of this sub-tree\n        while (ch === \"(\") {\n            nextNode = parseTree(); // Parse the next sub-tree\n            // Add sub-tree as child of last sequence node\n            currentNode.children.push(nextNode); // Do NOT advance current\n            white(); // Skip whitespace between/after sub-trees\n        }\n        next(')'); // Expect closing parenthesis at end of this sub-tree\n\n        return rootNode;\n    }\n\n    // Parses a node and its properties\n    function parseNode() {\n        var property, // Scratch for parsing properties\n            node = { props: [], children: [] }; // Node to construct\n\n        next(';'); // Double-check semi-colon at start of node\n        white(); // Skip whitespace before properties\n        // Parse properties until end of node detected\n        while ( ch && ch !== ';' && ch !== '(' && ch !== ')') {\n            property = parseProperty(); // Parse the property and values\n            node.props.push(property); // Add property to node\n            white(); // Skip whitespace between/after properties\n        }\n\n        return node;\n    }\n\n    // Parses a property and its values\n    function parseProperty() {\n        var property = { id: '', values: [] }; // Property to construct\n\n        // Look for property ID within letters\n        while ( ch && /[A-Za-z]/.test(ch) ) {\n            if (/[A-Z]/.test(ch)) { // Ignores lower case letters\n                property.id += ch; // Only adds upper case letters\n            }\n            next();\n        }\n        if (!property.id) { // Error if id empty\n            error('Missing property ID');\n        }\n\n        white(); // Skip whitespace before values\n        while(ch === '[') { // Look for values of this property\n            property.values.push( parseValue() );\n            white(); // Skip whitespace between/after values\n        }\n        if (property.values.length === 0) { // Error on empty list of values\n            error('Missing property values');\n        }\n\n        return property;\n    }\n\n    // Parses a value\n    function parseValue() {\n        var value = '';\n        next('['); // Double-check opening bracket at start of value\n\n        // Read until end of value (unescaped closing bracket)\n        while ( ch && ch !== ']' ) {\n            if ( ch === '\\\\' ) { // Backslash escape handling\n                next('\\\\');\n                if (lineBreak()) { // Soft (escaped) line break\n                    // Nothing, soft line breaks are removed\n                } else if (ch <= ' ') { // Other whitespace\n                    value += ' '; // Convert to space\n                } else {\n                    value += ch; // Pass other escaped characters verbatim\n                }\n            } else { // Non-escaped character\n                if (lineBreak()) { // Hard (non-escaped) line break\n                    value += '\\n'; // Convert all new lines to just LF\n                } else if (ch <= ' ') { // Other whitespace\n                    value += ' '; // Convert to space\n                } else {\n                    value += ch; // Other characters\n                }\n            }\n            next();\n        }\n        next(']'); // Expect closing bracket at end of value\n\n        return value;\n    }\n};\n// Convert game state tree into SGF string\nbesogo.composeSgf = function(editor) {\n    'use strict';\n    return '(' + composeNode(editor.getRoot()) + ')';\n\n    // Recursively composes game node tree\n    function composeNode(tree) {\n        var string = ';', // Node starts with semi-colon\n            children = tree.children,\n            i; // Scratch iteration variable\n\n        if (!tree.parent) { // Null parent means node is root\n            // Compose root-specific properties\n            string += composeRootProps(tree);\n        }\n        string += composeNodeProps(tree); // Compose general properties\n\n        // Recurse composition on child nodes\n        if (children.length === 1) { // Continue sequence if only one child\n            string += '\\n' + composeNode(children[0]);\n        } else if (children.length > 1) {\n            for (i = 0; i < children.length; i++) {\n                string += '\\n(' + composeNode(children[i]) + ')';\n            }\n        }\n\n        return string;\n    }\n\n    // Composes root specific properties\n    function composeRootProps(tree) {\n        var string = 'FF[4]GM[1]CA[UTF-8]AP[besogo:' + besogo.VERSION + ']',\n            x = tree.getSize().x,\n            y = tree.getSize().y,\n            gameInfo = editor.getGameInfo(), // Game info structure\n            hasGameInfo = false, // Flag for existence of game info\n            id; // Scratch iteration variable\n\n        if (x === y) { // Square board size\n            string += 'SZ[' + x + ']';\n        } else { // Non-square board size\n            string += 'SZ[' + x + ':' + y + ']';\n        }\n        string += 'ST[' + editor.getVariantStyle() + ']\\n'; // Line break after header\n\n        for ( id in gameInfo ) { // Compose game info properties\n            if (gameInfo.hasOwnProperty(id) && gameInfo[id]) { // Skip empty strings\n                string += id + '[' + escapeText(gameInfo[id]) + ']';\n                hasGameInfo = true;\n            }\n        }\n        string += (hasGameInfo ? '\\n' : ''); // Line break if game info exists\n\n        return string;\n    }\n\n    // Composes other properties\n    function composeNodeProps(node) {\n        var string = '',\n            props, // Scratch variable for property structures\n            stone, i, j; // Scratch iteration variables\n\n        // Compose either move or setup properties depending on type of node\n        if (node.getType() === 'move') { // Compose move properties\n            stone = node.move;\n            string += (stone.color === 1) ? 'W' : 'B';\n            string += '[' + coordsToLetters(stone.x, stone.y) + ']';\n        } else if (node.getType() === 'setup') { // Compose setup properties\n            props = { AB: [], AW: [], AE: [] };\n            for (i = 1; i <= node.getSize().x; i++) {\n                for (j = 1; j <= node.getSize().y; j++) {\n                    stone = node.getSetup(i, j);\n                    if (stone) { // If setup stone placed, add to structure\n                        props[ stone ].push({ x: i, y: j });\n                    }\n                }\n            }\n            string += composePointLists(props);\n        }\n\n        // Compose markup properties\n        props = { CR: [], SQ: [], TR: [], MA: [], SL: [], LB: [] };\n        for (i = 1; i <= node.getSize().x; i++) {\n            for (j = 1; j <= node.getSize().y; j++) {\n                stone = node.getMarkup(i, j);\n                if (stone) { // If markup placed\n                    if (typeof stone === 'string') { // String is label mark\n                        props.LB.push({ x: i, y: j, label: stone });\n                    } else { // Numerical code for markup\n                        // Convert numerical code to property ID\n                        stone = (['CR', 'SQ', 'TR', 'MA', 'SL'])[stone - 1];\n                        props[stone].push({ x: i, y: j });\n                    }\n                }\n            }\n        }\n        string += composePointLists(props);\n\n        if (node.comment) { // Compose comment property\n            string += (string ? '\\n' : ''); // Add line break if other properties exist\n            string += 'C[' + escapeText(node.comment) + ']';\n        }\n\n        return string;\n    } // END function composeNodeProps\n\n    // Composes properties from structure of point lists\n    // Each member should be an array of points for property ID = key\n    // Each point should specify point with (x, y) and may have optional label\n    function composePointLists(lists) {\n        var string = '',\n            id, points, i; // Scratch iteration variables\n\n        for (id in lists) { // Object own keys specifies property IDs\n            if (lists.hasOwnProperty(id)) {\n                points = lists[id]; // Corresponding members are point lists\n                if (points.length > 0) { // Only add property if list non-empty\n                    string += id;\n                    for (i = 0; i < points.length; i++) {\n                        string += '[' + coordsToLetters(points[i].x, points[i].y);\n                        if (points[i].label) { // Add optional composed label\n                            string += ':' + escapeText(points[i].label);\n                        }\n                        string += ']';\n                    }\n                }\n            }\n        }\n        return string;\n    }\n\n    // Escapes backslash and close bracket for text output\n    function escapeText(input) {\n        input = input.replace(/\\\\/g, '\\\\\\\\'); // Escape backslash\n        return input.replace(/\\]/g, '\\\\]'); // Escape close bracket\n    }\n\n    // Converts numerical coordinates to letters\n    function coordsToLetters(x, y) {\n        if (x === 0 || y === 0) {\n            return '';\n        } else {\n            return numToChar(x) + numToChar(y);\n        }\n    }\n\n    function numToChar(num) { // Helper for coordsToLetters\n        if (num > 26) { // Numbers 27-52 to A-Z\n            return String.fromCharCode('A'.charCodeAt(0) + num - 27);\n        } else { // Numbers 1-26 to a-z\n            return String.fromCharCode('a'.charCodeAt(0) + num - 1);\n        }\n    }\n};\n(function() {\n'use strict';\n\n// Color palette\nbesogo.RED  = '#be0119'; // Darker red (marked variant)\nbesogo.LRED = '#ff474c'; // Lighter red (auto-marked variant)\nbesogo.BLUE = '#0165fc'; // Bright blue (last move)\nbesogo.PURP = '#9a0eea'; // Red + blue (variant + last move)\nbesogo.GREY = '#929591'; // Between white and black\nbesogo.GOLD = '#dbb40c'; // Tool selection\nbesogo.TURQ = '#06c2ac'; // Turqoise (nav selection)\n\nbesogo.BLACK_STONES = 4; // Number of black stone images\nbesogo.WHITE_STONES = 11; // Number of white stone images\n\n// Makes an SVG element with given name and attributes\nbesogo.svgEl = function(name, attributes) {\n    var attr, // Scratch iteration variable\n        element = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n\n    for ( attr in (attributes || {}) ) { // Add attributes if supplied\n        if (attributes.hasOwnProperty(attr)) {\n            element.setAttribute(attr, attributes[attr]);\n        }\n    }\n    return element;\n};\n\n// Makes an SVG group for containing the shadow layer\nbesogo.svgShadowGroup = function() {\n    var group = besogo.svgEl('g'),\n        filter = besogo.svgEl('filter', { id: 'blur' }),\n        blur = besogo.svgEl('feGaussianBlur', {\n            in: 'SourceGraphic',\n            stdDeviation: '2'\n        });\n\n    filter.appendChild(blur);\n    group.appendChild(filter);\n    return group;\n};\n\n// Makes a stone shadow\nbesogo.svgShadow = function(x, y) {\n    return besogo.svgEl(\"circle\", {\n        cx: x,\n        cy: y,\n        r: 43,\n        stroke: 'none',\n        fill: 'black',\n        opacity: 0.32,\n        filter: 'url(#blur)'\n    });\n};\n\n// Makes a photo realistic stone element\nbesogo.realStone = function(x, y, color, index) {\n    var element;\n\n    if (color < 0) {\n        color = 'black' + (index % besogo.BLACK_STONES);\n    } else {\n        color = 'white' + (index % besogo.WHITE_STONES);\n    }\n    color = '_' + color + '.png';\n\n    element =  besogo.svgEl(\"image\", {\n        x: (x - 44),\n        y: (y - 44),\n        height: 88,\n        width: 88\n    });\n    element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', color);\n\n    return element;\n};\n\n// Makes a stone element\nbesogo.svgStone = function(x, y, color) {\n    var className = \"besogo-svg-greyStone\"; // Grey stone by default\n\n    if (color === -1) { // Black stone\n        className = \"besogo-svg-blackStone\";\n    } else if (color === 1) { // White stone\n        className = \"besogo-svg-whiteStone\";\n    }\n\n    return besogo.svgEl(\"circle\", {\n        cx: x,\n        cy: y,\n        r: 42,\n        'class': className\n    });\n};\n\n// Makes a circle at (x, y)\nbesogo.svgCircle = function(x, y, color) {\n    return besogo.svgEl(\"circle\", {\n        cx: x,\n        cy: y,\n        r: 27,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes a square at (x, y)\nbesogo.svgSquare = function(x, y, color) {\n    return besogo.svgEl(\"rect\", {\n        x: (x - 23),\n        y: (y - 23),\n        width: 46,\n        height: 46,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes an equilateral triangle at (x, y)\nbesogo.svgTriangle = function(x, y, color) {\n    // Approximates an equilateral triangle centered on (x, y)\n    var pointString = \"\" + x + \",\" + (y - 30) + \" \" +\n        (x - 26) + \",\" + (y + 15) + \" \" +\n        (x + 26) + \",\" + (y + 15);\n\n    return besogo.svgEl(\"polygon\", {\n        points: pointString,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes an \"X\" cross at (x, y)\nbesogo.svgCross = function(x, y, color) {\n    var path = \"m\" + (x - 24) + \",\" + (y - 24) + \"l48,48m0,-48l-48,48\";\n\n    return besogo.svgEl(\"path\", {\n        d: path,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes an \"+\" plus sign at (x, y)\nbesogo.svgPlus = function(x, y, color) {\n    var path = \"m\" + x + \",\" + (y - 28) + \"v56m-28,-28h56\";\n\n    return besogo.svgEl(\"path\", {\n        d: path,\n        stroke: color,\n        \"stroke-width\": 8,\n        fill: \"none\"\n    });\n};\n\n// Makes a small filled square at (x, y)\nbesogo.svgBlock = function(x, y, color) {\n    return besogo.svgEl(\"rect\", {\n        x: x - 18,\n        y: y - 18,\n        width: 36,\n        height: 36,\n        stroke: \"none\",\n        \"stroke-width\": 8,\n        fill: color\n    });\n};\n\n// Makes a label at (x, y)\nbesogo.svgLabel = function(x, y, color, label) {\n    var element,\n        size;\n\n    // Trims label to 3 characters\n    if (label.length > 3) {\n        label = label.slice(0, 2) + '…';\n    }\n\n    // Set font size according to label length\n    switch(label.length) {\n        case 1:\n            size = 72;\n            break;\n        case 2:\n            size = 56;\n            break;\n        case 3:\n            size = 36;\n            break;\n    }\n\n    element = besogo.svgEl(\"text\", {\n        x: x,\n        y: y,\n        dy: \".65ex\", // Seems to work for vertically centering these fonts\n        \"font-size\": size,\n        \"text-anchor\": \"middle\", // Horizontal centering\n        \"font-family\": \"Helvetica, Arial, sans-serif\",\n        fill: color\n    });\n    element.appendChild( document.createTextNode(label) );\n\n    return element;\n};\n\n})(); // END closure\nbesogo.makeToolPanel = function(container, editor) {\n    'use strict';\n    var element, // Scratch for building SVG images\n        svg, // Scratch for building SVG images\n        labelText, // Text area for next label input\n        selectors = {}, // Holds selection rects\n        passButton = document.createElement('input'),\n        cutButton = document.createElement('input');\n\n    svg = makeButtonSVG('auto', 'Auto-play/nav'); // Auto-play/nav tool button\n    svg.appendChild(makeYinYang(0, 0));\n\n    svg = makeButtonSVG('playB', 'Play black'); // Play black button\n    svg.appendChild(besogo.svgStone(0, 0, -1));\n\n    svg = makeButtonSVG('playW', 'Play white'); // Play white button\n    svg.appendChild(besogo.svgStone(0, 0, 1));\n\n    svg = makeButtonSVG('addB', 'Set black'); // Add black button\n    element = besogo.svgEl('g');\n    element.appendChild(besogo.svgStone(0, 0, -1)); // Black stone\n    element.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n    svg.appendChild(element);\n\n    svg = makeButtonSVG('addW', 'Set white'); // Add white button\n    element = besogo.svgEl('g');\n    element.appendChild(besogo.svgStone(0, 0, 1)); // White stone\n    element.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus\n    svg.appendChild(element);\n\n    svg = makeButtonSVG('addE', 'Set empty'); // Add empty button\n    element = besogo.svgEl('g');\n    element.appendChild(besogo.svgStone(0, 0)); // Grey stone\n    element.appendChild(besogo.svgCross(0, 0, besogo.RED)); // Red cross\n    svg.appendChild(element);\n\n    svg = makeButtonSVG('circle', 'Circle'); // Circle markup button\n    svg.appendChild(besogo.svgCircle(0, 0, 'black'));\n\n    svg = makeButtonSVG('square', 'Square'); // Square markup button\n    svg.appendChild(besogo.svgSquare(0, 0, 'black'));\n\n    svg = makeButtonSVG('triangle', 'Triangle'); // Triangle markup button\n    svg.appendChild(besogo.svgTriangle(0, 0, 'black'));\n\n    svg = makeButtonSVG('cross', 'Cross'); // Cross markup button\n    svg.appendChild(besogo.svgCross(0, 0, 'black'));\n\n    svg = makeButtonSVG('block', 'Block'); // Block markup button\n    svg.appendChild(besogo.svgBlock(0, 0, 'black'));\n\n    svg = makeButtonSVG('clrMark', 'Clear mark'); // Clear markup button\n    element = besogo.svgEl('g');\n    element.appendChild(besogo.svgTriangle(0, 0, besogo.GREY));\n    element.appendChild(besogo.svgCross(0, 0, besogo.RED));\n    svg.appendChild(element);\n\n    svg = makeButtonSVG('label', 'Label'); // Label markup button\n    svg.appendChild(besogo.svgLabel(0, 0, 'black', 'A1'));\n\n    labelText = document.createElement(\"input\"); // Label entry text field\n    labelText.type = \"text\";\n    labelText.title = 'Next label';\n    labelText.onblur = function() {\n        editor.setLabel(labelText.value);\n    };\n    labelText.addEventListener('keydown', function(evt) {\n        evt = evt || window.event;\n        evt.stopPropagation(); // Stop keydown propagation when in focus\n    });\n    container.appendChild(labelText);\n\n    passButton.type = 'button';\n    passButton.value = 'Pass';\n    passButton.title = 'Pass move';\n    passButton.onclick = function() {\n        var tool = editor.getTool();\n        if (tool !== 'navOnly' && tool !== 'auto' && tool !== 'playB' && tool !== 'playW') {\n            editor.setTool('auto'); // Ensures that a move tool is selected\n        }\n        editor.click(0, 0, false); // Clicking off the board signals a pass\n    };\n    container.appendChild(passButton);\n\n    cutButton.type = 'button';\n    cutButton.value = 'Cut';\n    cutButton.title = 'Remove branch';\n    cutButton.onclick = function() {\n        editor.cutCurrent();\n    };\n    container.appendChild(cutButton);\n\n    editor.addListener(toolStateUpdate); // Set up listener for tool state updates\n    toolStateUpdate({ label: editor.getLabel(), tool: editor.getTool() }); // Initialize\n\n\n    // Creates a button holding an SVG image\n    function makeButtonSVG(tool, tooltip) {\n        var button = document.createElement('button'),\n            svg = besogo.svgEl('svg', { // Icon container\n                width: '100%',\n                height: '100%',\n                viewBox: '-55 -55 110 110' }), // Centered on (0, 0)\n            selected = besogo.svgEl(\"rect\", { // Selection rectangle\n                x: -50, // Center on (0, 0)\n                y: -50,\n                width: 100,\n                height: 100,\n                fill: 'none',\n                'stroke-width': 8,\n                stroke: besogo.GOLD,\n                rx: 20, // Rounded rectangle\n                ry: 20, // Thanks, Steve\n                visibility: 'hidden'\n            });\n\n        container.appendChild(button);\n        button.appendChild(svg);\n        button.onclick = function() {\n            editor.setTool(tool);\n        };\n        button.title = tooltip;\n        selectors[tool] = selected;\n        svg.appendChild(selected);\n        return svg; // Returns reference to the icon container\n    }\n\n    // Callback for updating tool state and label\n    function toolStateUpdate(msg) {\n        var tool;\n        if (msg.label) {\n            labelText.value = msg.label;\n        }\n        if (msg.tool) {\n            for (tool in selectors) { // Update which tool is selected\n                if (selectors.hasOwnProperty(tool)) {\n                    if (msg.tool === tool) {\n                        selectors[tool].setAttribute('visibility', 'visible');\n                    } else {\n                        selectors[tool].setAttribute('visibility', 'hidden');\n                    }\n                }\n            }\n        }\n    }\n\n    // Draws a yin yang\n    function makeYinYang(x, y) {\n        var element = besogo.svgEl('g');\n\n        // Draw black half circle on right side\n        element.appendChild( besogo.svgEl(\"path\", {\n            d: \"m\" + x + \",\" + (y - 44) + \" a44 44 0 0 1 0,88z\",\n            stroke: \"none\",\n            fill: \"black\"\n        }));\n\n        // Draw white part of ying yang on left side\n        element.appendChild( besogo.svgEl(\"path\", {\n            d: \"m\" + x + \",\" + (y + 44) + \"a44 44 0 0 1 0,-88a22 22 0 0 1 0,44z\",\n            stroke: \"none\",\n            fill: \"white\"\n        }));\n\n        // Draw round part of black half of ying yang\n        element.appendChild( besogo.svgEl(\"circle\", {\n            cx: x,\n            cy: y + 22,\n            r: 22,\n            stroke: \"none\",\n            fill: \"black\"\n        }));\n\n        return element;\n    }\n};\nbesogo.makeTreePanel = function(container, editor) {\n    'use strict';\n    var svg,\n        pathGroup,\n        bottomLayer,\n        currentMarker,\n        SCALE = 0.25; // Tree size scaling factor\n\n    rebuildNavTree();\n    editor.addListener(treeUpdate);\n\n\n    // Callback for handling tree changes\n    function treeUpdate(msg) {\n        if (msg.treeChange) { // Tree structure changed\n            rebuildNavTree(); // Rebuild entire tree\n        } else if (msg.navChange) { // Only navigation changed\n            updateCurrentMarker(); // Update current location marker\n        } else if (msg.stoneChange) { // Only stones in current changed\n            updateCurrentNodeIcon();\n        }\n    }\n\n    // Updates the current marker in the tree\n    function updateCurrentMarker() {\n        var current = editor.getCurrent();\n\n        setSelectionMarker(currentMarker);\n        setCurrentMarker(current.navTreeMarker);\n    }\n\n    // Sets marker element to indicate the current node\n    function setCurrentMarker(marker) {\n        var width = container.clientWidth,\n            height = container.clientHeight,\n            top = container.scrollTop,\n            left = container.scrollLeft,\n            markX = (marker.getAttribute('x') - 5) * SCALE, // Computed position of marker\n            markY = (marker.getAttribute('y') - 5) * SCALE,\n            GRIDSIZE = 120 * SCALE; // Size of the square grid\n\n        if (markX < left) { // Ensure horizontal visibility of current marker\n            container.scrollLeft = markX;\n        } else if (markX + GRIDSIZE > left + width) {\n            container.scrollLeft = markX + GRIDSIZE - width;\n        }\n        if (markY < top) { // Ensure vertical visibility of current marker\n            container.scrollTop = markY;\n        } else if (markY + GRIDSIZE > top + height) {\n            container.scrollTop = markY + GRIDSIZE - height;\n        }\n\n        marker.setAttribute('opacity', 1); // Always visible\n        marker.onmouseover = null; // Clear hover over action\n        marker.onmouseout = null; // Clear hover off action\n        bottomLayer.appendChild(marker); // Moves marker to the background\n        currentMarker = marker;\n    }\n\n    // Sets marker\n    function setSelectionMarker(marker) {\n        marker.setAttribute('opacity', 0); // Normally invisible\n        marker.onmouseover = function() { // Show on hover over\n            marker.setAttribute('opacity', 0.5);\n        };\n        marker.onmouseout = function() { // Hide on hover off\n            marker.setAttribute('opacity', 0);\n        };\n        svg.appendChild(marker); // Move marker to foreground\n    }\n\n    // Rebuilds the entire navigation tree\n    function rebuildNavTree() {\n        var current = editor.getCurrent(), // Current location in game state tree\n            root = editor.getRoot(), // Root node of game state\n            nextOpen = [], // Tracks occupied grid positions\n            oldSvg = svg, // Store the old SVG root\n            background = besogo.svgEl(\"rect\", { // Background color for tree\n                height: '100%',\n                width: '100%',\n                'class': 'besogo-svg-board'\n            }),\n            path, // Root path\n            width, // Calculated dimensions of the SVG\n            height;\n\n        svg = besogo.svgEl(\"svg\");\n        bottomLayer = besogo.svgEl(\"g\"); // Holder for the current marker\n        pathGroup = besogo.svgEl(\"g\"); // Holder for path elements\n\n        svg.appendChild(background); // Background color first\n        svg.appendChild(bottomLayer); // Bottom layer (for current marker) second\n        svg.appendChild(pathGroup); // Navigation path third\n\n        path = recursiveTreeBuild(root, 0, 0, nextOpen); // Build the tree\n        pathGroup.appendChild(finishPath(path, 'black')); // Finish and add root path\n\n        width = 120 * nextOpen.length; // Compute height and width of nav tree\n        height = 120 * Math.max.apply(Math, nextOpen);\n        svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);\n        svg.setAttribute('height', height * SCALE); // Scale down the actual SVG size\n        svg.setAttribute('width', width * SCALE);\n\n        if (oldSvg) { // Replace SVG in container\n            container.replaceChild(svg, oldSvg);\n        } else { // SVG not yet added to container\n            container.appendChild(svg);\n        }\n\n        setCurrentMarker(current.navTreeMarker); // Set current marker and ensure visible\n    } // END function rebuildNavTree\n\n    // Recursively builds the tree\n    function recursiveTreeBuild(node, x, y, nextOpen) {\n        var children = node.children,\n            position,\n            path,\n            childPath,\n            i; // Scratch iteration variable\n\n        if (children.length === 0) { // Reached end of branch\n            path = 'm' + svgPos(x) + ',' + svgPos(y); // Start path at end of branch\n        } else { // Current node has children\n            position = (nextOpen[x + 1] || 0); // First open spot in next column\n            position = (position < y) ? y : position; // Bring level with current y\n\n            if (y < position - 1) { // Check if first child natural drop > 1\n                y = position - 1; // Bring current y within 1 of first child drop\n            }\n            // Place first child and extend path\n            path = recursiveTreeBuild(children[0], x + 1, position, nextOpen) +\n                extendPath(x, y, nextOpen);\n\n            // Place other children (intentionally starting at i = 1)\n            for (i = 1; i < children.length; i++) {\n                position = nextOpen[x + 1];\n                childPath = recursiveTreeBuild(children[i], x + 1, position, nextOpen) +\n                    extendPath(x, y, nextOpen, position - 1);\n                // End path at beginning of branch\n                pathGroup.appendChild(finishPath(childPath, 'black'));\n            }\n        }\n        svg.appendChild(makeNodeIcon(node, x, y));\n        addSelectionMarker(node, x, y);\n\n        nextOpen[x] = y + 1; // Claims (x, y)\n        return path;\n    } // END function recursiveTreeBuild\n\n    function makeNodeIcon(node, x, y) { // Makes a node icon for the tree\n        var element,\n            color;\n\n        switch(node.getType()){\n            case 'move': // Move node\n                color = node.move.color;\n                element = besogo.svgEl(\"g\");\n                element.appendChild( besogo.svgStone(svgPos(x), svgPos(y), color) );\n                color = (color === -1) ? \"white\" : \"black\";\n                element.appendChild( besogo.svgLabel(svgPos(x), svgPos(y), color,\n                    '' + node.moveNumber) );\n                break;\n            case 'setup': // Setup node\n                element = besogo.svgEl(\"g\");\n                element.appendChild(besogo.svgStone(svgPos(x), svgPos(y))); // Grey stone\n                element.appendChild(besogo.svgPlus(svgPos(x), svgPos(y), besogo.RED));\n                break;\n            default: // Empty node\n                element = besogo.svgStone(svgPos(x), svgPos(y)); // Grey stone\n        }\n        node.navTreeIcon = element; // Save icon reference in game state tree\n        node.navTreeX = x; // Save position of the icon\n        node.navTreeY = y;\n\n        return element;\n    } // END function makeNodeIcon\n\n    function updateCurrentNodeIcon() { // Updates the current node icon\n        var current = editor.getCurrent(), // Current location in game state tree\n            oldIcon = current.navTreeIcon,\n            newIcon = makeNodeIcon(current, current.navTreeX, current.navTreeY);\n        svg.replaceChild(newIcon, oldIcon);\n    }\n\n    function addSelectionMarker(node, x, y) {\n        var element = besogo.svgEl(\"rect\", { // Create selection marker\n            x: svgPos(x) - 55,\n            y: svgPos(y) - 55,\n            width: 110,\n            height: 110,\n            fill: besogo.TURQ\n        });\n        element.onclick = function() {\n            editor.setCurrent(node);\n        };\n\n        node.navTreeMarker = element; // Save selection marker in node\n        setSelectionMarker(element); // Add as and set selection marker properties\n    }\n\n    function extendPath(x, y, nextOpen, prevChildPos) { // Extends path from child to current\n        var childPos = nextOpen[x + 1] - 1; // Position of child\n        if (childPos === y) { // Child is horizontally level with current\n            return 'h-120'; // Horizontal line back to current\n        } else if (childPos === y + 1) { // Child is one drop from current\n            return 'l-120,-120'; // Diagonal drop line back to current\n        } else if (prevChildPos && prevChildPos !== y) {\n            // Previous is already dropped, extend back to previous child drop line\n            return 'l-60,-60v-' + (120 * (childPos - prevChildPos));\n        } else { // Extend double-bend drop line back to parent\n            return 'l-60,-60v-' + (120 * (childPos - y - 1)) + 'l-60,-60';\n        }\n    }\n\n    function finishPath(path, color) { // Finishes path element\n        var element = besogo.svgEl(\"path\", {\n            d: path,\n            stroke: color,\n            \"stroke-width\": 8,\n            fill: \"none\"\n        });\n        return element;\n    }\n\n    function svgPos(x) { // Converts (x, y) coordinates to SVG position\n        return (x * 120) + 60;\n    }\n};\nbesogo.autoInit()\n</script>\n<style>\n.besogo-container {\n\tborder: 5px solid indianred;\n\tborder-radius:6px;\n}\n\n\n.besogo-control  {\n    max-width:400px;\n\tmargin:auto;\n\tmargin-top:10px;\n}\n\n[title=\"Variants: [child]/sibling\"], [title=\"Variants: show/[hide]\"], [title=\"Toggle coordinates\"], .besogo-gameInfo {    \ndisplay: none!important;\n}\n\n.besogo-comment > div {\nvisibility: visible;\nmargin-top:10px;\n\tborder-bottom-left-radius: 10px;\n\tborder-bottom-right-radius: 10px;\n    padding: 25px;\n    color: #D7DEE9; /* FONT COLOR */\n    background-color: #333B45; /* BACKGROUND COLOR */\n\n}\n\n.card {\n\n\theight: 85%;\n\n}\n\n</style>\n\n\n\n\n\n"
                }
            ],
            "type": 0,
            "vers": []
        }
    ],
    "notes": []
}